<?php
/******************************************************************************
  Abstract Store 1.0						Ariadne 2.0

  Copyright (C) 1998,1999  Muze 

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

  --------------------------------------------------------------------------

  This is the abstract store class. It does nothing.

  The store class is an interface between Ariadne objects and a storage layer. 
  It is used by all Ariadne objects to call templates in other objects or to 
  manipulate the location and contents of objects in the Ariadne system.

*******************************************************************************/

// debugging functions.

function debug($text) {
	global $_debug;
	if ($_debug) {
		echo "<b>$text</b><BR>\n";
	}
}

function debugon() {
	global $_debug;
	$_debug=1;
	debug("Debugging on.");
}

function debugoff() {
	global $_debug;
	debug("Debugging off.");
	$_debug=0;
}

function error($text) {
	echo "// <b>Error: $text</b><BR>\n<!--\nalert('Error: $text');\n// -->\n";
}

// general objectstore functions

class store {

	var $error;
	var $root;
	var $code;
	
	function store($path, &$config) {
	/**********************************************************************************
		
	 This is the constructor routine for the store object. 

	 $path is the root path of the running script under the document root of				
		the webserver.
	 $config["code"] contains the location of the class files for all the used types.

	 **********************************************************************************/

		debug("Store init");
		$this->error="";
		$this->root=$path;
		$this->code=$config["code"];
	}

	function call($template, $args, $objects) {
	/**********************************************************************************
	
	 This function takes a list of objects, the function to be called in each of those
	 objects and the arguments of that function as arguments. The list of objects is of
	 unspecified type and may be different in other implementations of the store 
	 interface.

	 The function must retrieve and instantiate each object in the object list and call
	 the objects call with $function and $args.

	 **********************************************************************************/ 

		debug("store->call: start");
		$this->error="";
	}

	function get($path) {
	/**********************************************************************************

	 This function takes as argument a path to an object in the store and must retrieve
	 all the necessary data and return this in the objectlist type needed for 
	 store->call(). If the requested path does not exist, it must retrieve the object
	 with the longest matching path.

	 $path should always start and end with a '/'.

	 **********************************************************************************/

		debug("store->get: start ($path)");
		$this->error="";
		$result["method"]="get";
		$result["path"]=$path;
		debug("store->get: end");
		return $result;
	}

	function ls($path) {
	/**********************************************************************************

	 This function takes as argument a path to an object in the store and must retrieve
	 all the objects and their data which have this object as their parent. It must 
	 then return this in the objectlist type needed for store->call(). If the requested
	 path does not exist, it must retrieve the object with the longest matching path.

	 $path should always start and end with a '/'.

	 **********************************************************************************/

		debug("store->ls: ($path)");
		$this->error="";
		$result["method"]="ls";
		$result["path"]=$path;
		debug("store->ls: end");
		return $result;
	}

	function parents($path) {
	/**********************************************************************************

	 This function takes as argument a path to an object in the store. It must return 
	 all objects with a path which is a substring of the given path. The resulsts are 
	 ordered by path (length), shortest paths first.
	 In effect all parents of an object in the tree are called, in order, starting at 
	 the root.

	 $path should always start and end with a '/'.

	 **********************************************************************************/

		debug("store->parents: ($path)");
		$this->error="";
		$result["method"]="parents";
		$result["path"]=$path;
		debug("store->parents: end");
		return $result;
	}

	function find($path, $criteria, $limit=100, $offset=0) {
	/**********************************************************************************

	 This function takes as arguments a path to an object in the store and some search
	 criteria. It must search for all matching objects under the given path. If the
	 given path is not in this store but in a substore it will not automatically search
	 that substore. 

	 $criteria is of the form 

	 $criteria ::= ({ $property_name => ({ $valuename => ({ $compare_function, $value }) }) }) 

	 e.g.: $criteria["status"]["value"][">"]="'published'";

	 $path should always start and end with a '/'.

	 **********************************************************************************/

		debug("store->find: ($path)");
		$this->error="";
		$result["method"]="find";
		$result["path"]=$path;
		$result["criteria"]=$criteria;
		while (list($property, $values)=@each($criteria)) {
			while (list($valuename, $compare)=each($values)) {
				while (list($function, $value)=each($compare)) {
					if ($value=="") {
						$value=0;
					}
					switch($property) {
						case "object" : // system defined property
							switch($valuename) {
								case ("type") : 
															break;
								case ("implements") : 
															break;
								case ("parent") :
															break;
								case ("lastchange") :
															break;
							}
							break;
						default :
					}
				}
			}
			if ($property!="object") {

			}
		}
		debug("store->find: end");
		return $result;
	}

	function close() {
	// This is the destructor function.

		debug("store->close.");
	}

	function save($path, $type, &$data, $properties="", $vtype="") {
	/***************************************************************

	 This function takes as argument a path, type, objectdata and 
	 possibly a properties list and vtype (virtual type).
	 If there exists no object with the given path, a new object is 
	 saved with the given type, data, properties and vtype, and a
	 new path is saved pointing to it.
	 If there does exist an object with the given path, it's object
	 data is overwritten with the given data and if vtype is set the
	 current vtype is overwritten with the new one.
		
	 $path must be an absolute path (containing no '..' and starting
	 	with '/')
	 $type must be a valid type
	 $data can be any string (usually a serialized object.)
	 $properties is a multidimensional hash of the following form:
	 	$properties[{property_name}][][{value_name}]={value}
	 	{property_name} must be a valid property name
	 	{value_name} must be a valid value name for this property
		{value} can be a number, boolean or string. If it is a string
			it must be enclosed in single qoutes. All other single 
			quotes in the string must be escaped. e.g:
			"'\'t is a String'"
	 example:
		$properties["name"][0]["value"]="'A name'";
		$properties["name"][1]["value"]="'A second name!'";
	 if $properties["name"]=1 then all properties for property name
		will be removed.

	 $vtype must be a valid type.
	 
	 if $properties or $vtype are not set or empty ("",0 or false)
	 they will be ignored. $vtype defaults to $type.
	 Only those properties listed in $properties will be updated.
	 Any other property set will remain as it was.

	***************************************************************/

		debug("store->save: ($path type=$type vtype=$vtype)");
		$this->error="";
		$parent=$this->make_path($path, "..");
		if (ereg("{([0-9]):id}",$path,$match)) { 
			// if the last part of a path matches something like {2:id} this
			// part will automatically create a new number, unique in this directory, and fill it in.
			$subid=$this->nextid($parent);
			if ($match[1]) { 
				$subid=substr("000000000".$subid,-(intval($match[1])));
			}
			$path=ereg_replace("{[0-9]:id}",strval($subid),$path);
			debug("store->save: new path: $path ($subid)");
		}
		if ($id=$this->exists($path)) { //update
			if ($vtype) { // only change/save vtype if it is explicitly set
				// update object and set virtual type
			} else {
				// update object 
			}
			$this->save_properties($properties, $id); 
		} else { // insert new
			if ($vtype=="") { // if vtype is not set, it defaults to type for new objects
				$vtype=$type; 
			}
			// insert new object
			$this->save_properties($properties, $id);
		}
		debug("store->save: end");
		return $result;
	}

	function purge($path) {
	/**********************************************************************
	 
	 This function must delete the object pointed to by $path and all
	other paths pointing to that object. It must then remove any property
	for this object from all property types.
	 The function returns the number of paths found and removed or 1 if
	there was no path found (meaning that the object doesn't exist and 
	therefor purge succeeded while doing nothing.)

	 $path should always start and end with a '/'.

	**********************************************************************/

		debug("store->purge: ($path)");
		$this->error="";
		$object=$this->exists($path);
		if ($object) {
			// remove object
			$this->del_property($object);
		} else { // no such path, so purge already succeeded :)
			$result=1;
		}
		debug("store->purge: end");
		return $result;
	}

	function delete($path) {
	/**********************************************************************

	 This function deletes the path given. If this is the last path pointing
	to an object, the object must be purged instead.

	$path should always start and end with a '/'.

	**********************************************************************/

		debug("store->delete: ($path)");
		$this->error="";
		$paths=$this->list_paths($path);
		if ($paths) {
			if (sizeof($paths)==1) { // only one path for this object
				$result=$this->purge($path); // therefore purge the object.
			} else { // only delete the given path
				// remove $path
			}
		}
		debug("store->delete: end");
		return $result;
	}

	function exists($path) {
	/**********************************************************************

	 This function checks the given path to see if it exists. If it does
	it returns the id of the object to which it points. Otherwise it returns
	0.

	$path should always start and end with a '/'.

	**********************************************************************/

		debug("store->exists: ($path)");
		$this->error="";
		// find unique object id for the given path.
		//	 this cannot simply be the path, as an object can have multiple 
		//	 paths but must have only one, unique, id.
		return $object;
	}


	function link($source, $destination) {
	/**********************************************************************

	 Link adds an extra path to an already existing object. It has two
	arguments: $source and $destination. $source is an existing path of
	an object, $destination is the new path. $destination must not already
	exist.

	$destination should always start and end with a '/'.

	**********************************************************************/

		debug("store->link: ($destination from $source)");
		$this->error="";
		$parent=$this->make_path($destination, "..");
		if ($this->exists($destination)) {
			$this->error="$destination already exists, cannot overwrite.";
			$result=0;
		} else { 
			if (ereg("{([0-9]):id}",$destination,$match)) {
				$subid=$this->nextid($parent);
				if ($match[1]) {
					$subid=substr("000000000".$subid,-(intval($match[1])));
				}
				$destination=ereg_replace("{[0-9]:id}",strval($subid),$destination);
				debug("store->link: new destination: $destination ($subid)");
			}
			$id=$this->exists($source);
			if ($id) {
				// add new path $destination for object with id $id
				debug("store->link: end");
				$result=$destination;
			}
		}
		debug("store->link: end (no $source)");
		return $result;
	}

	function list_paths($path) {
	/**********************************************************************

	 This function returns an array of all paths pointing to the same object 
	as $path does.

	**********************************************************************/

		debug("store->list_paths: start");
		$this->error="";
		$object=$this->exists($path);
		// find all paths pointing to the object with id $object
		debug("store->list_paths: end");
		return $result;
	}

	function implements($type, $implements) {
	/**********************************************************************

	 This function returns 1 if the $type implements the type or
	interface in $implements. Otherwise it returns 0.

	 $type and $implements are strings of at most 16 characters.
	**********************************************************************/

		$this->error="";
		// check to see whether $type implements $implements. 
		//	 $implements can be another type or any string.
		return $result;
	}
	
	function make_path($curr_dir, $path) {
	/**********************************************************************
 
	 This function creates an absolute path from the given starting path
	($curr_dir) and a relative (or absolute) path ($path). If $path starts
	with a '/' $curr_dir is ignored. 
	$path must be a string of substrings seperated by '/'. each of these 
	substrings may consist of charachters and/or numbers. If a substring
	is "..", it and the previuos substring will be removed. If a substring
	is "." or "", it is removed. All other substrings are then concatenated
	with a '/' between them and at the start and the end. This string is 
	then returned.

	**********************************************************************/

		debug("store->make_path: ($path from $curr_dir)");		
		$this->error="";
		if (substr($path,0,1)=="/") {
			$result="/";
			$path=substr($path, 1);
		} else {
			$result=$curr_dir;
		}
		if (substr($path,-1)=="/") {
			$path=substr($path, 0, -1);
		}
		if ($path) {
			$splitpath=split("/", $path);
			while (list($key, $pathticle)=each($splitpath)) {
				switch($pathticle) {
					case ".." : $result=substr($result, 0, strrpos(substr($result,0,-1), "/")+1);
								break;
					case "." : break;
					case ""	 : break;
					default	 : $result=$result.$pathticle."/";
				}
			}
		}
		debug("store->make_path: end");		
		return $result;
	}

	function save_properties($properties, $id) {
	/********************************************************************

	 'private' function of mysql.phtml. It updates all property tables
	defined in $properties and sets the values to the values in
	$properties.

	********************************************************************/

		if ($properties && (is_array($properties)) && (is_int($id))) {
			while (list($property, $property_set)=each($properties)) {
				$this->del_property($id, $property);
				if (is_array($property_set)) {
					while (list($key, $values)=each($property_set)) {
						$this->add_property($id, $property, $values);
					}
				}
			}
		}
	}

	function add_property($object, $property, $values) {
		if ($object) {
			while (list($name, $value)=each($values)) {
				if ($value!="") {
					// add ($name, $value) pair for $property
				}
			}
		}
		return $result;
	}

	function del_property($object, $property="", $values="") {
		if (intval($object)) {
			if (!$property) { 
				// remove all properties for $object
			} else {
				if (is_array($values)) {
					while (list($name, $value)=each($values)) {
						// add ($name, $value) to check list
					} 
				}
				// remove all values of $property corresponding with
				// the (name, value) pairs in the checklist.
			}
		}
		return $result;
	}

	function nextid($path) {
	/**********************************************************************

	 'private' function of mysql store. Used by link and save.
	 This function calculates and returns the next unused id (number) for 
	the given path. 

	**********************************************************************/

		// calculate unique id per path.
		return $id;
	}

} // end class store

?>