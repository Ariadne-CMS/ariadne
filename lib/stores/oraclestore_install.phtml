<?php
/******************************************************************************
  Oracle install Store 1.0b						Ariadne 2.4

  Copyright (C) 1998-2004  Muze 

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

  --------------------------------------------------------------------------

  This is an implementation of the install store class for Oracle. 

*******************************************************************************/

include_once($ariadne."/stores/oraclestore.phtml");

class oraclestore_install extends oraclestore {

	function initialize() {
		echo "initializing oracle store.\n";
		$i = 0;

		$queries[$i]["query_string"] = "drop table ".$this->tbl_prefix."nodes"; 
		$queries[$i]["msg"] = $queries[$i]["query_string"];
		$i++;

		$queries[$i]["msg"]="creating nodes table.";
		$queries[$i]["query_string"]="
			CREATE TABLE ".$this->tbl_prefix."nodes (
				path varchar2(127) DEFAULT '' NOT NULL,
				parent varchar2(127) DEFAULT '' NOT NULL,
				object integer DEFAULT '0' NOT NULL,
				priority integer DEFAULT '0' NOT NULL,
				PRIMARY KEY (path))";
		$i++;

		$indexes = Array("object", "parent", "priority");
		foreach ($indexes as $index) {
			$indexn = $this->tbl_prefix."nodes$index";
			$queries[$i]["msg"]="creating index '$index' for nodes table";
			$queries[$i]["query_string"] = "
				CREATE INDEX $indexn on ".$this->tbl_prefix."nodes ($index)
				";
			$i++;
		}

		$queries[$i]["query_string"] = "drop table ".$this->tbl_prefix."objects"; 
		$queries[$i]["msg"] = $queries[$i]["query_string"];
		$i++;

		$queries[$i]["msg"]="creating objects table.";
		$queries[$i]["query_string"]="
			CREATE TABLE ".$this->tbl_prefix."objects (
				id integer  NOT NULL ,
				type varchar2(32) DEFAULT '' NOT NULL,
				vtype varchar2(32) DEFAULT '' NOT NULL,
				lastchanged date,
				PRIMARY KEY (id)
			)";
		$i++;

		$queries[$i]["query_string"] = "drop table ".$this->tbl_prefix."objects_data"; 
		$queries[$i]["msg"] = $queries[$i]["query_string"];
		$i++;

		$queries[$i]["msg"]="creating objects_data table.";
		$queries[$i]["query_string"]="
			CREATE TABLE ".$this->tbl_prefix."objects_data (
				id integer  NOT NULL ,
				object long,
				PRIMARY KEY (id)
			)";
		$i++;

		$queries[$i]["query_string"] = "drop sequence ".$this->tbl_prefix."ObjectID";
		$i++;

		$queries[$i]["msg"] = "creating object sequence";
		$queries[$i]["query_string"] = "CREATE SEQUENCE ".$this->tbl_prefix."ObjectID increment by 1 start with 1";
		$i++;

		$indexes = Array("lastchanged", "type", "vtype");
		foreach ($indexes as $index) {
			$indexn = $this->tbl_prefix."objects$index";
			$queries[$i]["msg"]="creating index '$indexn' for objects table";
			$queries[$i]["query_string"] = "
				CREATE INDEX $indexn on ".$this->tbl_prefix."objects ($index)
				";
			$i++;
		}

		$queries[$i]["query_string"] = "drop table ".$this->tbl_prefix."properties"; 
		$queries[$i]["msg"] = $queries[$i]["query_string"];
		$i++;

		$queries[$i]["msg"]="creating properties table.";
		$queries[$i]["query_string"]="
			CREATE TABLE ".$this->tbl_prefix."properties (
				name varchar2(21) DEFAULT '' NOT NULL,
				PRIMARY KEY (name)
			)";
		$i++;

		$queries[$i]["query_string"] = "drop table ".$this->tbl_prefix."types"; 
		$queries[$i]["msg"] = $queries[$i]["query_string"];
		$i++;

		$queries[$i]["msg"]="creating types table.";
		$queries[$i]["query_string"]="
			CREATE TABLE ".$this->tbl_prefix."types (
				type varchar2(32) DEFAULT '' NOT NULL,
				implements varchar2(32) DEFAULT '' NOT NULL
			)";
		$i++;

		$indexes = Array("type", "implements");
		foreach ($indexes as $index) {
			$indexn = $this->tbl_prefix."types$index";
			$queries[$i]["msg"]="creating index '$indexn' for types table";
			$queries[$i]["query_string"] = "
				CREATE INDEX $indexn on ".$this->tbl_prefix."types ($index)
				";
			$i++;
		}

		reset($queries);
		while ((list($key, $query)=each($queries)) && (!$this->error)) {
			if ($query["msg"]) {
				echo $query["msg"]."\n";
			}
			echo "<b>".$query['query_string']."</b><br>\n";
			$this->store_run_query($query['query_string']);
			if ($this->error) {
				error($this->error);
			}
		}


		if (!$error) {
			$return=true;
			// TODO: initialize locking tables
			// $this->mod_lock->init($this->tbl_prefix);

			echo "oracle store initialized.\n\n";
		} else {
			$return=false;
		}
		return $return;
	}

	function create_property($property, $definition, $cindexes="") {
	/**********************************************************************

		This function creates a new property type. This property can then be
	used by objects to set special information on which to quickly search
	using find.

	$name must be a string of at most 16 characters from the set [a-zA-Z0-9_] 
	or '-', starting with a letter (a-zA-Z).

	$definition describes which name value pairs this property contains and
	which type (and size) each value is.
	$definition is defined as: $definition[{name}][{type}]={size}
		{name} is defined like $name above
		(type} can be 'number', 'string', 'text' or 'boolean'
		{size} is only used for the string type and can not be more than 255. 
	$indexes describes which indexes the storage layer should consider
		for the property. Default behaviour is to create one index for the
		complete set of name-value pairs. If you want you can create a smaller
		index, or more than one index.
	$indexes is defined as: $indexes[][]={name} || $indexes="none"
		e.g. $indexes[0][0]="name1";
	 $indexes[1][0]="name2"
				 $indexes[1][1]="name3";
		this would create two indexes, one on "name1" and one on "name2" and
		"name3".
		{name} is defined like $name above. 
	if $indexes is set to "none", no user indexes will be created on this 
	property. This is usually not a good thing to do. 
	 
	**********************************************************************/
		$result=1;
		$i = 0;
		$this->error="";
		$property_tbl = $this->tbl_prefix."prop_".AddSlashes($property);

		/* load custom indexes if available */
		if (is_array($cindexes)) {
			$indexes = $cindexes;
		} else {
			$indexes = Array();
		}
		
		if (eregi("^[a-z][a-z0-9_-]*$", $property) && strlen($property)<=16) {
			$create_string="create table ".$this->tbl_prefix."prop_".AddSlashes($property)." (\n";
			while (list($name, $typedef)=each($definition)) {
				if (!eregi("^[a-z][a-z0-9_-]*$",$name) || strlen($name)>16) {
					$result=0;
					$this->error="Wrong format for type: $name";
					break;
				}	 
				$create_string.= "	AR_".$name."	";
				while (list($type,$size)=each($typedef)) {
					switch($type) {
						case "string": 
							if ($size>0 && $size<256) {
								$index[]="$name";
								//$create_string.="varchar2(".$size.") default ''  not null ,\n";
								$create_string.="varchar2(".$size.") ,\n";
							} else {
								$result=0;
								$this->error="Wrong format for typedefinition $name: incorrect size."; 
							}
							break;
						case "number":
							$index[]="$name";
							$create_string.="number default '0' not null ,\n";
							break;
						case "boolean":
							$index[]="$name";
							$create_string.="integer default '0' not null ,\n";
							break;
						case "text":
							$index[]="$name";
							//$create_string.="$name varchar2(2000) default ''  not null,\n";
							$create_string.="$name varchar2(2000) ,\n";
							break;
					}
				}
			}

			$indexes[] = $index;

			if ($result) {

				$queries[$i]["query_string"] = "drop table ".$this->tbl_prefix."prop_$property"; 
				$queries[$i]["msg"] = $queries[$i]["query_string"];
				$i++;

				$queries[$i]["msg"] = "Creating property table ($property)";
				$queries[$i]["query_string"] = $create_string." object integer not null)";
				$i++;

				$queries[$i]["msg"] = "Registering property table";
				$queries[$i]["query_string"] = "insert into ".$this->tbl_prefix."properties values ('".AddSlashes($property)."')";
				$i++;
				
				if ($cindexes != 'none' && $indexes && is_array($indexes)) {
					foreach ($indexes as $ikey => $index) {
						$icolumns = '';
						foreach ($index as $icolumn) {
							if (!$icolumns) {
								$icolumns = 'AR_'.$icolumn;
								$indexn = $property_tbl."_".$ikey."_".$icolumn;
							} else {
								$icolumns .= ', AR_'.$icolumn;
							}
						}
						$queries[$i]["msg"] = "Creating index ($indexn) on $property_tbl ($icolumns)";
						$queries[$i]["query_string"] = "create index $indexn on $property_tbl ($icolumns)";
						$i++;
					}
				}

				/* the object index */
				$index = $this->tbl_prefix."prop_".$property."_object";
				$queries[$i]["msg"] = "Creating index ($index) on $property_tbl (object)";
				$queries[$i]["query_string"] = "create index $index on $property_tbl (object)";
				$i++;

				if ($result) {
					while ((list($key, $query)=each($queries)) && (!$error)) {
						if ($query["msg"]) {
							echo $query["msg"]."\n";
						}
						echo "<b>".$query['query_string']."</b><br>\n";
						$this->store_run_query($query['query_string']);
						if ($this->error) {
							error($error);
							$result = 0;
						}
					}
				}
			}
		} else {
			$result=0;
			$this->error="Wrong format for property name: $property";
		}
		debug("create_property: $create_string","store");
		return $result;
	}

	function remove_property($property) {
	/**********************************************************************

		This function removes the property with the given name. It does not
	check whether there are types left which use this property. It returns
	true when the named property is succesfully removed. This means it also
	returns true if the property didn't exist in the first place.
	Otherwise it will return false.

	**********************************************************************/

		$this->error="";
		$eproperty=AddSlashes($property);
		$remove_string="drop table ".$this->tbl_prefix."prop_$eproperty";
		$this->store_run_query($remove_string);

		$query_string="delete from ".$this->tbl_prefix."properties where name='$eproperty'";
		$this->store_run_query($query_string);
		if ($this->error) {
			error($this->error);
		}
		//FIXME: check for succes first, check whether table no longer exists.
		return 1;
	}
	
	function add_type($type, $implements) {
	/**********************************************************************
	
		This function does not actually create a type, it only serves to
	notify to the system that $type exists and that it implements the
	type or interface given in $implements.
	$type and $implements must be strings of at most 16 characters.

	**********************************************************************/

		$this->error="";
		if ($type && $implements && (strlen($type)<33) && (strlen($implements)<33)) {
			$etype=AddSlashes($type);
			$eimplements=AddSlashes($implements);
			$query_string="insert into ".$this->tbl_prefix."types values ('$etype','$eimplements')";
			debug($query_string,"store");
			$this->store_run_query($query_string);

			if ($this->error) {
				$result=0;
				error($this->error);
			} else {
				$result=1;
			}	
		} else {
			$this->error="Wrong format for type or implements";
		}
		return $result;
	}

	function del_type($type, $implements="") {
	/**********************************************************************

		This function notifies the system that either:
	1) A type no longer implements a certain type or interface, or
	2) a type no longer exists.

	**********************************************************************/

		$this->error="";
		$etype=AddSlashes($type);
		if (!$implements) {
			$query_string="delete from ".$this->tbl_prefix."types where type='$etype' or implements='$etype'";
		} else {
			$eimplements=AddSlashes($implements);
			$query_string="delete from ".$this->tbl_prefix."types where type='$etype' and implements='$etype'";
		}
		debug($query_string,"store");
		$this->store_run_query($query_string);
		if ($this->error) {
			error($this->error);
			$result=0;
		} else {
			$result=1;
		}
		return $result;
	}

}

?>