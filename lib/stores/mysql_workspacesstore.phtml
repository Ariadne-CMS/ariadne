<?php
/******************************************************************************
  Mysql Store 1.0						Ariadne 2.0

  Copyright (C) 1998-2000  Muze 

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

  --------------------------------------------------------------------------

  This is an implementation of the store class for MySQL. The store class is
  an interface between Ariadne objects and a storage layer. It is used by all 
  Ariadne objects to call templates in other objects or to manipulate
  the location and contents of objects in the Ariadne system.

*******************************************************************************/

define('MAX_PATH_LENGTH', 254);

// general objectstore functions
require_once($ariadne."/stores/mysqlstore.phtml");

class mysql_workspacesstore extends mysqlstore {

	public function __construct($path, $config) {
		parent::__construct($path, $config);

		$this->layers = (array) $config["layer"];

		/* Include module mysql_compiler */
		include_once($this->code."stores/modules/mysql_workspaces_compiler.php");

	}
	
	public function getLayer($path) {
		krsort($this->layers); // Order path in reverse order, so longer (more specific) paths get found first.
		foreach ($this->layers as $layerPath => $layer) {
			if (substr($path, 0, strlen($layerPath)) == $layerPath) {
				return $layer;
			}
		}
		return 0;
	}

	public function setLayer($layer, $path = '/') {
		$this->layers[ $path ] = (int)$layer;
	}


	public function getLayerStatus($path = '/', $includeData = false) {
		$layer = (int)$this->getLayer($path);
		$epath = addslashes($path);
		$nodes_tbl=$this->tbl_prefix."nodes";
		$objects_tbl=$this->tbl_prefix."objects";
		$result = array();
		

		if ($layer) {
			$query_string = "select new.id as new_id, new.path as new_path, new.object as new_object, 
						UNIX_TIMESTAMP(new_objects.lastchanged) as new_lastchanged, new_objects.type as new_type, new_objects.vtype as new_vtype,
						old.id as old_id, old.path as old_path, old.object as old_object,
						UNIX_TIMESTAMP(old_objects.lastchanged) as old_lastchanged, old_objects.type as old_type, old_objects.vtype as old_vtype,
						old_stale.id as old_stale_id, old_stale.path as old_stale_path
			";
			if ($includeData) {
				$query_string .= "
					, new_objects.object as new_data, old_objects.object as old_data
				";
			}
			$query_string .= "
						from $nodes_tbl as new
							left join $nodes_tbl as old on new.id = old.id and old.layer = 0
							left join $objects_tbl as new_objects on new.object = new_objects.id
							left join $objects_tbl as old_objects on old.object = old_objects.id
							left join $nodes_tbl as old_stale on new.path = old_stale.path and old_stale.layer = 0
						where new.layer = $layer
						and new.path like '$epath%'
						order by new.path ASC
			";
			$query_result = $this->store_run_query($query_string);
			if ($query_result) {
				while ( $row = $query_result->fetch_array(MYSQLI_ASSOC) ) {
					$record = array();
					foreach ($row as $key => $value) {
						if (!is_numeric($key)) {
							if (substr($key, 0, strlen('old_stale_')) == 'old_stale_') {
								$record['old_stale'][substr($key, strlen('old_stale_'))] = $value;
							} else if (substr($key, 0, strlen('old_')) == 'old_') {
								$field = substr($key, strlen('old_'));
								if ($field == 'data') {
									$value = unserialize(self::fixObjectClass($value));
								}
								$record['old'][$field] = $value;
							} else if (substr($key, 0, strlen('new_')) == 'new_') {
								$field = substr($key, strlen('new_'));
								if ($field == 'data') {
									$value = unserialize(self::fixObjectClass($value));
								}
								$record['new'][$field] = $value;
							}
						}
					}
					if ($record['old']['id'] == $record['new']['id']) {
						if (!$record['new']['object']) {
							$record['operation'][] = 'delete';
						} else if ($record['old']['object'] == $record['new']['object']) {
							$record['operation'][] = 'move';
						} else {
							$record['operation'][] = 'update';
							if ($record['old']['path'] != $record['new']['path']) {
								$record['operation'][] = 'move';
							}
						}
					} else if ($record['old_stale']['path']) {
						$record['operation'] = array(
							'delete',
							'create'
						);
					} else {
						$record['operation'][] = 'create';
					}
					$result[$record['new']['path']] = $record;
				}
			}
		}
		return $result;
	}

	public function checkHardLinks($path) {
		// Check if there are any hardlinks in the path - if so, this is not compatible with workspaces support;
		$nodes_tbl = $this->tbl_prefix."nodes";
		$epath = addslashes($path);
		$query_string = "select distinct(parent) from $nodes_tbl nodes1 where exists ( select 1 from $nodes_tbl nodes2 where nodes1.object = nodes2.object and layer = 0 limit 1,1) and (('$epath' like concat(parent,'%')) or (parent like '$epath%'))";

		$query_result = $this->store_run_query($query_string);
		if ($query_result) {
			while ( $row = $query_result->fetch_array(MYSQLI_ASSOC) ) {
				if ($row['parent']) {
					return true;
				}
			}
		}
		return false;
	}

	public function commitLayer($path, $pathList, $layer = null) {
		$layer = (int)$this->getLayer($path);
		$nodes_tbl=$this->tbl_prefix."nodes";
		$objects_tbl=$this->tbl_prefix."objects";

		if (is_array($pathList)) {
			$statusList = $this->getLayerStatus($path);
			foreach ($pathList as $path) {
				$epath  = addslashes($path);
				$status = $statusList[$path];
				if ($status) {
					$query_string = "delete from $nodes_tbl where layer = 0 and path = '$epath'";
					$this->store_run_query($query_string);
					
					$query_string = "update $nodes_tbl set layer = 0 where layer = $layer and id = ".((int)$status['new']['id']);
					$this->store_run_query($query_string);

					if ($status['old']['id']) {
						$query_string = "select count(object) as count from $nodes_tbl where object = ".((int)$status['old']['id']);
						$result = $this->store_run_query($query_string);
						if ($result) {
							$objects = $result->fetch_array(MYSQLI_ASSOC);
							if ($objects['count'] == 0) {

								$this->del_property($status['old']['object']);

								$query_string="delete from $objects_tbl where id=" . ((int)$status['old']['object']);
								$this->store_run_query($query_string);

								foreach ($this->filestores as $fsName) {
									debug("store::purge purging fstore($fsName, ".$status['old']['id'].")", "store");
									$fStore = $this->get_filestore($fsName);
									$fStore->purge((int)$status['old']['object']);
								}
							}
						}
					}
				}
			}
		}
	}

	public function revertLayer($path, $pathList, $layer = null) {
		$layer = (int)$this->getLayer($path);
		$nodes_tbl=$this->tbl_prefix."nodes";
		$objects_tbl=$this->tbl_prefix."objects";

		if (is_array($pathList)) {
			$statusList = $this->getLayerStatus($path);
			foreach ($pathList as $path) {
				$epath  = addslashes($path);
				$status = $statusList[$path];
				if ($status) {
					$query_string = "delete from $nodes_tbl where layer = $layer and path = '$epath'";
					$this->store_run_query($query_string);
					
					if ($status['new']['id']) {
						$query_string = "select count(object) as count from $nodes_tbl where object = ".((int)$status['new']['id']);
						$result = $this->store_run_query($query_string);
						if ($result) {
							$objects = $result->fetch_array(MYSQLI_ASSOC);
							if ($objects['count'] == 0) {

								$this->del_property(((int)$status['new']['object']));

								$query_string="delete from $objects_tbl where id=" . ((int)$status['new']['object']);
								$this->store_run_query($query_string);

								foreach ($this->filestores as $fsName) {
									debug("store::purge purging fstore($fsName, ".((int)$status['new']['object']).")", "store");
									$fStore = $this->get_filestore($fsName);
									$fStore->purge(((int)$status['new']['object']));
								}
							}
						}
					}
				}
			}
		}
	}

	public function get($path) {
	/**********************************************************************************

	 This function takes as argument a path to an object in the store and will retrieve
	 all the necessary data and return this in the objectlist type needed for 
	 store->call(). If the requested path does not exist, it will retrieve the object
	 with the longest matching path.

	 $path should always start and end with a '/'.

	 **********************************************************************************/

		$this->error="";
		$result["method"]="get";
		$result["path"]=$path;
		$epath=AddSlashes($path);

		$nodes_tbl=$this->tbl_prefix."nodes";
		$objects_tbl=$this->tbl_prefix."objects";
		$types_tbl=$this->tbl_prefix."types";
		$layer=(int)$this->getLayer($path);
		
		if ($layer) {
			$query_string="select $nodes_tbl.path, $nodes_tbl.parent, $nodes_tbl.priority, $objects_tbl.id, $objects_tbl.type, $objects_tbl.object, UNIX_TIMESTAMP($objects_tbl.lastchanged) as lastchanged, $objects_tbl.vtype from $objects_tbl, $nodes_tbl where $objects_tbl.id=$nodes_tbl.object and $nodes_tbl.path='$epath' and ( $nodes_tbl.layer = $layer OR $nodes_tbl.layer = 0 and $nodes_tbl.id NOT IN (select $nodes_tbl.id from $nodes_tbl where $nodes_tbl.layer = $layer) and $nodes_tbl.path NOT IN (select path from $nodes_tbl where layer = $layer))";
		} else {
			$query_string="select $nodes_tbl.path, $nodes_tbl.parent, $nodes_tbl.priority, $objects_tbl.id, $objects_tbl.type, $objects_tbl.object, UNIX_TIMESTAMP($objects_tbl.lastchanged) as lastchanged, $objects_tbl.vtype from $objects_tbl, $nodes_tbl where $objects_tbl.id=$nodes_tbl.object and $nodes_tbl.path='$epath' and $nodes_tbl.layer = 0";
		}
		$result["list"]= $this->store_run_query($query_string);
		return $result;
	}
	
	public function mogrify($id, $type, $vtype = null) {
		$this->error="";

		$nodes_tbl=$this->tbl_prefix."nodes";
		$objects_tbl=$this->tbl_prefix."objects";
		$types_tbl=$this->tbl_prefix."types";
		$layer=(int)$this->getLayer($path);
		if ( ( strlen( $type ) > 32 ) || (strlen( $vtype ) > 32 ) ) {
			$this->error = "Type names are too long, maximum is 32 characters ( $type, $vtype )";
		} else if ( !$type ) {
			$this->error = "No type to mogrify to given.";
		}
		if (!$this->error && is_string($id)) {
			$epath = AddSlashes($id);
			if ($layer) {
				$query_string = "select $nodes_tbl.path, $nodes_tbl.object, $objects_tbl.layer from $nodes_tbl, $objects_tbl where $nodes_tbl.object = $objects_tbl.id and $nodes_tbl.path = '$epath' and ( $nodes_tbl.layer = $layer OR $nodes_tbl.layer = 0 and $nodes_tbl.id NOT IN (select $nodes_tbl.id from $nodes_tbl where $nodes_tbl.layer = $layer) and $nodes_tbl.path NOT IN (select path from $nodes_tbl where layer = $layer))";
			} else {
				$query_string = "select $nodes_tbl.object from $nodes_tbl where $nodes_tbl.path = '$epath' and $nodes_tbl.layer = 0";
			}
			$qresult = $this->store_run_query($query_string);
			if (!$qresult) {
				$this->error = "Could not fetch object id";
			} else {
				$temp = $qresult->fetch_array(MYSQLI_ASSOC);
				$id = $temp["object"];
				$objectLayer = $temp["layer"];
				$id = $this->addObjectToLayer($temp["path"]);
			}
		} else if ($layer) {
			$eid = (int)$id;
			$query_string = "select $nodes_tbl.path, $nodes_tbl.object, $objects_tbl.layer from $nodes_tbl, $objects_tbl where $nodes_tbl.object = $objects_tbl.id and $nodes_tbl.object = $eid and ( $nodes_tbl.layer = $layer OR $nodes_tbl.layer = 0 and $nodes_tbl.id NOT IN (select $nodes_tbl.id from $nodes_tbl where $nodes_tbl.layer = $layer) and $nodes_tbl.path NOT IN (select path from $nodes_tbl where layer = $layer))";
			$qresult = $this->store_run_query($query_string);
			if (!$qresult) {
				$this->error = "Could not fetch object id";
			} else {
				$temp = $qresult->fetch_array(MYSQLI_ASSOC);
				$id = $temp["object"];
				$objectLayer = $temp["layer"];
				$id = $this->addObjectToLayer($temp["path"]);
			}
			
		}
		if (!$this->error && $id) {
			$eid = AddSlashes($id);
			$etype = AddSlashes($type);
			if (!$vtype) {
				$vtype = $type;
			}
			$evtype = AddSlashes($vtype);
			$query_string = "update $objects_tbl set type='$etype', vtype='$evtype' where id = $eid";
			$result = $this->store_run_query( $query_string, $this->connect_id);
		}
		return $result;
	}

	public function touch($id, $timestamp = -1) {
	/**********************************************************************************

	 This function takes as argument a path to an object (or id of an object)
     in the store and will set the timestamp to $timestamp.

	 $path should always start and end with a '/'.

	 **********************************************************************************/

		$this->error="";

		$nodes_tbl=$this->tbl_prefix."nodes";
		$objects_tbl=$this->tbl_prefix."objects";
		$types_tbl=$this->tbl_prefix."types";
		$layer=(int)$this->getLayer('/'); //FIXME: resolve path before we get the current layer
		
		if ($timestamp == -1) {
			$timestamp = time();
		}

		if (is_string($id)) {
			$epath = AddSlashes($id);
			if ($layer) {
				$query_string = "select $nodes_tbl.path, $nodes_tbl.object, $objects_tbl.layer from $nodes_tbl, $objects_tbl where $nodes_tbl.object = $objects_tbl.id and $nodes_tbl.path = '$epath' and ( $nodes_tbl.layer = $layer OR $nodes_tbl.layer = 0 and $nodes_tbl.id NOT IN (select $nodes_tbl.id from $nodes_tbl where $nodes_tbl.layer = $layer) and $nodes_tbl.path NOT IN (select path from $nodes_tbl where layer = $layer))";
			} else {
				$query_string = "select $nodes_tbl.object from $nodes_tbl where $nodes_tbl.path = '$epath' and $nodes_tbl.layer = 0";
			}
			$qresult = $this->store_run_query($query_string);
			if (!$qresult) {
				$this->error = "Could not fetch object id";
			} else {
				$temp = $qresult->fetch_array(MYSQLI_ASSOC);
				$id = $temp["object"];
				$objectLayer = $temp["layer"];
				$id = $this->addObjectToLayer($temp["path"]);
			}
		} else if ($layer) {
			$eid = (int)$id;
			$query_string = "select $nodes_tbl.path, $nodes_tbl.object, $objects_tbl.layer from $nodes_tbl, $objects_tbl where $nodes_tbl.object = $objects_tbl.id and $nodes_tbl.object = $eid and ( $nodes_tbl.layer = $layer OR $nodes_tbl.layer = 0 and $nodes_tbl.id NOT IN (select $nodes_tbl.id from $nodes_tbl where $nodes_tbl.layer = $layer) and $nodes_tbl.path NOT IN (select path from $nodes_tbl where layer = $layer))";
			$qresult = $this->store_run_query($query_string);
			if (!$qresult) {
				$this->error = "Could not fetch object id";
			} else {
				$temp = $qresult->fetch_array(MYSQLI_ASSOC);
				$id = $temp["object"];
				$objectLayer = $temp["layer"];
				$id = $this->addObjectToLayer($temp["path"]);
			}
			
		}

		if ($id && !$this->error) {
			$eid = AddSlashes($id);
			$etimestamp = AddSlashes($timestamp);
			$query_string = "update $objects_tbl set lastchanged=FROM_UNIXTIME($etimestamp) where id = $eid";
			$qresult = $this->store_run_query($query_string);
			$result = $this->dbh->affected_rows;
		}
		return $result;
	}

	public function ls($path) {
	/**********************************************************************************

	 This function takes as argument a path to an object in the store and will retrieve
	 all the objects and their data which have this object as their parent. It will 
	 then return this in the objectlist type needed for store->call(). If the requested
	 path does not exist, it will retrieve the object with the longest matching path.

	 $path should always start and end with a '/'.

	 **********************************************************************************/

		$this->error="";
		$epath=AddSlashes($path);

		$nodes_tbl=$this->tbl_prefix."nodes";
		$objects_tbl=$this->tbl_prefix."objects";
		$types_tbl=$this->tbl_prefix."types";
		$layer=(int)$this->getLayer($epath);
		if ($layer) {
			$query_string="select distinct($nodes_tbl.path), $nodes_tbl.parent, $nodes_tbl.priority, $objects_tbl.id, $objects_tbl.type, $objects_tbl.object, UNIX_TIMESTAMP($objects_tbl.lastchanged) as lastchanged, $objects_tbl.vtype from $objects_tbl, $nodes_tbl where $objects_tbl.id=$nodes_tbl.object and ($nodes_tbl.layer = $layer OR $nodes_tbl.layer = 0 and $nodes_tbl.id NOT IN (select $nodes_tbl.id from $nodes_tbl where layer = $layer) and $nodes_tbl.path NOT IN (select path from $nodes_tbl where layer = $layer)) and $nodes_tbl.parent='$epath' order by $nodes_tbl.priority DESC, $nodes_tbl.path";
		} else {
			$query_string="select distinct($nodes_tbl.path), $nodes_tbl.parent, $nodes_tbl.priority, $objects_tbl.id, $objects_tbl.type, $objects_tbl.object, UNIX_TIMESTAMP($objects_tbl.lastchanged) as lastchanged, $objects_tbl.vtype from $objects_tbl, $nodes_tbl where $objects_tbl.id=$nodes_tbl.object and $nodes_tbl.layer = 0 and $nodes_tbl.parent='$epath' order by $nodes_tbl.priority DESC, $nodes_tbl.path";
		}
		$result["method"]="ls";
		$result["path"]=$path;
		$result["list"]= $this->store_run_query($query_string);
		return $result;
	}

	public function parents($path, $top="/") {
	/**********************************************************************************

	 This function takes as argument a path to an object in the store. It will return 
	 all objects with a path which is a substring of the given path. The resulsts are 
	 ordered by path (length), shortest paths first.
	 In effect all parents of an object in the tree are called, in order, starting at 
	 the root.

	 $path should always start and end with a '/'.

	 **********************************************************************************/

		$this->error="";
		$epath=AddSlashes($path);
		$etop=AddSlashes($top);

		$nodes_tbl=$this->tbl_prefix."nodes";
		$objects_tbl=$this->tbl_prefix."objects";
		$types_tbl=$this->tbl_prefix."types";
		$layer=(int)$this->getLayer($epath);
		
		$query_string="select distinct($nodes_tbl.path), $nodes_tbl.parent, $nodes_tbl.priority, $objects_tbl.id, $objects_tbl.type, $objects_tbl.object, UNIX_TIMESTAMP($objects_tbl.lastchanged) as lastchanged, $objects_tbl.vtype from $objects_tbl, $nodes_tbl where $objects_tbl.id=$nodes_tbl.object and $nodes_tbl.path=substring('$epath',1,length(path)) and $nodes_tbl.path LIKE '$etop%' and ( $nodes_tbl.layer = $layer OR $nodes_tbl.layer = 0 and $nodes_tbl.id NOT IN (select $nodes_tbl.id from $nodes_tbl where $nodes_tbl.layer = $layer) and $nodes_tbl.path NOT IN (select path from $nodes_tbl where layer = $layer)) order by path";
		$result["method"]="parents";
		$result["path"]=$path;
		$result["list"]= $this->store_run_query($query_string);
		return $result;
	}

	public function count_find($path, $criteria, $limit=100, $offset=0) {
		$sqlcompiler= $this->compilerFactory();
		$query=$sqlcompiler->compile($path, $criteria, $limit, $offset, $this->layers);
		if ($sqlcompiler->error) {
			$this->error=$sqlcompiler->error;
		}
		unset($sqlcompiler);
		$qresult = $this->store_run_query($query["count_query"]);
		if ($qresult) {
			$result = $qresult->fetch_array(MYSQLI_ASSOC);
			$count  = $result["count"];
		}
		return $count;
	}

	public function find($path, $criteria, $limit=100, $offset=0) {
	/**********************************************************************************

	 This function takes as arguments a path to an object in the store and some search
	 criteria. It will search for all matching objects under the given path. If the
	 given path is not in this store but in a substore it will not automatically search
	 that substore. 

	 $criteria is of the form 

	 $criteria ::= ({ $property_name => ({ $valuename => ({ $compare_function, $value }) }) }) 

	 e.g.: $criteria["status"]["value"][">"]="published";

	 $path should always start and end with a '/'.

	 **********************************************************************************/
		if (!is_array($criteria) && ($criteria=trim($criteria))) {
			$sqlcompiler= $this->compilerFactory();
			$query=$sqlcompiler->compile($path, $criteria, $limit, $offset, $this->layers);
			if ($sqlcompiler->error) {
				$this->error=$sqlcompiler->error;
			}
			unset($sqlcompiler);
			$result["list"]= $this->store_run_query($query["select_query"]);
		} else {
			$this->error="";
			$count=0;
			$result["method"]="find";
			$result["path"]=$path;
			$result["criteria"]=$criteria;
			$epath=AddSlashes($path);

			$nodes_tbl=$this->tbl_prefix."nodes";
			$objects_tbl=$this->tbl_prefix."objects";
			$types_tbl=$this->tbl_prefix."types";
			$layer = $this->getLayer( $path );
			while (list($property, $values)=@each($criteria)) {
				$eproperty=AddSlashes($property);
				if ($property!="object") {
					$from.=", ".$this->tbl_prefix."prop_$eproperty";
					$where.=" and (";
				}
				while (list($valuename, $compare)=each($values)) {
					while (list($function, $value)=each($compare)) {
						//FIXME: add proper escaping of strings
						switch(strtolower($function)) {
							case '=':
							case '==':
								$ecompare = '=';
							break;
							case '!=':
							case '<=':
							case '>=':
							case '<':
							case '>':
								$ecompare = $function;
							break;
							case '~=':
							case '=~':
							case 'like':
								$ecompare = "like";
							break;
							case '!~':
							case 'not like':
								$ecompare = "not like";
							break;
						}
						$evaluename=AddSlashes($valuename);
						if ($value=="") {
							// empty strings as value generate strange results in SQL land
							$value=0;
						}
						switch($property) {
							case "object" :
								switch($valuename) {
									case ("type") :
										$where.=" and $objects_tbl.type $ecompare '".addSlashes($value)."' ";
									 	break;
									case ("implements") :
										$types=", $types_tbl";
										$where.=" and ( $types_tbl.implements $ecompare '".addSlashes($value)."' and $objects_tbl.vtype=$types_tbl.type ) ";
										break;
									case ("parent") :
										$where.=" and $nodes_tbl.parent $ecompare '".addSlashes($value)."' ";
										break;
									case ("lastchanged") :
										$value = date("YmdHis", $value);
										$where.=" and $objects_tbl.lastchanged $ecompare '".addSlashes($value)."' ";
										break;
								}
								break;
							default :
								$where.=$this->tbl_prefix."prop_$eproperty.AR_$evaluename $ecompare '".addSlashes($value)."' and ";
						}
					}
				}
				if ($property!="object") {
					$where.=" ".$this->tbl_prefix."prop_$eproperty.object=$objects_tbl.id)	";
				}
			}
			$query_string="select distinct($nodes_tbl.path), $nodes_tbl.parent, $nodes_tbl.priority, $objects_tbl.id, $objects_tbl.type, $objects_tbl.object, UNIX_TIMESTAMP($objects_tbl.lastchanged) as lastchanged, $objects_tbl.vtype from $nodes_tbl, $objects_tbl $from $types where $objects_tbl.id=$nodes_tbl.object and $nodes_tbl.path like '$epath%'";
			if ($layer) {
				$query_string .= " and ($nodes_tbl.layer = $layer OR $nodes_tbl.layer = 0 and $nodes_tbl.id NOT IN (select id from $nodes_tbl where layer = $layer) and $nodes_tbl.path NOT IN (select path from $nodes_tbl where layer = $layer))";
			} else {
				$query_string .= " and $nodes_tbl.layer = 0";
			}

			$where=substr($where,4);
			if ($where) { 
				$query_string.=" and ( ( $where ) )";
			} 
			$query_string.=" order by $nodes_tbl.parent, $nodes_tbl.priority DESC, $nodes_tbl.path";
			if ($limit) {
				$query_string.=" limit ";
				if ($offset) {
					$query_string.="$offset,";
				}
				$query_string.="$limit";
			}
			$result["list"]= $this->store_run_query($query_string);
		}
		return $result;
	}

	public function save($path, $type, $data, $properties="", $vtype="", $priority=false) {
	/***************************************************************

		This function takes as argument a path, type, objectdata and 
		possibly a properties list and vtype (virtual type).
		If there exists no object with the given path, a new object is 
		saved with the given type, data, properties and vtype, and a
		new path is saved pointing to it.
		If there does exist an object with the given path, it's object
		data is overwritten with the given data and if vtype is set the
		current vtype is overwritten with the new one.

		$path must be an absolute path (containing no '..' and starting
			with '/')
		$type must be a valid type
		$data can be any string (usually a serialized object.)
		$properties is a multidimensional hash of the following form:
			$properties[{property_name}][][{value_name}]={value}
			{property_name} must be a valid property name
			{value_name} must be a valid value name for this property
			{value} can be a number, boolean or string. 
		example:
			$properties["name"][0]["value"]="A name";
			$properties["name"][1]["value"]="A second name!";
		if $properties["name"]=1 then all properties for property name
			will be removed.

		$vtype must be a valid type.
	 
		if $properties or $vtype are not set or empty ("",0 or false)
		they will be ignored. $vtype defaults to $type.
		Only those properties listed in $properties will be updated.
		Any other property set will remain as it was.

	***************************************************************/
		$this->error="";
		if ($path!="/") {
			$parent=$this->make_path($path, "..");
		} else {
			$parent="..";
		}
		$eparent=AddSlashes($parent);
		$epath=AddSlashes($path);
		$edata=AddSlashes(serialize($data));
		$etype=AddSlashes($type);
		$epriority=(int)$priority;

		$nodes_tbl=$this->tbl_prefix."nodes";
		$objects_tbl=$this->tbl_prefix."objects";
		$types_tbl=$this->tbl_prefix."types";
		$layer=(int)$this->getLayer($path);
		if (strlen($path)<MAX_PATH_LENGTH) { // initial check
			$id=$this->exists($path);
			debug("save: id before object layer check $id", "store");
			if ($id) { //update
				$id = $this->addObjectToLayer($path);
				debug("save: id after adding object to layer $id", "store");
				$result = $path;
				if ($vtype) { // only change/save vtype if it is explicitly set
					$evtype=AddSlashes($vtype);
					$query_string="update $objects_tbl set object='$edata', vtype='$evtype', lastchanged=NULL where id=$id"; 
				} else {
					$query_string="update $objects_tbl set object='$edata', lastchanged=NULL where id=$id"; 
				}
				$qresult = $this->store_run_query($query_string);
				if ($qresult !== false) {
					$this->save_properties($properties, $id, $this); 
					if($priority !== false) {
						$query_string="update $nodes_tbl set priority=$epriority where path='$epath' and layer = $layer";
						$qresult = $this->store_run_query($query_string);
						if ($qresult === false) {
							debug("save: update object failed!","store");
							debug("save: ".$this->error,"store");
							$result=0;
						}
					} 
				} else {
					debug("save: update object failed!","store");
					debug("save: ".$this->error,"store");
					$result=0;
				}
			} else { // insert new
				if ($vtype=="") { // if vtype is not set, it defaults to type for new objects
					if ($subcpos = strpos($type, '.')) {
						$vtype = substr($type, 0, $subcpos);
					} else {
						$vtype=$type; 
					}
				}
				$evtype=AddSlashes($vtype);

				if($priority === false){
					// default priority == 0
					$priority = 0;
					$epriority=(int)$priority;
				}

				$mask = substr($path, strlen($parent));
				if (preg_match("/^(.*)\{([0-9]:)?id\}(.*)/",$mask,$matches)) { 
					// if the last part of a path matches something like {2:id} this
					// part will automatically create a new number, unique in this directory, and fill it in.
					// before we proceed, we need to lock the 'nodes' and 'objects' table
					$query_string="lock tables ".$this->tbl_prefix."nodes write, ".$this->tbl_prefix."objects write";
					$qresult = $this->store_run_query($query_string);
					if ($qresult !== false) {
						$needunlocking = true;

						$subid=$this->get_nextid($parent, $mask);
						$path=preg_replace("/\{([0-9]:)?id\}/",strval($subid),$path);
						$epath=AddSlashes($path);
					} else {
						error("PANIC: could not obtain write lock on nodes table!");
						$this->close();
						exit;
					}
				}

				if (strlen($path)>=MAX_PATH_LENGTH) {
					// extra check, after rewrite of filename
					$this->error="ERROR: Maximum path length (".MAX_PATH_LENGTH." characters) exceeded. Please shorten your filenames.";
					$result=false;
				} else {
					$query_string="insert into $objects_tbl (layer, id,type,object,vtype) values ($layer, 0,'$etype','$edata','$evtype')";
					$qresult = $this->store_run_query($query_string);
					$id=$this->dbh->insert_id;
					if ($qresult !== false && $id) {
						if ($layer) {
							$query_string = "delete from $nodes_tbl where path = '$epath' and layer = $layer";
							$this->store_run_query($query_string);
						}
						$query_string="insert into $nodes_tbl (layer, path, parent, object, priority) values ($layer, '$epath','$eparent',$id,$epriority)";
						$qresult = $this->store_run_query($query_string);
						if ($qresult) {
							if ($needunlocking) {
								$query_string = "unlock tables";
								$this->store_run_query($query_string);
								$needunlocking = false;
							}
							$this->save_properties($properties, $id, $this);
							$result=$path;
						} else {
							debug("save: insert node failed!","store");
							debug("save: ".$this->error,"store");
							$result=0;
						}
					} else {
						debug("save: insert object failed!","store");
						debug("save: ".$this->error,"store");
						$result=0;
					}
				}
				if ($needunlocking) {
					$query_string = "unlock tables";
					$this->store_run_query($query_string);
					$needunlocking = false;
				}
			}
		} else {
			// path too long
			$this->error="ERROR: Maximum path length (".MAX_PATH_LENGTH." characters) exceeded. Please shorten your filenames.";
			$result=false;
		}
		return $result;
	}

	public function getNodeByObjectId( $id ) {
		$nodes_tbl=$this->tbl_prefix."nodes";
		$objects_tbl=$this->tbl_prefix."objects";
		debug("store::getPathById( $id )", "store");

		$query_string_layers = "";
		foreach ($this->layers as $path => $layer) {
			$query_string_layers .= " OR ( path like '".AddSlashes($path)."%' and layer = ".((int)$layer)." ) ";
		}
		
		$query_string_node = "select path, parent, priority, object, id, layer from $nodes_tbl where object = ".((int)$id)." and (layer = 0 $query_string_layers) order by layer DESC";
		$result = $this->store_run_query($query_string_node);
		if (!$result) {
			return false;
		}

		$numRows = $result->num_rows;
		if (!$numRows) {
			return false;
		}

		$node = $result->fetch_array(MYSQLI_ASSOC);
		if (!$node['layer']) {
			if ( $query_string_layers ) {
				$part = "and ($query_string_layers)";
			} else {
				$path = '';
			}

			$query_string_node = "select path, parent, priority, id, object, layer from $nodes_tbl where id = ".$node['id']." $part";
			$result = $this->store_run_query($query_string_node);
			if (!$result) {
				return false;
			}
			$layeredNode = $result->fetch_array(MYSQLI_ASSOC);
			if ($layeredNode) {
				return $layeredNode;
			}
		}
		return $node;
	}

	public function addObjectToLayer($path, $layer = null) {
		$this->error="";

		if (is_numeric($path)) {
			$node = $this->getNodeByObjectId( $path );
			if ($this->error) {
				return false;
			}
			$path = $node['path'];
		}
		if (!$path) {
			$this->error = "No path given to addObjectToLayer";
			return false;		
		}
		
		$epath=AddSlashes($path);
		$nodes_tbl=$this->tbl_prefix."nodes";
		$objects_tbl=$this->tbl_prefix."objects";
		if (!isset($layer)) {
			$layer=(int)$this->getLayer($path);
		} else {
			$layer=(int)$layer;
		}
		debug("store::addObjectToLayer($path, $layer)", "store");

		$query_string_node = "select id, path, parent, object, priority from $nodes_tbl where path = '$epath' and layer = 0";
		$result = $this->store_run_query($query_string_node);
		if (!$result) {
			return false;
		}
		$node = $result->fetch_array(MYSQLI_ASSOC);
		if (!$layer) {
			return $node['object'];
		}

		$query_string_new_node = "select id, path, parent, object, priority from $nodes_tbl where path = '$epath' and layer = $layer";
		$result = $this->store_run_query($query_string_new_node);
		if (!$result) {
			return false;
		}
		$newNode = $result->fetch_array(MYSQLI_ASSOC);

		
		if (!$node && $newNode) { // check if newNode has been moved 
			$query_string_node = "select id, path, parent, object, priority from $nodes_tbl where id = ".$newNode['id']." and layer = 0";
			$result = $this->store_run_query($query_string_node);
			if (!$result) {
				return false;
			}
			$node = $result->fetch_array(MYSQLI_ASSOC);
			if (!$node['id']) {
				return $newNode['object'];
			}
		}

		$query_string_object = "select id, type, vtype, object, lastchanged from $objects_tbl where id = ".AddSlashes($node['object']);
		$result = $this->store_run_query($query_string_object);
		if (!$result) {
			return false;
		}

		$object = $result->fetch_array(MYSQLI_ASSOC);
		if (!$newNode['object'] || $newNode['object'] == $object['id']) {
			$insert_object_string = "insert into $objects_tbl (layer, type, vtype, object, lastchanged)
				values ($layer, '".AddSlashes($object['type'])."',
					'".AddSlashes($object['vtype'])."', '".AddSlashes($object['object'])."',
					'".AddSlashes($object['lastchanged'])."'
				)
			";
			$result = $this->store_run_query($insert_object_string);
			if (!$result) {
				return false;
			}
			$id = $this->dbh->insert_id;
		} else {
			$id = $newNode['object'];
		}

		if (!$newNode['id'] || $newNode['object'] == $object['id']) {
			if (!$newNode['id']) {
				$node_query_string = "insert into store_nodes (layer, id, path, parent, priority, object)
					values($layer, ".AddSlashes($node['id']).", '$epath',
					'".AddSlashes($node['parent'])."', '".AddSlashes($node['priority'])."',
					$id)
				";
			} else {
				$node_query_string = "update store_nodes set object = $id where id = ".$newNode['id']." and layer = $layer";
			}
			
			$result = $this->store_run_query($node_query_string);
			if (!$result) {
				return false;
			}

			$properties = $this->load_properties($object['id'],'','%'); // get properties from all scopes
			$this->save_properties($properties, $id);
			foreach ($this->filestores as $fsName) {
				debug("store::addObjectToLayer::filestore($fsName, id: ".$object['id'].")", "store");
				$fStore = $this->get_filestore($fsName);
				$fStore->copyNode($object['id'], $id, true);
			}
		}
		return $id;
	}

	protected function purge($path) {
	/**********************************************************************
	 
		This function will delete the object pointed to by $path and all
	other paths pointing to that object. It will then remove any property
	for this object from all property tables.
		The function returns the number of paths found and removed or 1 if
	there was no path found (meaning that the object doesn't exist and 
	therefor purge succeeded while doing nothing.)

	 $path should always start and end with a '/'.

	**********************************************************************/

		$this->error="";

		$nodes_tbl=$this->tbl_prefix."nodes";
		$objects_tbl=$this->tbl_prefix."objects";
		$types_tbl=$this->tbl_prefix."types";
		$nextid_tbl=$this->tbl_prefix."seq_id";
		$epath=AddSlashes($path);
		$eparent=$this->make_path($epath, '..');
		$layer=(int)$this->getLayer($path);

		$object=$this->exists($path);
		if ($object) {
			if (!$layer || $object !== $this->exists($path, 0)) {
				if ($layer) {
					$query_string = "update $nodes_tbl set object=0 where object=$object and layer=$layer";
				} else {
					$query_string="delete from $nodes_tbl where object=$object and layer=$layer";
				}
				$this->store_run_query($query_string);
				
				$query_string = "select count(object) as count from $nodes_tbl where object = $object";
				$result = $this->store_run_query($query_string);
				if ($result) {
					$objects = $result->fetch_array(MYSQLI_ASSOC);
					if ($objects['count'] == 0) {

						$this->del_property($object);

						$query_string="delete from $objects_tbl where id=$object";
						$this->store_run_query($query_string);

						foreach ($this->filestores as $fsName) {
							debug("store::purge purging fstore($fsName, $object)", "store");
							$fStore = $this->get_filestore($fsName);
							$fStore->purge($object);
						}
					}
				}
				$result = 1;
			} else {
				$query_string="select id from $nodes_tbl where path = '$epath' and layer = 0";
				$result = $this->store_run_query($query_string);
				if ($result) {
					$tmp = $result->fetch_array(MYSQLI_ASSOC);
					$nodeId = $tmp['id'];
					if ($nodeId) {
						$query_string="replace into $nodes_tbl (path, parent, object, id, layer) values ('$epath', '$eparent', 0, $nodeId, $layer)";
						$temp=$this->store_run_query($query_string);
						if ($temp) {
							$result=$this->dbh->affected_rows;
						}
					}
				}
			}
		} else { // no such path, so purge already succeeded :)
			$result=1;
		}
		return $result;
	}

	public function delete($path) {
	/**********************************************************************

		This function deletes the path given. If this is the last path pointing
	to an object, the object will be purged instead.

	$path should always start and end with a '/'.

	**********************************************************************/

		return $this->purge($path);
	}
	

	public function exists($path, $layer = null) {
	/**********************************************************************

		This function checks the given path to see if it exists. If it does
	it returns the id of the object to which it points. Otherwise it returns
	NULL.

	$path should always start and end with a '/'.

	**********************************************************************/

		$this->error="";
		$object = null;
		$epath=AddSlashes($path);

		$nodes_tbl=$this->tbl_prefix."nodes";
		$objects_tbl=$this->tbl_prefix."objects";
		$types_tbl=$this->tbl_prefix."types";

		debug("store::exists($path, $layer)", "store");
		
		$query_string="select object from $nodes_tbl where path='$epath'";
		if (!isset($layer)) {
			$layer = (int)$this->getLayer($path);
			$query_string .= " and (layer = $layer OR layer = 0 and id NOT IN (select id from $nodes_tbl where layer = $layer) and $nodes_tbl.path NOT IN (select path from $nodes_tbl where layer = $layer))";		
		} else {
			$layer = (int)$layer;
			$query_string .= " and layer = $layer";
		}
		$temp=$this->store_run_query($query_string);

		if ($temp && ($row=$temp->fetch_array(MYSQLI_ASSOC))) {
			$object=intval($row["object"]);
		}
		return $object;
	}


/*	public function link($source, $destination) {
		die("The store::link() method has been removed!");
		return false;
	}
*/
	public function move($source, $destination) {
	/**********************************************************************

	$destination should always start and end with a '/'.

	**********************************************************************/


		$nodes_tbl=$this->tbl_prefix."nodes";
		$objects_tbl=$this->tbl_prefix."objects";
		$types_tbl=$this->tbl_prefix."types";
		$layer=(int)$this->getLayer($destination);
		
		$this->error="";
		$esource=AddSlashes($source); 
		$parent=$this->make_path($destination, "..");
		$filename=substr($destination, strlen($parent));
		$eparent = AddSlashes($parent);

		$query_string = "select path from $nodes_tbl where path = '$eparent'";
		$qresult = $this->store_run_query($query_string);
		if ($qresult && ($row = $qresult->fetch_array(MYSQLI_ASSOC))){
			$eparent = AddSlashes($row['path']);
			$edestination = AddSlashes($eparent.$filename);

			if (($destId = $this->exists($destination)) &&
					! ( strtolower($destination) === strtolower($source) &&
						$destination !== $source
					)) {

				$this->error="$destination already exists, cannot overwrite.";
				debug("move: ERROR: ".$this->error,"store");
				$result=false;
			} else if (!$this->exists($parent)) {
				$this->error="$parent does not exist, cannot move.";
				debug("move: ERROR: ".$this->error,"store");
				$result=false;
			} else { 
				$mask = substr($destination, strlen($parent));
				if (preg_match("/(.*)\{([0-9]:)?id\}(.*)/",$mask,$matches)) {
					$query_string="lock tables ".$this->tbl_prefix."nodes write";
					$qresult = $this->store_run_query($query_string);
					if ($qresult){
						$needunlocking = true;
						$subid = $this->get_nextid($parent, $mask);
						$destination=preg_replace("/\{([0-9]:)?id\}/",strval($subid),$destination);
						$edestination=AddSlashes($destination);
					} else {
						error("PANIC: could not obtain write lock on nodes table!");
						$this->close();
						exit;
					}
				}
				$id=$this->exists($source);
				if ($id) {
					if ($layer) {
						$temp_table_sql = "create temporary table ".$nodes_tbl."_temp like $nodes_tbl";
						$tmpTblResult   = $this->store_run_query($temp_table_sql);
						if ($tmpTblResult) {
							$destinationlength=strlen($destination);
							$sourcelength=strlen($source);
							$parentlength=strlen($parent);
							// move the top path
							$query_string="insert into ".$nodes_tbl."_temp (path, parent, layer, priority, object, id) select '$edestination', '$eparent', $layer, priority, object, id from $nodes_tbl where path='$esource' and ( $nodes_tbl.layer = $layer OR $nodes_tbl.layer = 0 and $nodes_tbl.id NOT IN (select $nodes_tbl.id from $nodes_tbl where $nodes_tbl.layer = $layer) and $nodes_tbl.path NOT IN (select path from $nodes_tbl where layer = $layer))";
							$result=$this->store_run_query($query_string);
							if ($result) {
								// now move all the children
								$query_string="insert into ".$nodes_tbl."_temp (path, parent, layer, priority, object, id) select CONCAT('$edestination', SUBSTRING(path, $sourcelength+1)), CONCAT('$edestination', SUBSTRING(parent, $sourcelength+1)), $layer, priority, object, id from $nodes_tbl where parent like '$esource%' and ( $nodes_tbl.layer = $layer OR $nodes_tbl.layer = 0 and $nodes_tbl.id NOT IN (select $nodes_tbl.id from $nodes_tbl where $nodes_tbl.layer = $layer) and $nodes_tbl.path NOT IN (select path from $nodes_tbl where layer = $layer))";
								$result=$this->store_run_query($query_string);
								if ($result) {
									$query_string = "delete from $nodes_tbl where layer = $layer and path like '$esource%'";
									$result = $this->store_run_query($query_string);
									if ($result) {
										if (isset($destId)) {
											//remove tombstone from this layer
											$query_string = "delete from $nodes_tbl where layer = $layer and path = '$edestination'";
											$this->store_run_query($query_string);
										}
										// copy moved nodes into our current layer
										$query_string = "insert into $nodes_tbl select * from ".$nodes_tbl."_temp";
										$result = $this->store_run_query($query_string);
									}
								}
							}
							$query_string = "drop table ".$nodes_tbl."_temp";
							$this->store_run_query($query_string);
						}
					} else {
						$destinationlength=strlen($destination);
						$sourcelength=strlen($source);
						$parentlength=strlen($parent);
						// move the top path
						$query_string="update $nodes_tbl set path='$edestination', parent='$eparent' where path='$esource' and layer = 0";
						$result=$this->store_run_query($query_string);
						if ($result) {
							// now move all the children
							$query_string="update $nodes_tbl set path=CONCAT('$edestination', SUBSTRING(path, $sourcelength+1)), parent=CONCAT('$edestination', SUBSTRING(parent, $sourcelength+1)) where parent like '$esource%' and layer = 0";
							$result=$this->store_run_query($query_string);
						}
					}
				} else {
					$result=false;
				}
			}

			if ($needunlocking) {
				$query_string = "unlock tables";
				$this->store_run_query($query_string);
			}
		}

		if ($result) {
			return $destination;
		} else {
			return false;
		}
	}


	public function list_paths($path) {
	/**********************************************************************

		This function returns an array of all paths pointing to the same object 
	as $path does.

	**********************************************************************/

		die("store::list_paths has been removed");
	}

	public function get_nextid($path, $mask="{5:id}") {
	/**********************************************************************

		'private' function of mysql store. This will return the next
		'autoid' for $path.

	**********************************************************************/

		$path=AddSlashes($path);
		$nodes_tbl = $this->tbl_prefix."nodes";
		$layer = $this->getLayer( $path );
		$substr_s = strlen($path);
		if (preg_match("/^(.*)\{([0-9]:)?id\}(.*)/",$mask,$matches)) { 
			$subid = 0;
			$mask_pre = $matches[1];
			$substr_s += strlen($mask_pre)+1;
			$substr_l = intval(substr($matches[2], 0, 1));
			if (!$substr_l) {
				$substr_l = 5; // default length is 5
			}
			$mask_post= $matches[3];
			$query_string = "
				select max(substring(path, $substr_s, $substr_l)) as id
				from $nodes_tbl where 
				parent =  '$path' and
				path regexp '^".$path.$mask_pre."[0-9]\{".$substr_l."\}".$mask_post."' and
				object != 0
			";

			if ($layer) {
				$query_string .= " and (layer = $layer OR layer = 0 and id NOT IN (select id from $nodes_tbl where parent = '$path' and layer = $layer) and $nodes_tbl.path NOT IN (select path from $nodes_tbl where layer = $layer))";
			} else {
				$query_string .= " and layer = 0";
			}
			$result = $this->store_run_query($query_string);
			if ($result) {
				$row = $result->fetch_array(MYSQLI_ASSOC);
				$subid  = (int)$row["id"];
			}
			$subid=$subid+1;
			$subid = sprintf("%0".$substr_l."d", $subid);
		}
		return $subid;
	}

} // end class store
