<?php
/******************************************************************************
  PostgreSQL Store 1.0					Ariadne 2.0

  Copyright (C) 1998-2000  Muze, eMAXX

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

  --------------------------------------------------------------------------

  This is an implementation of the store class for PostgreSQL. The store class
  is an interface between Ariadne objects and a storage layer. It is used by
  all Ariadne objects to call templates in other objects or to manipulate the
  location and contents of objects in the Ariadne system.

*******************************************************************************/

define(MAX_PATH_LENGTH, 128);
define(MAX_PROPERTY_LENGTH, 128);
require_once($ariadne."/stores/store.php");

// general objectstore functions
class postgresqlstore extends store {

	protected $connect_id;
	protected $code;
	protected $transaction = false;

	public function __construct($path, $config) {
		global $AR;
	/**********************************************************************************

	 This is the constructor routine for the store object. It takes some configuration 
	 information as arguments and sets up the database connection.

	 $path is the root path of the running script under the document root of
		the webserver.
	 $config contains some database configuration values: "host", "user",
		"password", "database" and the location of the class files for all the used
		types.

	 **********************************************************************************/

		debug("postgresqlstore($path, [array])", "store");
		if (!extension_loaded("pgsql")) {
			dl("pgsql.so");
		}
		$this->error = "";

		$query_string = (($config["host"]) ? "host='".$config["host"]."'" : "").
			" user='".$config["user"]."'".
			" password='".$config["password"]."'".
			" dbname='".$config["database"]."'";

		$this->connect_id = pg_pconnect($query_string) OR DIE ("Could not connect to PostgreSQL database ".$config["database"].". Please create this database manually." );
		$this->root = $path;
		$this->code = $config["code"];
		$this->files = $config["files"];
		$this->tbl_prefix = $config["prefix"];
		$this->transaction = false;

		/* Instantiate module postgresql_compiler */
		include_once($this->code."stores/modules/postgresql_compiler.php");

		/* Instantiate module locking */
		include_once($this->code."modules/mod_lock/postgresql.phtml");
		$this->mod_lock = new postgresqllock($config["prefix"]);
		$this->mod_lock->connect($config["host"], $config["user"], $config["password"], $config["database"]);
		$this->mod_lock->lock_duration = $config["lock_duration"];

		$config["password"] = "";
		$this->proxystore = $this;

		debug("postgresqlstore: end", "all");

	}

	public function call($template, $args, $objects, $options = array() ) {
	/**********************************************************************************
	
	 This function takes a list of objects, the function to be called in each of those
	 objects and the arguments of that function as arguments. The list of objects is of
	 unspecified type and may be different in other implementations of the store 
	 interface.

	 The function will retrieve and instantiate each object in the object list and call
	 the objects call with $function and $args.

	 **********************************************************************************/ 

		debug("call($template, ".debug_serialize($args).", [list])", "store");
		$result = Array();
		$this->error = "";
		$this->count = @pg_numrows($objects["list"]);
		$i = 0;
		while ($row = @pg_fetch_array($objects["list"], $i++)) {
			$object = $this->newobject($row["path"],
					$row["parent"],
					$row["type"],
					unserialize($row["object"]),
					$row["id"],
					$row["lastchanged"],
					$row["vtype"],
					strlen($row["object"]),
					$row["priority"]);

			if ( isset($options['usePathAsKey']) && $options['usePathAsKey'] ) {
				$result[$row['path']] = $object->call($template, $args);
			} else {
				$result[] = $object->call($template, $args);
			}
		}

		if (! $this->count) {
			debug("call: end: no objects found whatsoever.","all");
		} else {
			debug("call: end: $this->count objects found","all");
		}
		$this->total+=$this->count;
		return ($result);
	}

	public function count($objects) {
		return (@pg_numrows($objects["list"]));
	}

	public function info($objects) {
		debug("call($template, $args, [list])","store");
		$i = 0;
		while ($row=@pg_fetch_array($objects["list"], $i++)) {
			unset($row["object"]);
			$result[]=$row;
		}
		return ($result);
	}

	public function get_config($field) {
		debug("store::get_config($field)", "store");
		$result = $this->$field;
		debug("store::get_config: end", "all");
		return $result;
	}

	public function get($path) {
	/**********************************************************************************

	 This function takes as argument a path to an object in the store and will retrieve
	 all the necessary data and return this in the objectlist type needed for 
	 store->call(). If the requested path does not exist, it will retrieve the object
	 with the longest matching path.

	 $path should always start and end with a '/'.

	 **********************************************************************************/

		debug("get($path)","store");
		$this->error = "";
		$result["method"] = "get";
		$result["path"] = $path;
		$epath=AddSlashes($path);

		$nodes_tbl = $this->tbl_prefix."nodes";
		$objects_tbl = $this->tbl_prefix."objects";
		$types_tbl = $this->tbl_prefix."types";

		$query_string = "select $nodes_tbl.path, $nodes_tbl.parent, $nodes_tbl.priority, $objects_tbl.id, $objects_tbl.type, $objects_tbl.object, date_part('epoch', $objects_tbl.lastchanged) as lastchanged, $objects_tbl.vtype from $objects_tbl, $nodes_tbl where $objects_tbl.id=$nodes_tbl.object and lower($nodes_tbl.path)=lower('$epath')";
		$result["list"] = $this->store_run_query($query_string);
		debug("get: end","all");
		return ($result);
	}

	public function touch($id, $timestamp = -1) {
		debug("touch($id, $timestamp)","store");
		$this->error="";

		$nodes_tbl=$this->tbl_prefix."nodes";
		$objects_tbl=$this->tbl_prefix."objects";
		$types_tbl=$this->tbl_prefix."types";

		if ($timestamp == -1) {
			$timestamp = time();
		}

		if (is_string($id)) {
			$epath = AddSlashes($id);
			$query_string = "select $nodes_tbl.object from $nodes_tbl where lower($nodes_tbl.path) = lower('$epath')";
			$qresult = $this->store_run_query($query_string);
			if ($qresult === false) {
				debug("get: failed on query","store");
			} else {
				$temp = pg_fetch_array($qresult);
				$id = $temp["object"];
				debug("Fetched object id(".$id.")","store");
			}
		} else {
			debug("\$id(".$id.") isn't a string, so we do not look it up","store");
		}


		if ($id && !$this->error) {
			$eid = AddSlashes($id);
			$etimestamp = AddSlashes($timestamp);
			$query_string = "update $objects_tbl set lastchanged='".date("r",$timestamp)."' where id = $eid";
			$qresult = $this->store_run_query($query_string);
			if ($qresult === false) {
				debug("touch: failed on query","store");
			} else {
				debug("Updated object","store");
				$result = pg_affected_rows($qresult);
			}
		}
		debug("touch: end","all");
		return $result;
	}

	public function ls($path) {
	/**********************************************************************************

	 This function takes as argument a path to an object in the store and will retrieve
	 all the objects and their data which have this object as their parent. It will 
	 then return this in the objectlist type needed for store->call(). If the requested
	 path does not exist, it will retrieve the object with the longest matching path.

	 $path should always start and end with a '/'.

	 **********************************************************************************/

		debug("ls($path)","store");
		$this->error = "";
		$epath = AddSlashes($path);

		$nodes_tbl = $this->tbl_prefix."nodes";
		$objects_tbl = $this->tbl_prefix."objects";
		$types_tbl = $this->tbl_prefix."types";

		$query_string = "select distinct($nodes_tbl.path), $nodes_tbl.parent, $nodes_tbl.priority, $objects_tbl.id, $objects_tbl.type, $objects_tbl.object, date_part('epoch', $objects_tbl.lastchanged) as lastchanged, $objects_tbl.vtype from $objects_tbl, $nodes_tbl where $objects_tbl.id=$nodes_tbl.object and lower($nodes_tbl.parent)=lower('$epath') order by $nodes_tbl.priority DESC, $nodes_tbl.path";
		$result["method"] = "ls";
		$result["path"] = $path;
		$result["list"] = $this->store_run_query( $query_string);
		debug("ls: query=$query_string","all");
		debug("ls: end","all");
		return ($result);
	}

	public function parents($path, $top="/") {
	/**********************************************************************************

	 This function takes as argument a path to an object in the store. It will return 
	 all objects with a path which is a substring of the given path. The resulsts are 
	 ordered by path (length), shortest paths first.
	 In effect all parents of an object in the tree are called, in order, starting at 
	 the root.

	 $path should always start and end with a '/'.

	 **********************************************************************************/

		debug("parents($path)","store");
		$this->error = "";
		$epath = AddSlashes($path);
		$etop = AddSlashes($top);

		$nodes_tbl = $this->tbl_prefix."nodes";
		$objects_tbl = $this->tbl_prefix."objects";
		$types_tbl = $this->tbl_prefix."types";

		$query_string = "select distinct($nodes_tbl.path), $nodes_tbl.parent, $nodes_tbl.priority, $objects_tbl.id, $objects_tbl.type, $objects_tbl.object, date_part('epoch', $objects_tbl.lastchanged) as lastchanged, $objects_tbl.vtype from $objects_tbl, $nodes_tbl where $objects_tbl.id=$nodes_tbl.object and lower($nodes_tbl.path)=lower(substring('$epath',1,length(path))) and lower($nodes_tbl.path) LIKE lower('$etop%') order by path";
		debug($query_string, "all");
		$result["method"] = "parents";
		$result["path"] = $path;
		$result["list"] = $this->store_run_query( $query_string);
		debug("parents: end","all");
		return ($result);
	}

	public function find($path, $criteria, $limit=100, $offset=0) {
	/**********************************************************************************

	 This function takes as arguments a path to an object in the store and some search
	 criteria. It will search for all matching objects under the given path. If the
	 given path is not in this store but in a substore it will not automatically search
	 that substore. 

	 $criteria is of the form 

	 $criteria ::= ({ $property_name => ({ $valuename => ({ $compare_function, $value }) }) }) 

	 e.g.: $criteria["status"]["value"][">"]="'published'";

	 $path should always start and end with a '/'.

	 **********************************************************************************/
		if (! is_array($criteria) && ($criteria = trim($criteria))) {
			$sqlcompiler = new postgresql_compiler($this, $this->tbl_prefix);
			debug("raw query: $query_raw", "store");
			$query_string = $sqlcompiler->compile($path, $criteria, $limit, $offset);
			if ($sqlcompiler->error) {
				$this->error = $sqlcompiler->error;
			}
			unset($sqlcompiler);
		} else {
			$this->error = "";
			$count = 0;
			$result["method"] = "find";
			$result["path"] = $path;
			$result["criteria"] = $criteria;
			$epath = AddSlashes($path);

			$nodes_tbl = $this->tbl_prefix."nodes";
			$objects_tbl = $this->tbl_prefix."objects";
			$types_tbl = $this->tbl_prefix."types";

			while (list($property, $values) = @each($criteria)) {
				$eproperty=AddSlashes($property);
				if ($property != "object") {
					$from .= ", ".$this->tbl_prefix."prop_$eproperty";
					$where .= " and (";
				}
				while (list($valuename, $compare) = each($values)) {
					while (list($function, $value) = each($compare)) {
						switch(strtolower($function)) {
							case '=':
							case '==':
								$ecompare = '=';
							break;
							case '!=':
							case '<=':
							case '>=':
							case '<':
							case '>':
								$ecompare = $function;
							break;
							case '~=':
							case '=~':
							case 'like':
								$ecompare = "like";
							break;
							case '!~':
							case 'not like':
								$ecompare = "not like";
							break;
						}
						$evaluename = AddSlashes($valuename);
						if ($value == "") { 
							// empty strings as value generate strange results in SQL land
							$value = 0;
						}
						switch($property) {
							case "object" :
								switch($valuename) {
									case ("type") : 
										$where .= " and $objects_tbl.type $ecompare $value ";
									 	break;
									case ("implements") : 
										$types = ", $types_tbl";
										$where .= " and ( $types_tbl.implements $ecompare $value and $objects_tbl.vtype=$types_tbl.type ) ";
										break;
									case ("parent") :
										$where .= " and $nodes_tbl.parent $ecompare $value ";
										break;
									case ("lastchanged") :
										$where .= " and date_part('epoch', $objects_tbl.lastchanged) $ecompare $value ";
										break;
								}
								break;
							default :
								$where .= $this->tbl_prefix."prop_$eproperty.AR_$evaluename $ecompare $value and "; 
						}
					}
				}
				if ($property != "object") {
					$where .= " ".$this->tbl_prefix."prop_$eproperty.object=$objects_tbl.id)	";
				}
			}
			$query_string = "select distinct($nodes_tbl.path), $nodes_tbl.parent, $nodes_tbl.priority, $objects_tbl.id, $objects_tbl.type, $objects_tbl.object, date_part('epoch', $objects_tbl.lastchanged) as lastchanged, $objects_tbl.vtype from $nodes_tbl, $objects_tbl $from $types where $objects_tbl.id=$nodes_tbl.object and lower($nodes_tbl.path) like lower('$epath%')";
	        $where = substr($where,4);
	        if ($where) { 
	          $query_string .= " and ( ( $where ) )";
	        } 
			$query_string.=" order by $nodes_tbl.parent, $nodes_tbl.priority DESC, $nodes_tbl.path";

			if ($limit) {
				$query_string.=" limit $limit";
			}
			if ($offset) {
				$query_string.=" offset $offset";
			}
		}
		$result["list"]=$this->store_run_query( $query_string);


		debug("find: end","all");
		return ($result);
	}

	public function close() {
		parent::close();
		$this->stop_transaction(false);
		return (@pg_close($this->connect_id));
	}

	public function save($path, $type, $data, $properties="", $vtype="", $priority=false) {
	/***************************************************************

		This function takes as argument a path, type, objectdata and 
		possibly a properties list and vtype (virtual type).
		If there exists no object with the given path, a new object is 
		saved with the given type, data, properties and vtype, and a
		new path is saved pointing to it.
		If there does exist an object with the given path, it's object
		data is overwritten with the given data and if vtype is set the
		current vtype is overwritten with the new one.

		$path must be an absolute path (containing no '..' and starting
			with '/')
		$type must be a valid type
		$data can be any string (usually a serialized object.)
		$properties is a multidimensional hash of the following form:
			$properties[{property_name}][][{value_name}]={value}
			{property_name} must be a valid property name
			{value_name} must be a valid value name for this property
			{value} can be a number, boolean or string. If it is a string
				it must be enclosed in single qoutes. All other single 
				quotes in the string must be escaped. e.g:
				"'\'t is a String'"
		example:
			$properties["name"][0]["value"]="'A name'";
			$properties["name"][1]["value"]="'A second name!'";
		if $properties["name"]=1 then all properties for property name
			will be removed.

		$vtype must be a valid type.
	 
		if $properties or $vtype are not set or empty ("",0 or false)
		they will be ignored. $vtype defaults to $type.
		Only those properties listed in $properties will be updated.
		Any other property set will remain as it was.

	***************************************************************/

		debug("save($path, $type, [data], [properties], $vtype, $priority)","store");
		$this->error = "";
		if ($path!="/") {
			$parent = $this->make_path($path, "..");
		} else {
			$parent = "..";
		}
		$eparent = AddSlashes($parent);
		$epath=AddSlashes($path);
		$edata=AddSlashes(serialize($data));
		$etype=AddSlashes($type);
		$epriority=(int)$priority;

		$nodes_tbl = $this->tbl_prefix."nodes";
		$objects_tbl = $this->tbl_prefix."objects";
		$types_tbl = $this->tbl_prefix."types";

		if (strlen($path)<MAX_PATH_LENGTH) {
			$this->start_transaction();
			if ($id = $this->exists($path)) { //update
				debug("save: updating","all");
				$result = $path;
				if ($vtype) { // only change/save vtype if it is explicitly set
					$evtype = AddSlashes($vtype);
					$query_string = "update $objects_tbl set object='$edata', vtype='$evtype', lastchanged=current_timestamp where id=$id"; 
				} else {
					$query_string = "update $objects_tbl set object='$edata', lastchanged=current_timestamp where id=$id"; 
				}
				$err = $this->store_run_query( $query_string);
				if ($err === false) {
					debug("save: update object failed on query!","store");
					$result = 0;
				} else {
					debug("save: query=$query_string","all");
					$err = $this->save_properties($properties, $id, $this); 
					if ($err === false) {
						debug("save: propertie save failed","store");
						$result = 0;
					} else {
						if($priority !== false) {
							$query_string = "update $nodes_tbl set priority=$epriority where path='$epath'";
							$err = $this->store_run_query( $query_string);
							if ($err === false) {
								debug("save: update object failed on query!","store");
								$result = 0;
							}
						}
					}
				}
			} else { // insert new
				debug("save: new","all");
				if ($vtype == "") { // if vtype is not set, it defaults to type for new objects
					if ($subcpos = strpos($type, '.')) {
						$vtype = substr($type, 0, $subcpos);
					} else {
						$vtype=$type; 
					}
				}
				$evtype = AddSlashes($vtype);

				if($priority === false){
					// default priority == 0
					$priority = 0;
					$epriority=(int)$priority;
				}
				$query_string = "LOCK TABLE $nodes_tbl IN SHARE MODE";
				if ($exec = $this->store_run_query( $query_string)) {

					$mask = substr($path, strlen($parent));
					if (preg_match("/^(.*)\{([0-9]:)?id\}(.*)/",$mask,$matches)) { 
						// if the last part of a path matches something like {2:id} this
						// part will automatically create a new number, unique in this directory, and fill it in.
						$subid=$this->get_nextid($parent, $mask);
						$path=preg_replace("/\{([0-9]:)?id\}/",strval($subid),$path);
						$epath=AddSlashes($path);
						debug("save: new path: $path ($subid)","all");
					}
					if (strlen($path)>=MAX_PATH_LENGTH) {
						// extra check on rewritten path
						$this->error="ERROR: Maximum path length exceeded (".MAX_PATH_LENGTH." characters). Please shorten your filename.";
						$result=false;
					} else {
						$query_string = "insert into $objects_tbl (type,object,vtype) values ('$etype','$edata','$evtype')";
						$exec = $this->store_run_query( $query_string);
						$id = false;
						if ($exec !== false) {
							$query_string = "select currval('".$objects_tbl."_id_seq') as id from $objects_tbl";
							$exec = $this->store_run_query( $query_string);
							if ($exec !== false) {
								$row = pg_fetch_array($exec, 0);
								$id = (int)$row["id"];
							}
						}

						if ($exec !== false && ($id !== false)) {
							$query_string = "insert into $nodes_tbl (path,parent,object,priority) values ('$epath','$eparent',$id,$epriority)";
							$exec = $this->store_run_query( $query_string);
							if ($exec) {
								$err = $this->save_properties($properties, $id, $this);
								if ($err === false) {
									debug("save: propertie save failed","store");
									$result = 0;
								} else {
									$result=$path;
								}
							} else {
								debug("save: insert node failed on query!","store");
								$result=0;
							}
						} else {
							debug("save: insert object failed on query!","store");
							$result=0;
						}
					}
				} else {
					error($this->error);
					error("PANIC: could not obtain write lock on nodes table!");
					$this->close();
					exit;
				}
			}
			debug("save: result=(".$result.")","store");
			if($result === 0) {
				$this->stop_transaction(false);
			} else {
				$this->stop_transaction(true);
			}
		} else {
			$this->error="ERROR: Maximum path length exceeded (".MAX_PATH_LENGTH." characters). Please shorten your filename.";
			$result=false;
		}
		debug("save: end","all");
		return $result;
	}

	protected function purge($path) {
	/**********************************************************************
	 
		This function will delete the object pointed to by $path and all
	other paths pointing to that object. It will then remove any property
	for this object from all property tables.
		The function returns the number of paths found and removed or 1 if
	there was no path found (meaning that the object doesn't exist and 
	therefor purge succeeded while doing nothing.)

	 $path should always start and end with a '/'.

	**********************************************************************/

		debug("purge($path)","store");
		$this->error = "";

		$nodes_tbl = $this->tbl_prefix."nodes";
		$objects_tbl = $this->tbl_prefix."objects";
		$types_tbl = $this->tbl_prefix."types";

		$object = $this->exists($path);
		if ($object) {
			$result=false;
			$this->start_transaction();
			$query_string = "delete from $nodes_tbl where object=$object";
			$exec = $this->store_run_query( $query_string);
			if ($exec) {
				$result=pg_cmdtuples($exec);
				if($this->del_property($object) === false){
					$result=false;
				} else {
					$query_string = "delete from $objects_tbl where id=$object";
					$exec = $this->store_run_query($query_string);
					 if (!$exec) {
					 	$result=false;
					 }
				}
			} else {
				$result = false;
			}
		} else { // no such path, so purge already succeeded :)
			$result=1;
		}
		if($result === false) {
			$this->stop_transaction(false);
		} else {
			$this->stop_transaction(true);
		}
		debug("purge: end","all");
		return ($result);
	}

	public function delete($path) {
	/**********************************************************************

		This function deletes the path given. If this is the last path pointing
	to an object, the object will be purged instead.

	$path should always start and end with a '/'.

	**********************************************************************/

		debug("delete($path)","store");
		$this->error = "";
		$epath = AddSlashes($path);
		$paths = $this->list_paths($path);

		$nodes_tbl = $this->tbl_prefix."nodes";
		$objects_tbl = $this->tbl_prefix."objects";
		$types_tbl = $this->tbl_prefix."types";

		if ($paths) {
			if (sizeof($paths) == 1) { // only one path for this object
				$result = $this->purge($path); // therefore purge the object.
			} else { // only delete the given path
				$this->start_transaction();
				$query_string = "delete from $nodes_tbl where path='$epath'";
				$exec = $this->store_run_query( $query_string);
				if($exec){
					if (pg_cmdtuples($exec)) {
						$result = 1;
					} else {
						$result = 0;
					}
					$this->stop_transaction(true);
				} else {
					debug("delete: delete failed on query!","store");
					$this->stop_transaction(false);
				}
			}
		}
		debug("delete: end","all");
		return ($result);
	}

	public function exists($path) {
	/**********************************************************************

		This function checks the given path to see if it exists. If it does
	it returns the id of the object to which it points. Otherwise it returns
	0.

	$path should always start and end with a '/'.

	**********************************************************************/

		debug("exists($path)","store");
		$this->error = "";
		$epath = AddSlashes($path);
		$object = false;

		$nodes_tbl = $this->tbl_prefix."nodes";
		$objects_tbl = $this->tbl_prefix."objects";
		$types_tbl = $this->tbl_prefix."types";

		$query_string = "select object from $nodes_tbl where lower(path)=lower('$epath')";
		$exec = $this->store_run_query( $query_string);
		if ($exec){
			if( (pg_numrows($exec) > 0) && ($row = pg_fetch_array($exec, 0))) {
				$object=intval($row["object"]);
				debug("exists: end (yes)","all");
			} else {
				debug("exists: end (no)","all");
			}
		} else {
			debug("exists: failed on query!","all");
		}
		return ($object);
	}

	public function link($source, $destination) {
	/**********************************************************************

		Link adds an extra path to an already existing object. It has two
	arguments: $source and $destination. $source is an existing path of
	an object, $destination is the new path. $destination must not already
	exist.

	$destination should always start and end with a '/'.

	**********************************************************************/

		debug("link($source,$destination)","store");
		$this->error = "";
		$edestination = AddSlashes($destination);
		$esource = AddSlashes($source); 
		$parent = $this->make_path($destination, "..");
		$eparent = AddSlashes($parent);

		$nodes_tbl = $this->tbl_prefix."nodes";
		$objects_tbl = $this->tbl_prefix."objects";
		$types_tbl = $this->tbl_prefix."types";
		$result = false;

		$this->start_transaction();
		if ($this->exists($destination)) {
			$this->error="$destination already exists, cannot overwrite.";
			debug("link: ERROR: ".$this->error,"store");
			$result = false;
		} else if (!$this->exists($parent)) {
			$this->error = "$parent does not exist, cannot link.";
			debug("link: ERROR: ".$this->error,"store");
			$result = false;
		} else { 
			$mask = substr($destination, strlen($parent));
			if (preg_match("/(.*)\{([0-9]:)?id\}(.*)/",$mask,$matches)) {
				$query_string = "LOCK TABLE $nodes_tbl IN SHARE MODE";
				if ($exec = $this->store_run_query( $query_string)) {
					$subid = $this->get_nextid($parent,$mask);
					$destination = preg_replace("/\{[0-9]:id\}/",strval($subid),$destination);
					$edestination = AddSlashes($destination);
					debug("link: new destination: $destination ($subid)","all");
				} else {
					error("link: ".$this->error);
					error("PANIC: could not obtain write lock on nodes table!");
					$this->close();
					exit;
				}
			}
			$id = $this->exists($source);
			if ($id) {
				$query_string = "insert into $nodes_tbl (path, parent, object ) values ('$edestination', '$eparent', $id)";
				$exec = $this->store_run_query( $query_string);
				if ($exec === false) {
					debug("link: insert node failed on query!","store");
					$result = false;
				}
				debug("link: end","all");
				$result = $destination;
			} else {
				$result = false;
				debug("link: end (no $source)","store");
			}
		}
		debug("link: result=(".$result.")","store");
		if($result === false){
			$this->stop_transaction(false);
		} else {
			$this->stop_transaction(true);
		}
		return ($result);
	}

	protected function store_run_query($query) {
	/**********************************************************************

		`private` function to handle query's and set $this->error when this fails

	**********************************************************************/
		debug("store_run_query: query=(".$query.")","store");
		$result = @pg_exec($this->connect_id,$query);
		$err = pg_errormessage($this->connect_id);
		if ($err) {
			$this->error = "ERROR: PostgreSQL: $err";
			debug("store_run_query: error=(".$this->error.")","store");
			$result = false;
		}
		return $result;
	}

	public function move($source, $destination) {
	/**********************************************************************

	$destination should always start and end with a '/'.

	**********************************************************************/

		debug("move($source,$destination)","store");
		$this->error = "";
		$edestination = AddSlashes($destination);
		$esource = AddSlashes($source); 
		$parent = $this->make_path($destination, "..");
		$eparent = AddSlashes($parent);

		$nodes_tbl = $this->tbl_prefix."nodes";
		$objects_tbl = $this->tbl_prefix."objects";
		$types_tbl = $this->tbl_prefix."types";
		$result = false;

		$this->start_transaction();

		if ($this->exists($destination)) {
			$this->error = "$destination already exists, cannot overwrite.";
			debug("move: ERROR: ".$this->error,"store");
			$result = false;
		} else if (!$this->exists($parent)) {
			$this->error = "$parent does not exist, cannot move.";
			debug("move: ERROR: ".$this->error,"store");
			$result = false;
		} else { 
			$mask = substr($destination, strlen($parent));
			if (preg_match("/(.*)\{([0-9]:)?id\}(.*)/",$mask,$matches)) {
				$query_string = "LOCK TABLE $nodes_tbl IN SHARE MODE";
				$exec = $this->store_run_query( $query_string);
				if ($exec ==! false ) {
					$subid = $this->get_nextid($parent,$mask);
					$destination = preg_replace("/\{[0-9]:id\}/",strval($subid),$destination);
					$edestination = AddSlashes($destination);
					debug("move: new destination: $destination ($subid)","all");
				} else {
					error($this->error);
					error("PANIC: could not obtain write lock on nodes table!");
					$this->close();
					exit;
				}
			}
			$id = $this->exists($source);
			if ($id) {
				$destinationlength = strlen($destination);
				$sourcelength = strlen($source);
				$parentlength = strlen($parent);
				// first move the root path
				$query_string = "update $nodes_tbl set path='$edestination', parent='$eparent' where path='$esource'";
				$exec = $this->store_run_query($query_string);
				if ($exec !== false) {
					// then move the children
					$query_string = "update $nodes_tbl set path=('$edestination' || substring(path FROM $sourcelength+1)), parent=('$edestination' || substring(parent, $sourcelength+1)) where path like '$esource%'";
					$exec=$this->store_run_query($query_string);
					if ($exec === false) {
						$result = false;
						debug("move: update of childen failed on query","all");
					} else {
						$result = true;
					}
				} else {
					$result = false;
					debug("move: update of node failed on query","all");
				}
				debug("move: end","all");
			} else {
				$result = false;
				debug("move: end (no $source)","store");
			}
		}
		if($result === false){
			$this->stop_transaction(false);
		} else {
			$this->stop_transaction(true);
		}
		if ($result) {
			return $destination;
		} else {
			return false;
		}
	}

	public function list_paths($path) {
	/**********************************************************************

		This function returns an array of all paths pointing to the same object 
	as $path does.

	**********************************************************************/

		debug("list_paths($path)","store");
		$this->error = "";

		$nodes_tbl = $this->tbl_prefix."nodes";
		$objects_tbl = $this->tbl_prefix."objects";
		$types_tbl = $this->tbl_prefix."types";

		$object = $this->exists($path);
		$query_string = "select path from $nodes_tbl where object=$object";
		$exec = $this->store_run_query( $query_string);
		$i = 0;
		while ($row=@pg_fetch_array($exec, $i++)) {
			$result[] = $row["path"];
		}
		debug("list_paths: end","all");
		return ($result);
	}

	public function AR_implements($type, $implements) {
	/**********************************************************************

		This function returns 1 if the $type implements the type or
	interface in $implements. Otherwise it returns 0.

	**********************************************************************/

		debug("implements($implements)","store");

		$nodes_tbl = $this->tbl_prefix."nodes";
		$objects_tbl = $this->tbl_prefix."objects";
		$types_tbl = $this->tbl_prefix."types";
		$result = false;

		$query_string = "select distinct type from $types_tbl where implements='".AddSlashes($implements)."' and type='".AddSlashes($type)."'";
		$this->error = "";
		$exec = $this->store_run_query( $query_string);
		if ($exec !== false){
			if( pg_numrows($exec) > 0) {
				$row = pg_fetch_array($exec, 0);
			}
		}
		if ($row) {
			$result = true;
		}
		debug("implements: end ($result)","all");
		return ($result);
	}

	public function load_properties($object, $values="") {
		debug("load_properties($object, [values])","all");
		if ($object) {
			$query_string = "select name from ".$this->tbl_prefix."properties";
			$exec = $this->store_run_query( $query_string);
			$i = 0;
			if($exec !== false){
				while ($prop = @pg_fetch_array($exec, $i++)) {
					if ($value = $this->load_property($object,$prop["name"],$values)) {
						$result[$prop["name"]] = $value;
					}
				}
			}
		}
		debug("load_properties: end","all");
		return ($result);
	}

	public function load_property($object, $property, $values="") {
		debug("load_property($object, $property, [values])","all");

		$nodes_tbl = $this->tbl_prefix."nodes";
		$objects_tbl = $this->tbl_prefix."objects";
		$types_tbl = $this->tbl_prefix."types";

		if ($object) {
			$query_string="select * from ".$this->tbl_prefix."prop_".AddSlashes($property)." where ";
			if (is_array($values)) {
				while (list($name, $value)=each($values)) {
					$query_string.="AR_".AddSlashes($name)."=$value and ";
				}
			}
			$query_string.="object=$object";
			$exec = @$this->store_run_query( $query_string);
			$i = 0;
			$currProp=0;
			while ($prop=@pg_fetch_array($exec, $i++, PGSQL_ASSOC)) {
				reset($prop);
				while (is_array($prop) && (list($name,$val)=each($prop)) ) {
					if ($name != "object") {
						if (is_string($val)) {
							$result[$currProp][substr($name,3)] = "'".AddSlashes($val)."'";
						} else {
							$result[$currProp][substr($name,3)] = $val;
						}
					}
				}
				$currProp++;
			}
		}
		debug("load_property: end","all");
		return ($result);
	}

	public function add_property($object, $property, $values) {
		debug("add_property($object, $property, [values])","all");

		$nodes_tbl = $this->tbl_prefix."nodes";
		$objects_tbl = $this->tbl_prefix."objects";
		$types_tbl = $this->tbl_prefix."types";

		if ($object) {
			while (list($name, $value)=each($values)) {
				if ($value != "") {
					$query_names .= "AR_".AddSlashes($name).", ";
					if(strlen($value) >= MAX_PROPERTY_LENGTH) {
						$query_values .= "substr(".$value.",1,".MAX_PROPERTY_LENGTH."), ";
					} else {
						$query_values .= "$value, ";
					}
				}
			}
			$query_string = "insert into ".$this->tbl_prefix."prop_".AddSlashes($property)." ( ".
				$query_names."object ) values ( ".$query_values."$object )";
			$exec = $this->store_run_query( $query_string);
			if($exec) {
				$result = pg_cmdtuples($exec);
			} else {
				$result = false;
				debug('add_property failed','store');
			}
		}
		debug("add_property: end","all");
		return ($result);
	}

	public function del_property($object, $property="", $values="") {
		debug("del_property($object, $property, [values])","all");
		$result=false;

		$nodes_tbl = $this->tbl_prefix."nodes";
		$objects_tbl = $this->tbl_prefix."objects";
		$types_tbl = $this->tbl_prefix."types";

		if (intval($object)) {
			if (!$property) { // remove all properties for $object
				$query_string = "select name from ".$this->tbl_prefix."properties";
				$exec = $this->store_run_query( $query_string);
				$i = 0;
				if($exec){
					while ($row=@pg_fetch_array($exec, $i++)) {
						$query_string = "delete from ".$this->tbl_prefix."prop_".$row["name"]." where object=$object";
						$exec_del = $this->store_run_query( $query_string);
						if($exec_del){
							$result += pg_cmdtuples($exec_del);
						}
					}
				} else {
					$result = false;
				}
			} else {
				$query_string = "delete from ".$this->tbl_prefix."prop_".AddSlashes($property)." where ";
				if (is_array($values)) {
					while (list($name, $value) = each($values)) {
						$query_string .= "AR_".AddSlashes($name)."=$value and ";
					}
				}
				$query_string .= "object=$object";
				$exec = $this->store_run_query( $query_string);
				if($exec){
					$result = pg_cmdtuples($exec);
				}
			}
		}
		debug("del_property: end","all");
		return $result;
	}


	public function set_nextid($path, $newid) {
	/**********************************************************************

		'private' function of postgresql store. 
		(deprecated, but still available for backward compatibility).

	**********************************************************************/
		return $newid;
	}


	public function get_nextid($path, $mask="{5:id}") {
	/**********************************************************************

		'private' function of postgressql store. This will return the next
		'autoid' for $path.

	**********************************************************************/

		$path=AddSlashes($path);

		$substr_s = strlen($path);
		if (preg_match("/^(.*)\{([0-9]:)?id\}(.*)/",$mask,$matches)) { 
			$subid = 0;
			$mask_pre = $matches[1];
			$substr_s += strlen($mask_pre)+1;
			$substr_l = intval(substr($matches[2], 0, 1));
			$mask_post= $matches[3];
			$query_string = 
				"select max(substr(path, $substr_s, $substr_l)) as id
				from ".$this->tbl_prefix."nodes where 
				path ~ '^".$path.$mask_pre."[0-9]\{".$substr_l."\}".$mask_post."'";

			//error($query_string);
			$result = $this->store_run_query( $query_string);
			if ($result) {
				$row = pg_fetch_array($result);
				$subid = (int)$row["id"];
			}
			$subid=$subid+1;
			$subid = sprintf("%0".$substr_l."d", $subid);
		}
		return $subid;
	}

	protected function start_transaction(){
	/**********************************************************************

		'private' function of postgressql store. This will start a transaction.

	**********************************************************************/
		$query_string = "BEGIN WORK";
		if($this->store_run_query( $query_string)){
			$this->transaction = true;
		}
		return $this->transaction;
	}

	protected function stop_transaction($how){
	/**********************************************************************

		'private' function of postgressql store. This will end a transaction when
		there is a transaction.

	**********************************************************************/
		if($this->transaction){
			if($how){
				$query_string = "COMMIT WORK;";
			} else {
				$query_string = "ROLLBACK WORK;";
			}
			if($this->store_run_query( $query_string)){
				$this->transaction = false;
			}
		}
		return !$this->transaction;
	}

} // end class store

?>