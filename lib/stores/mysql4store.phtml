<?php
/******************************************************************************
  Mysql4 Store 1.0						Ariadne 2.0

  Copyright (C) 1998-2003  Muze 

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

  --------------------------------------------------------------------------

  This is an implementation of the store class for MySQL. The store class is
  an interface between Ariadne objects and a storage layer. It is used by all 
  Ariadne objects to call templates in other objects or to manipulate
  the location and contents of objects in the Ariadne system.

*******************************************************************************/

/* include the base class */
include("mysqlstore.phtml");

// general objectstore functions

class mysql4store extends mysqlstore {

	function mysql4store($path, $config) {
		mysqlstore::mysqlstore($path, $config);
		/* Include module mysql4_compiler */
		include_once($this->code."stores/modules/mysql4_compiler.php");
	}

	function is_supported($feature) {
	/**********************************************************************************
		This function takes as argument a feature description and returns
		true if this feature is supported and false otherwise
	**********************************************************************************/
		switch	($feature) {
			case "fulltext":
			case "fulltext_boolean":
				$result = true;
			break;
			default:
				$result = mysql_store::supported($feature);
			break;
		}
		return $result;
	}

	function find($path, $criteria, $limit=100, $offset=0) {
	/**********************************************************************************

	 This function takes as arguments a path to an object in the store and some search
	 criteria. It will search for all matching objects under the given path. If the
	 given path is not in this store but in a substore it will not automatically search
	 that substore. 

	 $criteria is of the form 

	 $criteria ::= ({ $property_name => ({ $valuename => ({ $compare_function, $value }) }) }) 

	 e.g.: $criteria["status"]["value"][">"]="'published'";

	 $path should always start and end with a '/'.

	 **********************************************************************************/
		debug("find($path, [criteria], $limit, $offset)","store");
		if (!is_array($criteria) && ($criteria=trim($criteria))) {
			$sqlcompiler=new mysql4_compiler($this->tbl_prefix);
			$query_string=$sqlcompiler->compile($path, $criteria, $limit, $offset);
			if ($sqlcompiler->error) {
				$this->error=$sqlcompiler->error;
			}
			unset($sql_compiler);

		} else {
			$this->error="";
			$count=0;
			$result["method"]="find";
			$result["path"]=$path;
			$result["criteria"]=$criteria;
			$epath=AddSlashes($path);

			$nodes_tbl=$this->tbl_prefix."nodes";
			$objects_tbl=$this->tbl_prefix."objects";
			$types_tbl=$this->tbl_prefix."types";

			while (list($property, $values)=@each($criteria)) {
				$eproperty=AddSlashes($property);
				if ($property!="object") {
					$from.=", ".$this->tbl_prefix."prop_$eproperty";
					$where.=" and (";
				}
				while (list($valuename, $compare)=each($values)) {
					while (list($function, $value)=each($compare)) {
						switch(strtolower($function)) {
							case '=':
							case '==':
								$ecompare = '=';
							break;
							case '!=':
							case '<=':
							case '>=':
							case '<':
							case '>':
								$ecompare = $function;
							break;
							case '~=':
							case '=~':
							case 'like':
								$ecompare = "like";
							break;
							case '!~':
							case 'not like':
								$ecompare = "not like";
							break;
						}
						$evaluename=AddSlashes($valuename);
						if ($value=="") { 
							// empty strings as value generate strange results in SQL land
							$value=0;
						}
						switch($property) {
							case "object" :
								switch($valuename) {
									case ("type") : 
										$where.=" and $objects_tbl.type $ecompare $value ";
									 	break;
									case ("implements") : 
										$types=", $types_tbl";
										$where.=" and ( $types_tbl.implements $ecompare $value and $objects_tbl.vtype=$types_tbl.type ) ";
										break;
									case ("parent") :
										$where.=" and $nodes_tbl.parent $ecompare $value ";
										break;
									case ("lastchanged") :
										$value = date("YmdHis", $value);
										$where.=" and $objects_tbl.lastchanged $ecompare $value ";
										break;
								}
								break;
							default :
								$where.=$this->tbl_prefix."prop_$eproperty.AR_$evaluename $ecompare $value and "; 
						}
					}
				}
				if ($property!="object") {
					$where.=" ".$this->tbl_prefix."prop_$eproperty.object=$objects_tbl.id)	";
				}
			}
			$query_string="select distinct($nodes_tbl.path), $nodes_tbl.parent, $nodes_tbl.priority, $objects_tbl.id, $objects_tbl.type, $objects_tbl.object, UNIX_TIMESTAMP($objects_tbl.lastchanged) as lastchanged, $objects_tbl.vtype from $nodes_tbl, $objects_tbl $from $types where $objects_tbl.id=$nodes_tbl.object and $nodes_tbl.path like '$epath%'";
			$where=substr($where,4);
			if ($where) { 
				$query_string.=" and ( ( $where ) )";
			} 
			$query_string.=" order by $nodes_tbl.parent, $nodes_tbl.priority DESC, $nodes_tbl.path";
			if ($limit) {
				$query_string.=" limit ";
				if ($offset) {
					$query_string.="$offset,";
				}
				$query_string.="$limit";
			}
		}
		debug("find: query=$query_string","all");
		$result["list"]=mysql_db_query($this->database,$query_string, $this->connect_id);
		if ($result["list"]) {
			debug("find: end (".mysql_num_rows($result["list"]).")","all");
		}
		return $result;
	}
	

	function format_for_fti($text) {
	/**********************************************************************
 
		This function prepares the passed string to be interpreted properly
	by the store's full text indexing system.
		For MySQL, all characters over 126 and the select allowed characters
	are escaped with the underscore character; whitespace characters are
	collapsed into a single space.

	**********************************************************************/

		debug("format_for_fti($text)","all");
		$allowedchars="_'-";
		$search = array("%[\\x80-\\xFF$allowedchars]%es", "%\\s+%s");
		$replace = array("'_'.dechex(ord('\\0'))", " ");
		return preg_replace($search, $replace, $text);
	}

}
?>