<?php
define("PT_VARIABLE",               254);
define("PT_STRING",                 253);
define("PT_SUBSTRING",              252);
define("PT_IDENT",                  251);
define("PT_UNPARSED",               250);
define("PT_EOF",                    249);
define("PT_MULTIPART_STRING_START", 248);
define("PT_MULTIPART_STRING_END",   247);
define("PT_PINP_START",             246);
define("PT_PINP_END",               245);
define("PT_ERROR",                  244);
define("PT_PAR_OPEN",               243);
define("PT_NEW",                    242);
define("PT_FUNCTION",               241);
define("PT_GLOBAL",                 240);
define("PT_RETURN",                 239);
define("PT_FILENAME",               238);
define("PT_INCLUDE",                237);
define("PT_INCLUDE_ONCE",           236);
define("PT_REQUIRE",                235);
define("PT_REQUIRE_ONCE",           234);
define("PT_PAR_CLOSE",              233);
define("PT_COMMA",                  232);
define("PT_BRACKET_OPEN",           231);
define("PT_BRACKET_CLOSE",          230);
define("PT_VAR_REFERENCE",          229);
define("PT_DQ_STRING",              228);
define("PT_CBRACE_OPEN",            227);
define("PT_CBRACE_CLOSE",           226);
define("PT_NUMBER",                 225);
define("PT_END_STMT",               224);
define("PT_FOR_STMT",               223);
define("PT_NAMESPACE",              222);
define("PT_NAMESPACE_SEPERATOR",    221);
define("PT_USE",                    220);
define("PT_AS",                     219);
define("PT_THROW",                  218);
define("PT_TRY",                    217);
define("PT_CATCH",                  216);
define("PT_CBRACE_OPEN_VAR",        215);
define("PT_VAR_CBRACE_OPEN",        214);
define("PT_HEREDOC",                213);
define("PT_EXT_COMPILE_START",      212);
define("PT_EXT_COMPILE_END",        211);
define("PT_ARRAY_OP",               210);
define("PT_CLASS_OPERATOR",         209);
define("PT_OBJECT_OPERATOR",        208);
define("PT_ASSIGN_OP",              207);

define("YY_STATE_HTML",               1);
define("YY_STATE_PINP",               2);
define("YY_STATE_EXT_COMPILE",        3);
define("YY_STATE_DQ",                 4);

class scanner {

	function __construct() {
		/*
			create lookup table for language constructs
		*/
		$this->YYLANG_CONSTRUCTS = Array(
			"new" => PT_NEW,
			"function" => PT_FUNCTION,
			"global" => PT_GLOBAL,
			"return" => PT_RETURN,
			"__file__" => PT_FILENAME,
			"include" => PT_INCLUDE,
			"include_once" => PT_INCLUDE_ONCE,
			"require" => PT_REQUIRE,
			"require_once" => PT_REQUIRE_ONCE,
			"for" => PT_FOR_STMT,
			"namespace" => PT_NAMESPACE,
			"use"	=> PT_USE,
			"throw" => PT_THROW,
			"try"	=> PT_TRY,
			"catch"	=> PT_CATCH
		);


		
		
		/*
			create character classes
		*/
		for ($c = ord('a'); $c <= ord('z'); $c++) {
			$cclass[chr($c)] = chr($c);
			$cclass[strtoupper(chr($c))] = strtoupper(chr($c));
		}
		$cclass["_"] = "_";
		$this->YYCLASSES["ID_FIRST"] = $cclass;

		$cclass_second = $cclass;
		for ($c = ord('0'); $c <= ord('9'); $c++) {
			$cclass_second[chr($c)] = 1;
		}
		$this->YYCLASSES["ID_SECOND"] = $cclass_second;

		$cclass_trailing["\n"] = 1;
		$cclass_trailing[" "] = 1;
		$cclass_trailing["\t"] = 1;
		$cclass_trailing[chr(13)] = 1;
		$this->YYCLASSES["NOISE"] = $cclass_trailing;

		$cclass['"'] = '"';
		$cclass["'"] = "'";
		$cclass['$'] = '$';
		$cclass['/'] = '/';
		$cclass['-'] = '-';
		$cclass['`'] = '`';
		$cclass['<'] = '<';
		$cclass['%'] = '%';
		$cclass['?'] = '?';
		$cclass['('] = '(';
		$cclass[')'] = ')';
		$cclass['#'] = '#';
		$cclass[','] = ',';
		$cclass['{'] = '}';
		$cclass['}'] = '{';
		$cclass['='] = '=';
		$cclass['0'] = '0';
		$cclass['1'] = '1';
		$cclass['2'] = '2';
		$cclass['3'] = '3';
		$cclass['4'] = '4';
		$cclass['5'] = '5';
		$cclass['6'] = '6';
		$cclass['7'] = '7';
		$cclass['8'] = '8';
		$cclass['9'] = '9';
		$cclass[';'] = ';';
		$cclass[chr(0)] = 1;
		$this->YYCLASSES["START_TRANSITION"] = $cclass;
	}

	function init($buffer, $state = "html") {
		$this->YYBUFFER = $buffer."\0";
		$this->YYLINE = 1;
		switch ($state) {
			case "pinp":
				$this->YYSTATE = YY_STATE_PINP;
			break;
			case "html":
			default:
				$this->YYSTATE = YY_STATE_HTML;
			break;
		}
		$this->YYCURSOR = 0;
	}

	function print_current_range() {
		echo "scanner: (".substr($this->YYBUFFER, $this->YYCURSOR - 4, 4).") ";
		echo "[".$this->YYBUFFER[$this->YYCURSOR]."] ";
		echo "(".substr($this->YYBUFFER, $this->YYCURSOR +1, 4).")\n";
	}
	
	function push_back($string) {
		$this->YYLINE -= substr_count($string, "\n");
		$this->YYCURSOR = $this->YYCURSOR - strlen($string);
	}

	function ext_compile($engine, $string) {
		if ($engine == "lessc") { // FIXME: Define an API for compiler classes so that no specific configuration is needed here.
			return ar('formats/less')->compile($string);
		} else if ($engine == "jsmin") {
			return ar('beta/jsmin')->compile($string);
		} else if ($engine == "test") {
			return "[[ TEST ]] $string [[ /TEST ]]";
		}
		return false;
	}

	function scan(&$result) {
		global $AR;
		$YYCURSOR = &$this->YYCURSOR;
		$YYBUFFER = &$this->YYBUFFER;
		$YYCLASSES = &$this->YYCLASSES;
		$YYCURSOR_START = $YYCURSOR;
		$YYSTATE = &$this->YYSTATE;

		do {
			$yych = $YYBUFFER[$YYCURSOR];
			switch ($YYSTATE) {
				case YY_STATE_HTML:
					if (ord($yych) == 0) {
						return PT_EOF;
					} else if (ord($yych == 12)) {
						return PT_EOF;
					} else {
						$matches='';
						$scan_buffer = substr($YYBUFFER, $YYCURSOR, -1);
						$re_code="^(.*)(<pinp>|<compile:[^>]+>|<script[^>]+language[^>]*=[^>]*php[^>]*>|<[%?])";
						if (preg_match("!".$re_code."!Usi", $scan_buffer, $matches)) {

							$this->YYLINE += substr_count($matches[1], "\n");
							if ($matches[2]) {
								if (strtolower($matches[2]) === "<pinp>") {
									/* pinp tag found */
									$result = $matches[1];
									$YYCURSOR+=strlen($matches[0]);
									$YYSTATE = YY_STATE_PINP;
									return PT_PINP_START;
								} else if (strpos(strtolower($matches[2]), "<compile:") === 0) {
									/* compile tag found */
									$result = $matches[1];
									$YYCURSOR+=strlen($matches[0]);
									$YYSTATE = YY_STATE_EXT_COMPILE;
									return PT_EXT_COMPILE_START;
								} else {
									/* php start tag found */
									$result = $matches[1];
									$YYCURSOR+=strlen($matches[0]);
									$result .= "<?"."php echo \"".str_replace('$', '\\$', AddCSlashes($matches[2], ARESCAPE))."\"; ?".">";
									return PT_UNPARSED;
								}
							} else {
								$result = $matches[1];
								$YYCURSOR+=strlen($matches[0]);
								return PT_UNPARSED;
							}
						} else {
							$result = $scan_buffer;
							$YYCURSOR = strlen($YYBUFFER)-1; // disregard the added "\0"
							return PT_UNPARSED;
						}
					}
				break;
				case YY_STATE_DQ:
					switch ($yych) {
						case '{':
							$result = $yych;
							$yych = $YYBUFFER[++$YYCURSOR];
							if ($yych == '$') {
								$result .= $yych;
								return PT_CBRACE_OPEN_VAR;
							}
							return PT_CBRACE_OPEN;
						break;
						case '$':
							$result = $yych;
							$yych = $YYBUFFER[++$YYCURSOR];
							if ($yych == '{') {
								$result .= $yych;
								++$YYCURSOR;
								return PT_VAR_CBRACE_OPEN;
							}
							if ($yych == '"') {
								return PT_SUBSTRING;
							}
							--$YYCURSOR;
							return PT_VAR_REFERENCE;
						break;
						case '"':
							$result = $yych;
							$yych = $YYBUFFER[++$YYCURSOR];
							while ($YYCLASSES["NOISE"][$yych]) {
								$result .= $yych;
								if ($yych == "\n") {
									$this->YYLINE++;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							return PT_DQ_STRING;
						break;
						case "\0":
							$this->error = "Unterminated double quote.";
							return PT_ERROR;
						break;
						case "\n";
							$this->YYLINE++;
							++$YYCURSOR;
							$result = $yych;
							return PT_SUBSTRING;
						break;
						default:
							while (ord($yych)!==0 && !in_array($yych, Array('"', '$', '{', "\n"))) {
								if ($yych == '\\') {
									++$YYCURSOR;
								} else
								if ($yych == "\n") {
									$this->YYLINE++;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
							return PT_SUBSTRING;
						break;

					}
				break;
				case YY_STATE_PINP:
					switch($yych) {
						/*
							Single characters directly beneath here
						*/
						case ';': ($token || $token = PT_END_STMT);
						case '{': ($token || $token = PT_CBRACE_OPEN);
						case '}': ($token || $token = PT_CBRACE_CLOSE);
						case ',': ($token || $token = PT_COMMA);
						case '(': ($token || $token = PT_PAR_OPEN);
						case ')': ($token || $token = PT_PAR_CLOSE);
						case '[': ($token || $token = PT_BRACKET_OPEN);
						case ']': ($token || $token = PT_BRACKET_CLOSE);
						case '\\':($token || $token = PT_NAMESPACE_SEPERATOR);
							$yych = $YYBUFFER[++$YYCURSOR];
							while ($YYCLASSES["NOISE"][$yych]) {
								if ($yych == "\n") {
									$this->YYLINE++;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
							return $token;
						break;

						case '$': 
							$result = Array();
							array_push($result, Array(PT_VAR_REFERENCE => $yych));
							$YYCINC = 1;

							$yych = $YYBUFFER[++$YYCURSOR];
							if ($yych == '{') {
								array_push($result, Array(PT_CBRACE_OPEN => $yych));
								return ++$YYCURSOR;
							} else {
								while ($yych == '$') {
									$YYCINC++;
									array_push($result, Array(PT_VAR_REFERENCE => $yych));
									$yych = $YYBUFFER[++$YYCURSOR];
								}
								if ($YYCLASSES["ID_FIRST"][$yych]) {
									$yych = $YYBUFFER[++$YYCURSOR];
									while ($YYCLASSES["ID_SECOND"][$yych]) {
										$yych = $YYBUFFER[++$YYCURSOR];
									}
									while ($YYCLASSES["NOISE"][$yych]) {
										if ($yych == "\n") {
											$this->YYLINE++;
										}
										$yych = $YYBUFFER[++$YYCURSOR];
									}
									$ident = substr($YYBUFFER, $YYCURSOR_START+$YYCINC, $YYCURSOR-$YYCURSOR_START-$YYCINC);
									array_push($result, Array(PT_IDENT => $ident));

									return PT_VARIABLE;
								} else {
									$result = '$';
									$this->error = "single dollar sign";
									return PT_ERROR;
								}
							}
						break;

						case '%':
						case '?':
							$result = $yych;
							$yych = $YYBUFFER[++$YYCURSOR];
							if ($yych == '>') {
								$this->error = "php tags found at line: ".$this->YYLINE;
								return PT_ERROR;
							} else {
								return PT_UNPARSED;
							}
						break;

						case '=':
							$yych	= $YYBUFFER[++$YYCURSOR];
							$token	= PT_ASSIGN_OP;
							if ($yych === '>') {
								$token	= PT_ARRAY_OP;
								$yych	= $YYBUFFER[++$YYCURSOR];
							}
							while ($YYCLASSES["NOISE"][$yych]) {
								if ($yych == "\n") {
									$this->YYLINE++;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
							return $token;
						break;


						case '<':
							$yych = $YYBUFFER[++$YYCURSOR];
							switch ($yych) {
								case '/':
									$yych = $YYBUFFER[++$YYCURSOR];
									while ($yych == ' ') {
										$yych = $YYBUFFER[++$YYCURSOR];
									} 
									$tag_element = "";
									while ($yych != ' ' && ord($yych)!==0 && $yych != '>') {
										$tag_element .= $yych;
										$yych = $YYBUFFER[++$YYCURSOR];
									}
									while (ord($yych)!==0 && $yych!='>') {
										$yych = $YYBUFFER[++$YYCURSOR];
									}
									if ($yych=='>') {
										++$YYCURSOR;
									}
									$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
									if ($tag_element == "pinp") {
										$YYSTATE = YY_STATE_HTML;
										return PT_PINP_END;
									} else {
										return PT_UNPARSED;
									}
								break;
								case '<':
									$yych = $YYBUFFER[++$YYCURSOR];
									if ($yych == '<') {
										// skip spaces and tabs
										while (in_array($yych = $YYBUFFER[++$YYCURSOR], Array(" ", "\t")));

										$result = Array();
										array_push($result, Array(PT_HEREDOC => substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START)));

										$ID_START = $YYCURSOR;
										if ($YYCLASSES["ID_FIRST"][$yych]) {
											$yych = $YYBUFFER[++$YYCURSOR];
											while ($YYCLASSES["ID_SECOND"][$yych]) {
												$yych = $YYBUFFER[++$YYCURSOR];
											}
											if ($yych === "\r") {
												$yych = $YYBUFFER[++$YYCURSOR];
											}
											$this->YYLINE++;
											++$YYCURSOR;
											array_push($result, Array(PT_IDENT => $frop = substr($YYBUFFER, $ID_START, $YYCURSOR-$ID_START)));
											if ($yych !== "\n") {
												$this->error = "Heredoc syntax error: expected newline after heredoc identifier";
												array_push($result, Array(PT_ERROR => ""));
												return PT_ERROR;
											}
											return PT_HEREDOC;
										} else {
											$this->error = "Heredoc syntax error.";
											array_push($result, Array(PT_ERROR => ""));
											return PT_ERROR;
										}
										
									} else {
										$result = "<<";
									}
								break;
								default:
									$result = "<";
								break;
							}
							return PT_UNPARSED;
						break;
						case '/':
							$result = $yych;
							$yych = $YYBUFFER[++$YYCURSOR];
							switch ($yych) {
								case '/':
									$result .= $yych;
									$yych = $YYBUFFER[++$YYCURSOR];
									while ($yych != "\n" && $yych != "\r" && ord($yych)!==0) {
										$yych = $YYBUFFER[++$YYCURSOR];
									}
									return PT_UNPARSED;
								break;
								case '*':
									$result .= $yych;
									$start_line = $this->YYLINE;
									$yych = $YYBUFFER[++$YYCURSOR];
									while (ord($yych)!==0) {
										if ($yych == "\n") {
											$result .= $yych;
											$this->YYLINE++;
										}
										if ($yych == '*') {
											$result .= $yych;
											if  (($yych = $YYBUFFER[++$YYCURSOR]) == '/') {
												$result .= $yych;
												++$YYCURSOR;
												return PT_UNPARSED;
											}
										} else {
											$yych = $YYBUFFER[++$YYCURSOR];
										}
									}
									$this->error = "unterminated comment, started at $start_line";
									return PT_ERROR;
								break;
								default:
									return PT_UNPARSED;
								break;
							}
						break;

						case '0':
						case '1':
						case '2':
						case '3':
						case '4':
						case '5':
						case '6':
						case '7':
						case '8':
						case '9':
							$yych = $YYBUFFER[++$YYCURSOR];
							while ($yych >= "0" && $yych <= "9") {
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							if ($yych === '.') {
								$yych = $YYBUFFER[++$YYCURSOR];
								while ($yych >= "0" && $yych <= "9") {
									$yych = $YYBUFFER[++$YYCURSOR];
								}
							}
							while ($YYCLASSES["NOISE"][$yych]) {
								if ($yych == "\n") {
									$this->YYLINE++;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
							return PT_NUMBER;
						break;

						case $this->YYCLASSES["ID_FIRST"][$yych]:
							/* Identifier */
							$yych = $YYBUFFER[++$YYCURSOR];
							while ($YYCLASSES["ID_SECOND"][$yych]) {
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							while ($YYCLASSES["NOISE"][$yych]) {
								if ($yych == "\n") {
									$this->YYLINE++;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
							$construct = $this->YYLANG_CONSTRUCTS[chop(strtolower($result))];
							if ($construct) {
								return $construct;
							} else {
								return PT_IDENT;
							}
						break;
						case ':':
							$yych = $YYBUFFER[++$YYCURSOR];
							switch ($yych) {
								case ':':
									$yych = $YYBUFFER[++$YYCURSOR];
									$result = "::";
									return PT_CLASS_OPERATOR;
								break;
								default:
									$result = ":";
									return PT_UNPARSED;
								break;
							}
							
						break;
						case '`':
							$result = $yych;
							++$YYCURSOR;
							$this->error = "backtick encounterd at line ".$this->YYLINE;
							return PT_ERROR;
						break;
						case '"':
							$result = $yych;
							++$YYCURSOR;
							return PT_DQ_STRING;
						break;
						case "'":
							$start_line = $this->YYLINE;
							$yych = $YYBUFFER[++$YYCURSOR];
							while ($yych != "'" && ord($yych)!==0) {
								if ($yych == '\\') {
									++$YYCURSOR;
								} else
								if ($yych == "\n") {
									$this->YYLINE++;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							if (ord($yych)!==0) {
								while ($YYCLASSES["NOISE"][$yych = $YYBUFFER[++$YYCURSOR]]) {
									if ($yych == "\n") {
										$this->YYLINE++;
									}
									//$yych = $YYBUFFER[++$YYCURSOR];
								}
								$result=substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR - $YYCURSOR_START);
								return PT_STRING;
							} else {
								$result=substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR - $YYCURSOR_START);
								$this->error = "unterminated single quote, started at line: $start_line";
								return PT_ERROR;
							}
						break;
						case "-":
							if (($yych=$YYBUFFER[++$YYCURSOR])=='>') {
								$token = PT_OBJECT_OPERATOR;
								$yych = $YYBUFFER[++$YYCURSOR];
							} else {
								$token = PT_UNPARSED;
							}
							while ($YYCLASSES["NOISE"][$yych]) {
								if ($yych == "\n") {
									$this->YYLINE++;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
							return $token;
						break;
						case "\0":
							$result = $yych;
							return PT_EOF;
						break;
						case $YYCLASSES["START_TRANSITION"][$yych]:
							// unhandled start_transition
							++$YYCURSOR;
							$result = $yych;
							return PT_UNPARSED;
						break;
						default:
							while (!$YYCLASSES["START_TRANSITION"][$yych] && ord($yych) !== 0) {
								if ($yych == "\n") {
									$this->YYLINE++;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
							return PT_UNPARSED;
						break;
					}
				break;
				case YY_STATE_EXT_COMPILE:
						$startLine = $this->YYLINE;
						do {
							while ($yych !== '<' && ord($yych) !== 0) {
								if ($yych == "\n") {
									$this->YYLINE++;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}

							if ($yych === '<') {
								$yych = $YYBUFFER[++$YYCURSOR];
								switch ($yych) {
									case '/':
										$yych = $YYBUFFER[++$YYCURSOR];
										while ($yych == ' ') {
											$yych = $YYBUFFER[++$YYCURSOR];
										} 
										$tag_element = "";
										while ($yych != ' ' && ord($yych)!==0 && $yych != '>') {
											$tag_element .= $yych;
											$yych = $YYBUFFER[++$YYCURSOR];
										}
										while (ord($yych)!==0 && $yych!='>') {
											$yych = $YYBUFFER[++$YYCURSOR];
										}
										if ($yych=='>') {
											++$YYCURSOR;
										}

										if (preg_match('|^compile:([a-z]+)|i', $tag_element, $matches)) {
											$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR -$YYCURSOR_START - (strlen($tag_element) + 3) );
											$result = $this->ext_compile($matches[1], $result);
											if ( ! ar_error::isError($result) ){

												$pinp=new pinp($AR->PINP_Functions, "local->", "\$AR_this->_");
												$result=$pinp->compile($result);

												if ($result === false) {
													$this->error = "Compiler '".$matches[1]."' not found (started at line $startLine) ";
													return PT_ERROR;
												}
												$YYSTATE = YY_STATE_HTML;
												return PT_EXT_COMPILE_END;
											} else {
													$this->error = "Compiler error in compiler ".$matches[1]." (started at line $startLine) ";
													return PT_ERROR;
											}
										} else {
											continue 2;
										}
									break;
									default:
										continue 2;
									break;
								}
							}
							break;
						} while (1);

						$YYSTATE = YY_STATE_HTML;
						$result = $yych;
						return PT_EOF;
				break;

			}
		} while (1);
	}
}

class pinp {

	function __construct($allowed_functions, $var_prefix, $function_prefix="") {
		$var_prefix="\$".$var_prefix;
		if (!$function_prefix) {
			$function_prefix=$var_prefix;
		}
		if (is_array($allowed_functions)) {
			$allowed_functions=implode("|", $allowed_functions);
		}

		$this->var_prefix = $var_prefix;
		$this->function_prefix = $function_prefix;

		// warning: don't remove the first | in the first list of functions
		$array_funcs="|array|array_change_key_case|array_chunk|array_column|array_combine|array_count_values|".
		  "array_diff_assoc|array_diff_key|array_diff|array_fill|array_fill_keys|".
		  "array_flip|array_intersect|array_intersect_assoc|array_intersect_key|array_key_exists|array_keys|".
		  "array_merge|array_merge_recursive|array_multisort|array_pad|array_pop|".
		  "array_product|array_push|array_rand|array_replace|array_replace_recursive|array_reverse|array_search|".
		  "array_shift|array_slice|array_splice|array_sum|array_unique|array_unshift|array_values|arsort|asort|".
		  "compact|count|current|each|end|extract|in_array|key|key_exists|krsort|ksort|list|natsort|natcasesort|".
		  "next|pos|prev|range|reset|rsort|shuffle|sizeof|sort";
		$object_funcs="get_class|get_class_methods|get_class_vars|get_object_vars|get_parent_class|".
		  "is_a|is_subclass_of|method_exists|property_exists";
		$ctype_funcs="ctype_alnum|ctype_alpha|ctype_cntrl|ctype_digit|ctype_lower|ctype_print|ctype_punct|".
		  "ctype_space|ctype_Upper|ctype_xdigit";
		$control_funcs="if|else|elseif|do|while|for|switch|foreach|throw";
		$filter_funcs="filter_has_var|filter_id|filter_input_array|filter_input|filter_list|filter_var_array|filter_var";
		$datetime_funcs="checkdate|date|getdate|gettimeofday|gmdate|gmmktime|".
	      "gmstrftime|localtime|microtime|mktime|strftime|time|strtotime|".
		  "easter_days|easter_date|date_create|date_add|date_create_from_format|".
		  "date_date_set|date_default_timezone_get|date_default_timezone_set|date_diff|".
		  "date_format|date_get_last_errors|date_interval_create_from_date_string|".
		  "date_interval_format|date_isodate_set|date_modify|date_offset_get|date_parse_from_format|".
		  "date_parse|date_sub|date_sun_info|date_sunrise|date_sunset|date_time_set|".
		  "date_timestamp_get|date_timestamp_set|date_timezone_get|date_timezone_set|".
		  "idate|strptime|timezone_abbreviations_list|timezone_identifiers_list|".
		  "timezone_location_get|timezone_name_from_abbr|timezone_name_get|".
		  "timezone_offset_get|timezone_open|timezone_transitions_get|timezone_version_get";
		$math_funcs="abs|acos|acosh|asin|asinh|atan|atanh|atan2|base_convert|bindec|ceil|cos|".
	      "cosh|decbin|dechex|decoct|deg2rad|exp|expm1|floor|fmod|getrandmax|is_finite|is_infinite|".
	      "hexdec|hypot|lcg_value|log|log10|log1p|max|min|".
	      "mt_rand|mt_srand|mt_getrandmax|money_format|octdec|pi|pow|rad2deg|rand|round|".
	      "sin|sinh|sqrt|srand|tan|tanh|bcadd|bccomp|bcdiv|bcmod|bcmul|bcpow|bcpowmod|bcscale|bcsqrt|".
		  "bcsub|gmp_[a-z_]+";
		$misc_funcs="mail|highlight_string|pack|unpack|get_browser|get_class|uniqid|clone|set_time_limit|hash|".
		  "json_encode|json_decode|json_last_error|is_a|sleep|usleep|func_get_arg|func_get_args|func_num_args|".
		  "random_int|random_bytes";
		$zlib_funcs="gzinflate|gzcompress|gzdecode|gzdeflate|gzencode|gzuncompress|zlib_encode|zlib_decode|zlib_get_coding_type";
		$net_funcs="checkdnsrr|dns_check_record|gethostbyaddr|gethostbyname|gethostbynamel|getmxrr|".
		  "getprotobyname|getprotobynumber|header_remove|header|headers_list|headers_sent|http_response_code|".
		  "inet_ntop|inet_pton|setcookie|setrawcookie|".
		  "dns_get_mx|dns_get_record|getservbyport|getservbyname|ip2long|long2ip|get_headers|http_build_query";
		$regex_funcs="ereg|ereg_replace|eregi|eregi_replace|split|spliti|preg_match|".
		  "preg_match_all|preg_split|preg_quote|preg_grep|preg_filter|preg_last_error";
		$stream_functs="stream_context_create|stream_context_get_options|stream_context_get_params|stream_context_set_option|stream_context_set_params";
		$string_funcs="addslashes|addcslashes|bin2hex|chop|chr|chunk_split|".
		  "convert_cyr_string|convert_uudecode|convert_uuencode|count_chars|crc32|crypt|echo|explode|flush|".
		  "get_html_translation_table|htmlentities|htmlspecialchars|htmlspecialchars_decode|hex2bin|implode|join|".
		  "levenshtein|localeconv|ltrim|md5|sha1|metaphone|nl2br|ord|parse_str|print|printf|".
		  "quoted_printable_decode|quoted_printable_encode|html_entity_decode|html_entity_encode|".
		  "quotemeta|rawurldecode|rawurlencode|rtrim|str_rot13|str_getcsv|str_ireplace|".
	      "sscanf|setlocale|similar_text|soundex|sprintf|strncasecmp|strcasecmp|strchr|str_shuffle|".
		  "strcmp|strcoll|strcspn|strip_tags|stripcslashes|stripslashes|stristr|strlen|str_split|".
		  "strnatcmp|strnatcasecmp|strncasecmp|strncmp|str_pad|strpbrk|strpos|strrchr|str_repeat|strrev|str_word_count|".
		  "strrpos|strripos|strspn|strstr|strtok|strtolower|strtoupper|str_replace|strtr|substr|stripos|".
		  "substr_compare|substr_count|substr_replace|trim|ucfirst|ucwords|vprintf|vsprintf|wordwrap|".
		  "base64_decode|base64_encode|urldecode|urlencode|parse_url|basename|dirname|pathinfo|".
		  "mb_convert_encoding|utf8_encode|utf8_decode|number_format|lcfirst|nl_langinfo";
		$var_funcs="boolval|doubleval|empty|floatval|gettype|intval|is_array|is_bool|is_double|".
		  "is_float|is_int|is_integer|is_long|is_null|is_numeric|is_object|is_real|".
		  "is_resource|is_scalar|is_string|isset|settype|serialize|strval|unserialize|".
		  "unset|print_r|var_dump|var_export|is_callable";
		$xml_funcs="xmldoc|xmltree|domxml_[a-z_]+|xpath_[a-z_]+|xptr_[a-z_]+|".
		  "xml_parser_create|xml_parse_into_struct|xml_parser_free|".
		  "xml_parser_get_option|xml_parser_set_option";
		$debug_funcs="debug|debugon|debugoff|pftime|pfprint|pfreset|error";
		$loader_funcs="ldaccesscas|ldheader|ldredirect|ldsetcontent|ldsetclientcache|ldgetusercookie|ldsetusercookie|ldgetclientvar|ldregisterfile|ldgetservervar|ar|ldgeneratesessionkeycheck|ldaccessdenied|lddisablepostprocessing|ldgetrequestedhost";
		$ob_funcs="flush|ob_clean|ob_end_clean|ob_end_flush|ob_flush|ob_get_clean|ob_get_contents|".
		  "ob_get_flush|ob_get_length|ob_get_level|ob_get_status|ob_implicit_flush|ob_list_handlers|".
		  "output_add_rewrite_var|output_reset_rewrite_vars";
		$iconv_funcs="iconv_get_encoding|iconv_mime_decode_headers|iconv_mime_decode|iconv_mime_encode|iconv_set_encoding|iconv_strlen|".
		  "iconv_strpos|iconv_strrpos|iconv_substr|iconv";
		$mb_funcs="mb_check_encoding|mb_convert_case|mb_convert_encoding|".
		  "mb_convert_kana|mb_convert_variables|mb_decode_mimeheader|mb_decode_numericentity|mb_detect_encoding|".
		  "mb_detect_order|mb_encode_mimeheader|mb_encode_numericentity|mb_encoding_aliases|mb_ereg_match|".
		  "mb_ereg_replace|mb_ereg_search_getpos|mb_ereg_search_getregs|mb_ereg_search_init|mb_ereg_search_pos|".
		  "mb_ereg_search_regs|mb_ereg_search_setpos|mb_ereg_search|mb_ereg|mb_eregi|mb_eregi_replace|mb_eregi|".
		  "mb_get_info|mb_http_input|mb_http_output|mb_language|mb_list_encodings|mb_parse_str|mb_preferred_mime_name|".
		  "mb_regex_encoding|mb_regex_set_options|mb_send_mail|mb_split|mb_strcut|mb_strimwidth|mb_stripos|mb_stristr|".
		  "mb_strlen|mb_strpos|mb_strrchr|mb_strrichr|mb_strripos|mb_strrpos|mb_strstr|mb_strtolower|mb_strtoupper|".
		  "mb_strwidth|mb_substitute_character|mb_substr_count|mb_substr";
		$pspell_funcs="pspell_add_to_personal|pspell_add_to_session|pspell_check|pspell_clear_session|pspell_config_create|".
		  "pspell_config_ignore|pspell_config_mode|pspell_config_runtogether|pspell_config_save_repl|pspell_new_config|".
		  "pspell_new_personal|pspell_new|pspell_save_wordlist|pspell_store_replacement|pspell_suggest";
		$imap_funcs="imap_8bit|imap_alerts|imap_append|imap_base64|imap_binary|imap_body|imap_bodystruct|imap_check|imap_clearflag_full|".
		  "imap_close|imap_create|imap_createmailbox|imap_delete|imap_deletemailbox|imap_errors|imap_expunge|imap_fetch_overview|".
		  "imap_fetchbody|imap_fetchheader|imap_fetchmime|imap_fetchstructure|imap_fetchtext|imap_gc|imap_get_quota|imap_get_quotaroot|".
		  "imap_getacl|imap_getmailboxes|imap_getsubscribed|imap_header|imap_headerinfo|imap_headers|imap_last_error|imap_list|".
		  "imap_listmailbox|imap_listscan|imap_listsubscribed|imap_lsub|imap_mail_compose|imap_mail_copy|imap_mail_move|imap_mail|".
		  "imap_mailboxmsginfo|imap_mime_header_decode|imap_msgno|imap_num_msg|imap_num_recent|imap_open|imap_ping|imap_qprint|".
		  "imap_rename|imap_renamemailbox|imap_reopen|imap_rfc822_parse_adrlist|imap_rfc822_parse_headers|imap_rfc822_write_address|".
		  "imap_savebody|imap_scan|imap_scanmailbox|imap_search|imap_set_quota|imap_setacl|imap_setflag_full|imap_sort|imap_status|".
		  "imap_subscribe|imap_thread|imap_timeout|imap_uid|imap_undelete|imap_unsubscribe|imap_utf7_decode|imap_utf7_encode|imap_utf8";
		$this->allowed_functions=array_flip(explode("|", strtolower("$array_funcs|$object_funcs|$ctype_funcs|$filter_funcs|".
		  "$control_funcs|$datetime_funcs|$math_funcs|".
		  "$misc_funcs|$net_funcs|$regex_funcs|$string_funcs|$stream_funcs|$var_funcs|$xml_funcs|".
		  "$allowed_functions|$debug_funcs|$loader_funcs|$ob_funcs|$iconv_funcs|$mb_funcs|$pspell_funcs|$imap_funcs|$zlib_funcs")));

		/*
			create lookup table for cast-types
		*/
		$this->language_types = Array(
				"int"     => true,
				"integer" => true,
				"bool"    => true,
				"boolean" => true,
				"float"   => true,
				"double"  => true,
				"string"  => true,
				"binary"  => true,
				"array"   => true,
				"object"  => true
		);
	}

	function push_back_token() {
		while (count($this->tokens)) {
			list($token, $token_value) = each(array_shift($this->tokens));
			$this->scanner->push_back($token_value);
		}
		$this->scanner->push_back($this->token_ahead_value);
		$this->token_ahead = $this->token;
		$this->token_ahead_value = $this->token_value;
		$this->token = null;
		$this->token_value = "";
	}

	function print_current_range() {
		echo "parser: ";
		echo "ahead   ('".$this->token_ahead."', '".$this->token_ahead_value."') ";
		echo "current ('".$this->token."', '".$this->token_value."')\n";
	}

	function next_token() {
		$value="";
		if (count($this->tokens) == 0) {
			$token = $this->scanner->scan($value);
			if (is_array($value)) {
				$this->tokens = $value;
				list($token, $token_value) = each(array_shift($this->tokens));
			} else {
				$token = $token;
				$token_value = $value;
			}
		} else {
			list($token, $token_value) = each(array_shift($this->tokens));
		}
		if ($this->token_ahead) {
			$this->token = $this->token_ahead;
			$this->token_value = $this->token_ahead_value;
		}
		$this->token_ahead = $token;
		$this->token_ahead_value = $token_value;
	}

	function parse_argument_list() {
		$result = array (
			'arguments' => array(),
			'parsed' => ''
		);
		do {
			if ($this->token_ahead == PT_COMMA ) {
				// next statement
				$result['parsed'] .= ', ';
				$this->next_token();
			}
			// parse variable
			if($this->token_ahead == PT_VAR_REFERENCE ) {

				$this->next_token();

				if ($this->token_ahead != PT_IDENT) {
					$this->error = "Expected variable name at line ".$this->scanner->YYLINE;
					$result = false;
				} else {
					$this->next_token();
					$result['parsed'].= '$'.$this->token_value;
					$result['arguments'][] = trim($this->token_value);
				}

			} else {
					$this->error = "Unexpected token ".$this->token_ahead." at line ".$this->scanner->YYLINE;
					$result = false;
			}
		} while (!$this->error && ($this->token_ahead == PT_COMMA));
		return $result;
	}

	function parse_func_call_args() {
		do {
			// T_PAR_OPEN or T_COMMA 
			$this->next_token();
			$result .= $this->token_value;
			if ($this->token_ahead == PT_COMMA) {
				// also accept an empty argument
				continue;
			}
			$result .= $this->parse_statement();

		} while (!$this->error && ($this->token_ahead == PT_COMMA));
		return $result;
	}

	function parse_var_index($var_prefix, $func_prefix, $inDQString = false) {
		$result = "";
		$noise = "";
		if ($this->token_ahead == PT_IDENT) {
			$this->next_token();
			$ident        = $this->token_value;
			$array_index  = $this->parse_array_operator($inDQString);
			if ($this->error) {
				return false;
			}
			if (!$inDQString && $this->token_ahead == PT_PAR_OPEN) {
				if ($array_index) {
					$this->error = "Can't call functions from an array at line: ".$this->scanner->YYLINE;
					return false;
				}
				$call_args = $this->parse_func_call_args();
				if ($this->error) {
					return false;
				}
				if ($this->token_ahead != PT_PAR_CLOSE) {
					$this->error = "Expected ')' at line: ".$this->scanner->YYLINE;
					return false;
				}
				$this->next_token();
				$call_args .= $this->token_value;

				// remove all leading underscores.
				$ident = ltrim($ident, '_');
				$result = $func_prefix.$ident.$call_args;
			} else {
				$result = $var_prefix.$ident.$array_index;
			}
		} else if ($this->token_ahead == PT_CBRACE_OPEN || $this->token_ahead == PT_VAR_REFERENCE) {
			$this->next_token();
			if ($this->token == PT_CBRACE_OPEN) {
				$noise .= substr($this->token_value, 1);
				$index = "(".$this->parse_statement().")";
				if ($this->error) {
					return false;
				}
				if ($this->token_ahead != PT_CBRACE_CLOSE) {
					$this->error = "Expected '}' at line: ".$this->scanner->YYLINE;
					return false;
				}
				$this->next_token();
				$noise .= substr($this->token_value, 1);
			} else {
				if ($this->token_ahead != PT_IDENT) {
					$this->error = "Expected an identifier instead of '".$this->token_ahead_value."' at line: ".$this->scanner->YYLINE;
					return false;
				}
				$this->next_token();
				$index = $this->var_prefix.$this->token_value;
			}
			$array_index = $this->parse_array_operator($inDQString);
			if ($this->error) {
				return false;
			}
			if (!$inDQString && $this->token_ahead == PT_PAR_OPEN) {
				if ($array_index) {
					$this->error = "Can't call functions from an array at line: ".$this->scanner->YYLINE;
					return false;
				}
				$call_args = $this->parse_func_call_args();
				if ($this->error) {
					return false;
				}
				if ($this->token_ahead != PT_PAR_CLOSE) {
					$this->error = "Expected ')' at line: ".$this->scanner->YYLINE;
					return false;
				}
				$this->next_token();
				$call_args .= $this->token_value;

				$result = "{'".$func_prefix."'.ltrim(".$index.", '_')}".$call_args;
			} else if ($this->token_ahead == PT_OBJECT_OPERATOR) {
				$result = "$var_prefix"."{".$index."}".$array_index."$noise";
			} else {
				$result = "$var_prefix"."{'".$index."'}".$array_index."$noise";
			}
		} else {
			$this->error = "Unexpected '".$this->token_ahead_value."' following '".$this->token_value."' at line: ".$this->scanner->YYLINE;
		}
		return $result;
	}


	function parse_array_operator($inDQString = false) {
		$result = "";
		while (!$this->error && ( $this->token_ahead == PT_BRACKET_OPEN ||
					(!$inDQString && $this->token_ahead == PT_CBRACE_OPEN) ) ) {

			$this->next_token();
			if ($this->token == PT_BRACKET_OPEN) {
					$token_close = PT_BRACKET_CLOSE;
					$token_close_value = "]";
			} else {
					$token_close = PT_CBRACE_CLOSE;
					$token_close_value = "}";
			}

			$result .= $this->token_value;

			$stmt = $this->parse_statement();
			if (!$this->error) {
				if (trim($stmt)) {
					// NOTE: $result .= "($stmt)";
					$result .= "($stmt)";
				} else {
					$result .= $stmt;
				}
				//NOTE(ORIGINAL): $result .= $this->parse_statement();
				if ($this->token_ahead != $token_close) {
					$this->error = "Expected '$token_close_value' at line: ".$this->scanner->YYLINE;
				} else {
					$this->next_token();
					$result .= $this->token_value;
				}
			}
		}
		return $result;
	}


	function parse_object_operator($inDQString = false) {
		while (!$this->error && $this->token_ahead == PT_OBJECT_OPERATOR) {
			$this->next_token();
			$result .= $this->token_value.$this->parse_var_index("", "_", $inDQString);
			if ($this->token == PT_PAR_CLOSE) {
				break;
			}
		}
		return $result;
	}


	function parse_variable_reference($inDQString = false) {
		$this->next_token(); // eat $ sign;
		$result = $this->var_prefix.$this->parse_var_index("", "_", $inDQString);
		if ($this->error) {
			return false;
		}
		return $result;
	}

	function parse_catch_statement() {
		$result = "";
		if ($this->token_ahead != PT_PAR_OPEN) {
			$this->error = "Expected '(' to follow 'catch' at line ".$this->scanner->YYLINE;
			return false;
		}
		$result .= $this->token_ahead_value;

		$this->next_token();
		while ($this->token_ahead == PT_IDENT) {
			$result .= $this->token_ahead_value;
			$this->next_token();
		}
		if ($this->token_ahead != PT_VAR_REFERENCE) {
			$this->error = "Expected variable within catch() case at line ".$this->scanner->YYLINE;
			return false;
		}
		$result .= $this->token_ahead_value;
		$this->next_token();

		if ($this->token_ahead != PT_IDENT) {
			$this->error = "Expected variable name within catch() case at line ".$this->scanner->YYLINE;
			return false;
		}
		$varName = $this->token_ahead_value;
		$result .= 'pinp_exception_var';
		$this->next_token();

		$varNameClean = trim($varName);

		if ($this->token_ahead != PT_PAR_CLOSE) {
			$this->error = "Expected ')' to follow 'catch' statement at line ".$this->scanner->YYLINE;
			return false;
		}
		$result .= $this->token_ahead_value;

		$this->next_token();

		if ($this->token_ahead != PT_CBRACE_OPEN) {	
			$this->error = "Expected ')' to follow 'catch' statement at line ".$this->scanner->YYLINE;
			return false;
		}
		$result .= $this->token_ahead_value;
		$result .= $this->var_prefix.$varName.'='.'$pinp_exception_var;';

		$this->next_token();

		$result .= $this->parse_statement_list();
		$result .= $this->token_ahead_value;
		$this->next_token();

		return $result;
	}


	function parse_expression($inDQString = false) {
		$result = "";
		switch ($this->token_ahead) {

			case PT_VAR_REFERENCE:
				$result = $this->parse_variable_reference($inDQString);
				if ($this->error) {
					return false;
				}
				if ($this->token == PT_PAR_CLOSE) {
					$parseReturnValues = true;
				} else if ($this->token_ahead == PT_OBJECT_OPERATOR) {
					$result .= $this->parse_object_operator($inDQString);
				}
				if ($this->token == PT_PAR_CLOSE) {
					$parseReturnValues = true;
				}
			break;

			case PT_IDENT:
				$identSet = false;
				$iname = chop(strtolower($this->token_ahead_value));
				$this->next_token();
				if ($this->token_ahead == PT_CLASS_OPERATOR) {
					$result = "pinp_".$this->token_value."::";
					$this->next_token();
					if ($this->token_ahead != PT_IDENT) {
						$this->error = "Expecting an identifier following ($result) at line ".$this->scanner->YYLINE;
						return false;
					} else {
						$this->next_token();
						$result .= "_".$this->token_value;
					}
					$identSet = true;
				}
				if (!$inDQString && $this->token_ahead == PT_PAR_OPEN) {
					// we don't have to prefix the function identifier if we already have done that.
					if (!$identSet) {
						if (!$this->allowed_functions[strtolower($iname)]) {
								$result = $this->var_prefix.ltrim($this->token_value, '_');
						} else {
								$result = $this->token_value;
						}
					}
					$result .= $this->parse_func_call_args();
					if ($this->error) {
						return false;
					}
					if ($this->token_ahead != PT_PAR_CLOSE) {
						$this->error = "Expected ')' instead of '".$this->token_ahead_value."' at line ".$this->scanner->YYLINE;
						return false;
					}
					$result .= $this->token_ahead_value;
					$this->next_token();

					$identSet = true;
					$parseReturnValues = true;
				}
				if (!$identSet) {
					$result = $this->token_value;
				}
			break;

			case PT_PAR_OPEN:
				$result = $this->token_ahead_value;
				$this->next_token();
				// parse casting, e.g. (int) (float)
				if ($this->token_ahead == PT_IDENT && $this->language_types[strtolower(trim($this->token_ahead_value))]) {
					$this->next_token();
					$result .= $this->token_value;
					if ($this->token_ahead != PT_PAR_CLOSE) {
						$this->error = "Expected ')' for casting to '".$this->token_value."' at line: ".$this->scanner->YYLINE;
					} else {
						$this->next_token();
						$result .= $this->token_value;
					}
				} else {
					$result .= $this->parse_statement();
					if ($this->token_ahead != PT_PAR_CLOSE) {
						$this->error = "Expected ')' at line ".$this->scanner->YYLINE;
					} else {
						$this->next_token();
						$result .= $this->token_value;
						$parseReturnValues = true;
					}
				}
			break;
		}	

		if ($parseReturnValues) {
				$i = 0;
				while (!$this->error &&	
							($this->token_ahead == PT_OBJECT_OPERATOR 
								|| $this->token_ahead == PT_BRACKET_OPEN
								|| ($this->token_ahead == PT_PAR_OPEN && !$inDQString))) {
					while (!$this->error && $this->token_ahead == PT_BRACKET_OPEN) {
						$result = $result.$this->parse_array_operator($inDQString);
						$i++;
					}
					while (!$this->error && $this->token_ahead == PT_OBJECT_OPERATOR) {
						$result = $result.$this->parse_object_operator($inDQString);
						$i++;
					}
					while (!$inDQString && !$this->error && $this->token_ahead == PT_PAR_OPEN) {
						$result = substr($this->function_prefix, 0, -1) . "{'_'.ltrim(($result), '_')}" . $this->parse_func_call_args() . $this->token_ahead_value;
						if ($this->token_ahead != PT_PAR_CLOSE) {
							$this->error = "Expected ')' at line: ".$this->scanner->YYLINE;
							return false;
						}
						$this->next_token();
						$i++;
					}
				}
		}
		return $result;
	}


	function parse_multipart_string() {
		$this->scanner->YYSTATE = YY_STATE_DQ;
		if ($this->token_ahead == PT_HEREDOC) {
			$this->next_token();
			if ($this->token_ahead != PT_IDENT) {
				$this->error = "Expected an identifier, instead of (".$this->scanner->error."), following HereDoc operator at line: ".$this->scanner->YYLINE;
				return false;
			}
			$hereDoc = rtrim($this->token_ahead_value);
			$result = "<<<".$hereDoc."\n";
		} else {
			$result = '"';
		}
		$this->next_token();
		do {
			switch($this->token_ahead) {
				case PT_DQ_STRING:
					if (!$hereDoc) {
						break 2;
					}
					$this->next_token();
					$result .= $this->token_value;
				break;
				case PT_SUBSTRING:
					if ($hereDoc && rtrim($this->token_ahead_value) == "$hereDoc;") {
						break 2;
					}
				case PT_CBRACE_OPEN:
					$this->next_token();
					$result .= $this->token_value;
				break;
				case PT_CBRACE_OPEN_VAR:
					$this->scanner->YYSTATE = YY_STATE_PINP;
					$this->next_token();
						$stmt = $this->parse_statement();
						if ($this->error) {
							break;
						}
						if ($this->token_ahead != PT_CBRACE_CLOSE) {
							$this->error = "Expected '}' instead of '".$this->token_ahead_value."' in double quoted string at line: ".$this->scanner->YYLINE;
							break;
						}
					if (!$hereDoc) {
						$result .= '".('.$stmt.')."';
					} else {
						$result .= '${"hereDocResult".substr($hereDocResult = ('.$stmt.'), 0, 0)}';
					}
					$result .= substr($this->token_ahead_value, 1);
					$this->scanner->YYSTATE = YY_STATE_DQ;
					$this->next_token();
				break;
				case PT_VAR_REFERENCE:
					$this->scanner->YYSTATE = YY_STATE_PINP;
					$this->next_token();
					$varRes = $this->parse_expression(true);
					if ($varRes) {
						if ($this->error) {
							break;
						}
						$varResWithoutNoise = rtrim($varRes);
						if (!$hereDoc) {
							$result .= '".('.$varResWithoutNoise.')."';
						} else {
							$result .= '${"hereDocResult".substr($hereDocResult = ('.$varResWithoutNoise.'), 0, 0)}';
						}
						$result .= substr($varRes, strlen($varResWithoutNoise));
						$this->push_back_token();
					} else {
						$result .= '\$';
					}
					$this->scanner->YYSTATE = YY_STATE_DQ;
					$this->next_token();
				break;
				case PT_VAR_CBRACE_OPEN:
					$this->scanner->YYSTATE = YY_STATE_PINP;
						$this->next_token();
						$stmt = $this->var_prefix."{'".$this->parse_statement()."'}";
						if ($this->token_ahead != PT_CBRACE_CLOSE) {
							$this->error = "Expected '}' instead of '".$this->token_ahead_value."' in double quoted string at line: ".$this->scanner->YYLINE;
							return false;
						}
					if (!$hereDoc) {
						$result .= '".('.$stmt.')."';
					} else {
						$result .= '${"hereDocResult".substr($hereDocResult = ('.$stmt.'), 0, 0)}';
					}
					$result .= substr($this->token_ahead_value, 1);
					$this->scanner->YYSTATE = YY_STATE_DQ;
					$this->next_token();
				break;
				case PT_ERROR:
					$this->error = $this->scanner->error;
				break;
				default:
					$this->error = "Unexpected '".$this->token_ahead_value."' in double quoted string at line: ".$this->scanner->YYLINE;
				break;
			}
		} while (!$this->error);
		$this->scanner->YYSTATE = YY_STATE_PINP;
		$this->next_token();
		$result .= $this->token_value;
		return $result;
	}

	function is_constant() {
		return ($this->token_ahead == PT_DQ_STRING 
					|| $this->token_ahead == PT_STRING || $this->token_ahead == PT_NUMBER
						|| $this->token_ahead == PT_IDENT);
	}

	function parse_constant() {
		$result = "";
		switch ($this->token_ahead) {
			case PT_DQ_STRING:
				$result = $this->parse_multipart_string();
			break;
			case PT_IDENT:
			case PT_NUMBER:
			case PT_STRING:
				$result = $this->token_ahead_value;
				$this->next_token();
			break;
			default:
				$this->error = "Expected a constant at line ".$this->scanner->YYLINE.", but found '".$this->token_ahead_value."'";
			break;
		}
		return $result;
	}

	function parse_statement() {
		$result = '';
		while (!$this->error && $this->token_ahead != PT_EOF) {
			switch ($this->token_ahead) {
				default:
					$expression = $this->parse_expression();
					if (!$expression) {
						break 2;
					} else {
						$result .= $expression;
					}
				break;
				case PT_USE:
				case PT_AS:
					$this->error = "Aliasing/Importing is not supported yet. Error at line: ".$this->scanner->YYLINE;
				break;
				case PT_FUNCTION:
					$result .= $this->token_ahead_value;
					$this->next_token();
					if ($this->token_ahead != PT_PAR_OPEN) {
						$this->error = "Expected '(' instead of '$this->token_ahead_value' at line ".$this->scanner->YYLINE;
						return false;
					} else {
						$result .= $this->token_ahead_value;
						$this->next_token();
						if( $this->token_ahead != PT_PAR_CLOSE ) {
							$arguments = $this->parse_argument_list();
						} else {
							$arguments = array(
								'arguments' => array()
							);
						}
						$result .= $arguments['parsed'];
						if (!$this->error) {
							if ($this->token_ahead != PT_PAR_CLOSE) {
								$this->error = "Expected ')' instead of '$this->token_ahead_value' at line ".$this->scanner->YYLINE;
								return false;
							}

							$result .= $this->token_ahead_value;
							$this->next_token();

							$result .= ' use ('.substr($this->var_prefix,0,-2).') ';

							if ( $this->token_ahead !=  PT_CBRACE_OPEN ) {
								$this->error = "Expected '{' instead of '$this->token_ahead_value' at line ".$this->scanner->YYLINE;
								return false;
							}

							$result .= $this->token_ahead_value;
							$this->next_token();

							$functionPreable = ' '.substr($this->var_prefix,0,-2).' = new ar_core_pinpSandbox('.$this->var_prefix.'this);';
							foreach($arguments['arguments'] as $arg ) {
								$functionPreable .= ' '.$this->var_prefix."{'".$arg ."'}" .' = $' . "{'".$arg."'}; ";
							}
							$result .= $functionPreable;

							// statement list
							$result .= $this->parse_statement_list();

							if ($this->token_ahead !=  PT_CBRACE_CLOSE ) {
								$this->error = "Expected '{' instead of '$this->token_ahead_value' at line ".$this->scanner->YYLINE;
								return false;
							}
							$result .= $this->token_ahead_value;
							$this->next_token();
						}
					}
					return $result;
				break;
				case PT_NAMESPACE:
				case PT_NAMESPACE_SEPERATOR:
					$this->error = "Namespaces are not supported yet. Error at line: ".$this->scanner->YYLINE;
				break;
				case PT_CATCH:
					$result .= $this->token_ahead_value;
					$this->next_token();
					$result .= $this->parse_catch_statement();
				break;
				case PT_STRING:
					$result .= $this->token_ahead_value;
					$this->next_token();
				break;
				case PT_ARRAY_OP:
					$result .= $this->token_ahead_value;
					$this->next_token();
				break;
				case PT_HEREDOC:
				case PT_DQ_STRING:
					$result .= $this->parse_multipart_string();
				break;
				case PT_OBJECT_OPERATOR:
					$result .= "->";
					$this->next_token();
				break;
				case PT_THROW:
				case PT_TRY:

				case PT_NUMBER:
				case PT_ASSIGN_OP:
				case PT_UNPARSED:
					$result .= $this->token_ahead_value;
					$this->next_token();
				break;
				case PT_END_STMT:
					$result .= $this->token_ahead_value;
					$this->next_token();
					return $result;
				break;
				case PT_FOR_STMT:
					$result .= $this->token_ahead_value;
					$this->next_token();
					if ($this->token_ahead != PT_PAR_OPEN) {
						$this->error = "Expected '(' instead of '$this->token_ahead_value' at line ".$this->scanner->YYLINE;
						return false;
					} else {
						$result .= $this->token_ahead_value;
						$this->next_token();
						$result .= $this->parse_statement_list();
						if (!$this->error) {
							if ($this->token_ahead != PT_PAR_CLOSE) {
								$this->error = "Expected ')' instead of '$this->token_ahead_value' at line ".$this->scanner->YYLINE;
								return false;
							} else {
								$result .= $this->token_ahead_value;
								$this->next_token();
								return $result;
							}
						}
					}
				break;
				case PT_COMMA:
				case PT_PAR_CLOSE:
					return $result;
				break;
			}
		}
		return $result;
	}

	function parse_statement_list() {
		$result = "";
		while (!$this->error && $this->token_ahead != PT_EOF) {
			switch ($this->token_ahead) {
				case PT_PAR_CLOSE:
				case PT_CBRACE_CLOSE:
					return $result;
				break;
				case PT_CBRACE_OPEN:
					$result .= $this->token_ahead_value;
					$this->next_token();
					$result .= $this->parse_statement_list();
					$result .= $this->token_ahead_value;
					$this->next_token();
				break;
				case PT_PINP_START:
					$result .= $this->token_ahead_value."<?"."php ";
					$this->in_pinp = true;
					$this->next_token();
				break;
				case PT_PINP_END:
					$result .= " ?".">";
					$this->in_pinp = false;
					$this->next_token();
				break;
				case PT_EXT_COMPILE_START:
					$result .= $this->token_ahead_value;
					$this->in_ext_compile = true;
					$this->next_token();
				break;
				case PT_EXT_COMPILE_END:
					$result .= $this->token_ahead_value;
					$this->in_ext_compile = false;
					$this->next_token();
				break;

				case PT_RETURN:
					$ret_result = $this->token_ahead_value;
					$this->next_token();
					$ret_result .= $this->parse_statement();
					$result .= "{ $ret_result }";
					//NOTE(ORIGINAL): $result .= $ret_result;
				break;
				case PT_ERROR:
					$this->error = $this->scanner->error." at line ".$this->scanner->YYLINE;
				break;
				default:
					$statement = $this->parse_statement();
					if (!$statement && !$this->error) {
						$this->error = "Unexpected '".chop($this->token_ahead_value)."' at line ".$this->scanner->YYLINE;
					} else {
						$result .= $statement;
					}
				break;
			}
		}
		return $result;
	}

	function compileFuncCallArgs($template) {
		$this->scanner = new scanner();
		$this->scanner->init($template, "pinp");
		$this->tokens = Array();
		$this->new_template = "";
		$this->in_pinp = true;
		$this->new_template = $this->parse_func_call_args();
		if (!$this->error) {
			$this->syntax_test("<"."?php function test(".$this->new_template.") { } ?".">");
		}
		return $this->new_template;
	}

	function compile($template) {
		$this->scanner = new scanner();
		$this->scanner->init($template);
		$this->tokens = Array();
		$this->new_template = "";
		$this->in_pinp = false;
		$this->next_token();
		$this->new_template = $this->parse_statement_list();
		if (!$this->error && $this->in_pinp) {
			if ($this->token_ahead == PT_EOF) {
				$this->error = "No closing PINP tag found at line ".$this->scanner->YYLINE;
			} else {
				$this->error = "Unexpected '".$this->token_ahead_value."' at line ".$this->scanner->YYLINE; //no closing pinp tag found";
			}
		}
		if (!$this->error && $this->in_ext_compile) {
			if ($this->token_ahead == PT_EOF) {
				$this->error = "No closing COMPILE tag found at line ".$this->scanner->YYLINE;
			} else {
				$this->error = "Unexpected '".$this->token_ahead_value."' at line ".$this->scanner->YYLINE; //no closing pinp tag found";
			}
		}

		if (!$this->error) {
			$this->syntax_test();
		}
		return $this->new_template;
	}

	function syntax_test($template = "") {
		if (!$template) {
			$template = $this->new_template;
		}

		$this->error = null;
		$parser = (new PhpParser\ParserFactory)->create(PhpParser\ParserFactory::ONLY_PHP5);
		try {
			$parser->parse($template);
		} catch(PhpParser\Error $e) {
			$this->error = $e->getMessage();
		}
	}

}
