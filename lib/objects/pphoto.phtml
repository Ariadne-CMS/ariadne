<?php
    /******************************************************************
     pphoto.phtml                                          Muze Ariadne
     ------------------------------------------------------------------
     Author: Muze (info@muze.nl)
     Date: 31 october 2002

     Copyright 2002 Muze

     This file is part of Ariadne.

     Ariadne is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published 
     by the Free Software Foundation; either version 2 of the License, 
     or (at your option) any later version.
 
     Ariadne is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with Ariadne; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  
     02111-1307  USA

    -------------------------------------------------------------------

     Class inheritance: 	pobject > pfile > pphoto
     Description:

       This is the class definition file of the pphoto class.

    ******************************************************************/

debug("pphoto: Load","object");
include_once($this->code."objects/pfile.phtml");

class pphoto extends pfile { // pphoto class definition

	function setFontStyle($name, $font, $pointsize, $color, $gravity="northwest", $rotate=0) {
		$this->arFontStyles[$name]["font"]=$font;
		$this->arFontStyles[$name]["pointsize"]=$pointsize;
		$this->arFontStyles[$name]["color"]=$color;
		$this->arFontStyles[$name]["gravity"]=$gravity;
		$this->arFontStyles[$name]["rotate"]=$rotate;
	}

	function getThumbSettings() {
		global $ARConfig;
		return $ARConfig->cache[$this->path]->thumb;
	}

	function convert($format="jpg", $quality=75) {
		global $ARConfig;

		$this->set_context("mogrify");

		$result=false;
		if (eregi('[^a-z0-9+]',$format)) {
			$this->error=sprintf($ARnls["err:convillegalformat"],$format);
		} else {
			$ARConfig->photoStack[$this->id][]=" -format $format";
			$this->targetformat=$format;
			$quality=(int)$quality;
			$ARConfig->photoStack[$this->id][]=" -quality $quality";
			$result=true;
		}
		return $result;		
	}

	function getExif( $sections = false, $arrays = true, $thumbnail = false) {
		if (function_exists('exif_read_data')) {
			$tmpsrc = tempnam($this->store->get_config("files")."temp/", "photo");
			$f_store=$this->store->get_filestore("files");
			$f_store->copy_from_store($tmpsrc, $this->id, "file");
			$result=@exif_read_data($tmpsrc,$sections,$arrays,$thumbnail);
			@unlink($tmpsrc);
			$f_store->close();
		} else {
			$result['ERROR']='EXIF not supported by PHP';
		}
		return $result;
	}

	function identify( ) {
		global $AR;
		$tmpsrc = tempnam( $this->store->get_config("files")."temp/", "photo");
		$f_store = $this->store->get_filestore("files");
		$f_store->copy_from_store($tmpsrc, $this->id, "file");
		$execstring = $AR->IM->identify." ".$tmpsrc; 
		$myarray = Array();
		$result = exec( $execstring, &$myarray );
		@unlink( $tmpsrc );
		$f_store->close();
		return $myarray;
	}
	
	function scale($x, $y, $fillcolor=false) {
		global $ARConfig;

		$this->set_context("mogrify");

		$x=(int)$x;
		$y=(int)$y;
		$ARConfig->photoStack[$this->id][]=" -geometry ".$x."x".$y;

		$info=$this->getimageinfo();
		$aspectx=$x/$info[0];
		$aspecty=$y/$info[1];
		if ($aspectx>$aspecty) {
			$aspect=$aspecty;
		} else {
			$aspect=$aspectx;
		}
		$newx=$aspect*$info[0];
		$newy=$aspect*$info[1];

		return Array("x" => $newx, "y" => $newy);
	}

	function rotate($degrees) {
		global $ARConfig;

		$this->set_context("mogrify");
		$degrees=(int)$degrees;

		$ARConfig->photoStack[$this->id][]=" -rotate ".$degrees;

		return true;
	}

	function border($width, $height, $color=false) {
		global $ARConfig;

		$this->set_context("mogrify");

		$width=(int)$width;
		$height=(int)$height;
		$ARConfig->photoStack[$this->id][]=" -border $width"."x".$height." ";
		if ($color!==false) {
			$ARConfig->photoStack[$this->id][]=" -bordercolor $color ";
		}
		return true;
	}

	function cut($x, $y) {
		global $ARConfig;

		$this->set_context("mogrify");

		$ARConfig->photoStack[$this->id][]=" -chop ".((int)$x)."x".((int)$y);
		return true;
	}

	function crop($width, $height, $x=0, $y=0) {
		global $ARConfig;

		$this->set_context("mogrify");

		$ARConfig->photoStack[$this->id][]=" -crop ".((int)$width)."x".((int)$height)."+".((int)$x)."+".((int)$y);
		return true;
	} 

	function scaledown($x, $y, $fillcolor=false) {
		global $ARConfig;

		$this->set_context("mogrify");

		$x=(int)$x;
		$y=(int)$y;
		$ARConfig->photoStack[$this->id][]=" -geometry '".$x."x".$y.">'";

		$info=$this->getimageinfo();
		$aspectx=$x/$info[0];
		$aspecty=$y/$info[1];
		if ($aspectx>$aspecty) {
			$aspect=$aspecty;
		} else {
			$aspect=$aspectx;
		}
		$newx=$aspect*$info[0];
		$newy=$aspect*$info[1];

		return Array("x" => $newx, "y" => $newy);
	}

	function setComposeStyle($name, $method, $width, $height, $xoffset, $yoffset, $percentage, $resize) {
		$this->arComposeStyles[$name]["method"]=$method;
		$this->arComposeStyles[$name]["width"]=$width;
		$this->arComposeStyles[$name]["height"]=$height;
		$this->arComposeStyles[$name]["xoffset"]=$xoffset;
		$this->arComposeStyles[$name]["yoffset"]=$yoffset;
		$this->arComposeStyles[$name]["percentage"]=$percentage;
		$this->arComposeStyles[$name]["resize"]=$resize;
	} 

	function compose( $target, $style="default", $blend = 0, $params=false) {
		global $ARConfig;

		$this->set_context("composite");

		$compose = "";

		$def = $this->arComposeStyles[$style];
		if (is_array($params)) {
			if (is_array($def)) {
				$def = array_merge($def, $params);
			} else {
				$def = $params;
			}
		}

		if( is_array($def) ) {
			$method = $def["method"];
			$width = $def["width"];
			$height = $def["height"];
			$xoffset = $def["xoffset"];
			$yoffset = $def["yoffset"];
			$percentage = $def["percentage"];
			$resize = $def["resize"];
			$gravity = $def["gravity"];
		}

		$geo = false;

		if( isset( $width ) && isset( $height ) ) {
			$width=(int)abs($width);
			$height=(int)abs($height);
			$compose .= " -geometry \"".$width."x".$height;
			$geo = true;

		}
		if( isset( $xoffset ) && isset( $yoffset ) ) {
			if( !$geo ) {
				$compose .= " -geometry \"";
				$geo = true;
			}
			$xoffset=(int)$xoffset;
			$yoffset=(int)$yoffset;
			if( $xoffset < 0 ) {
				$compose .= $xoffset;
			} else {
				$compose .= "+".$xoffset;
			}
			if( $yoffset < 0 ) {
				$compose .= $yoffset;
			} else {
				$compose .= "+".$yoffset;
			}
		}

		if( $percentage ) {
			$compose .= "%";
		}
		if( $resize == ">" || $resize == "<" ) {
			$compose .= $resize;
		}
		
		if( $geo ) {
			$compose .= "\"";
		}

		if ($method && eregi('[^a-z0-9+]',$method)) {
			$this->error=sprintf($ARnls["err:composeillegalmethod"],$method);
		} else {
			$targetobj = current($this->get($target, "system.get.phtml"));
			if( $targetobj->type == "pphoto" ) {
				if ($method) {
					$compose .= " -compose ".$method;
				}
				if ($gravity) {
					$compose .= " -gravity $gravity ";
				}
				if( $blend ) {
					$compose .= " -blend ".$blend;
				}
			
				$targetid = $targetobj->id;
				if( $targetid ) {
					$tmpsrc = tempnam($this->store->get_config("files")."temp/", "photo");
					if(  substr( strtolower($tmpsrc), -4, 4 ) == ".tmp" ) {
						@unlink($tmpsrc);
						$tmpsrc = substr($tmpsrc, 0, -4 );
					}
					$tmpsrc .= ".photo";

					$ARConfig->photoTempFiles[$this->id][] = $tmpsrc;
					$ARConfig->photoTempFilesID[$this->id][] = $this->id;

					$tmpmysrc = tempnam($this->store->get_config("files")."temp/", "photo");
					if(  substr( strtolower($tmpmysrc), -4, 4 ) == ".tmp" ) {
						@unlink($tmpmysrc);
						$tmpmysrc = substr($tmpmysrc, 0, -4 );
					}
					$tmpmysrc .= ".photo";

					$ARConfig->photoTempFiles[$this->id][] = $tmpmysrc;
					$ARConfig->photoTempFilesID[$this->id][] = $targetid;

					$execbuf = $compose." ".$tmpmysrc." {buildfile} ";
					$ARConfig->photoStack[$this->id][] = $execbuf;
					//echo "<script> alert('compose ($execbuf)'); </script>\n";
					$this->set_context("build");
				}
			}
		}


		return true;
	}


	function annotate($text, $x, $y, $style="default") {
		global $ARConfig;

		// FIXME: There should be an option in the FontStyle that
		// defines the target character encoding.

		require_once($this->store->get_config("code")."modules/mod_unicode.php");
		$text=unicode::utf8toiso8859($text);
		$this->set_context("mogrify");

		$x=(int)$x;
		$y=(int)$y;

		// Get defaults
		$font = "";
		$pointsize = 12;
		$color = "black";

		if(($style!="") && ($def=$this->arFontStyles[$style])) {
			$font = $def["font"];
			$pointsize = $def["pointsize"];
			$color = $def["color"];
			$gravity = $def["gravity"];
			$rotate = $def["rotate"];
		}
		if($font!="") {
			$font_store=$this->store->get_filestore("files");
			if($fontid=$this->exists($font)) {
				$chkfontgrants = current($this->get($font, "system.get.phtml"));
				if($chkfontgrants->CheckLogin("read")) {
					$tmpfont=$this->store->get_config("files")."temp/".$fontid.".ttf";
					$font_store->copy_from_store($tmpfont, $fontid, "file");
					$ARConfig->photoStack[$this->id][]= " -font ".$tmpfont;
					$this->arClearList[]=$fontid.".ttf";
				}
			}
			$font_store->close();
		}
		$rotcmd = "";
		if($gravity!="") {
		  $gravcmd = "-gravity $gravity ";
		}
		if($rotate!=0) {
		  $rotcmd = "-rotate $rotate";
		}
		$ARConfig->photoStack[$this->id][]=" -pointsize $pointsize -fill $color $gravcmd $rotcmd -draw \"text $x,$y '".addcslashes($text,ARESCAPE)."'\"";
		return true;
	}


	function set_context($context) {
		global $AR, $ARConfig;
		$unknown = false;

		if( !$ARConfig->photoContext[$this->id] ) {
			$ARConfig->photoContext[$this->id] = $context;
		}		

		if( $ARConfig->photoContext[$this->id] != $context ) {
			if( $ARConfig->photoContext[$this->id] == "mogrify" ) {
				$contextexecutable = $AR->IM->mogrify;
			} elseif( $ARConfig->photoContext[$this->id] == "composite" ) {
				$contextexecutable = $AR->IM->composite;
			} else {
				$unknown = true; // This should NOT happen
			}
			if( !$unknown && is_array($ARConfig->photoStack[$this->id])) {
				$image="";
				foreach($ARConfig->photoStack[$this->id] as $value){
					$image.=$value;
				}
				$ARConfig->photoCommandStack[$this->id][] = $contextexecutable.$image;
				unset($ARConfig->photoStack[$this->id]);
				if( $context == "build" ) {
					unset($ARConfig->photoContext[$this->id]);
				} else {
					$ARConfig->photoContext[$this->id] = $context;
				}
			}
		}
		return;
	}


	function build() {
		global $AR, $ARConfig, $ARCurrent;
		if (!$ARCurrent->arDontCache && $ARCurrent->cachetime!=-1 && $this->CheckPublic('read')) {
			if ($ARCurrent->cachetime==0 && !$AR->output_compression) {
				ob_start();	// start the cache
			}
			$ARCurrent->cachetime=-2; // set cache to onchange
		}
		$this->set_context("build");
 
		$result=false;
		$failed=false;
		if (!$this->error) {
			$tmpsrc = tempnam($this->store->get_config("files")."temp", "photo");
                        if(  substr( strtolower($tmpsrc), -4, 4 ) == ".tmp" ) {
                          @unlink($tmpsrc);
                          $tmpsrc = substr($tmpsrc, 0, -4 );
                        }
			$tmpsrc .= ".photo";
			$f_store=$this->store->get_filestore("files");
			$f_store->copy_from_store($tmpsrc, $this->id, "file");

			if( is_array($ARConfig->photoTempFiles[$this->id]) && is_array($ARConfig->photoTempFilesID[$this->id])) {
				reset($ARConfig->photoTempFiles[$this->id]);
				foreach( $ARConfig->photoTempFiles[$this->id] as $key => $tempfile){
					$f_store->copy_from_store($tempfile, $ARConfig->photoTempFilesID[$this->id][$key], "file");
				}
			}

			$f_store->close();

			if (chdir($this->store->get_config("files").'temp/')) {
				if (is_array($ARConfig->photoCommandStack[$this->id])) {
					$image="";
					foreach( $ARConfig->photoCommandStack[$this->id] as $exec_string){
						$exec_string = str_replace('{buildfile}', $tmpsrc, $exec_string);
						$exec_string .= " ".$tmpsrc;
						system($exec_string,$failed);
						if($failed){
							break;
						}
						debug("executing ($exec_string)");
						// echo( $exec_string."<br>");
					}
				}
				if (!$failed) {
					ob_start();
					if( substr( strtolower($tmpsrc), -6, 6 ) == ".photo" ) {
						$tmpsrc = substr( $tmpsrc, 0, -6 );
					}
					if ($this->targetformat && !eregi("[^0-9a-z\._-]",$this->targetformat)) {
						$destsrc=$tmpsrc.".".$this->targetformat;
					} else {
						$destsrc=$tmpsrc;
					}
					readfile($destsrc);
					$result=ob_get_contents();
					ob_end_clean();
					@unlink($tmpsrc);
					@unlink($destsrc);
				} else {
					$this->error=sprintf($ARnls["err:noimagemagick"],$exec_string);
				}
			} else {
				$this->error=sprintf($ARnls["err:changetempdirfailed"],$this->store->get_config("files"));
			}
		}
		if( is_array($ARConfig->photoTempFiles[$this->id])) {
			foreach($ARConfig->photoTempFiles[$this->id] as $tempfile){
				@unlink($tempfile);
			}
		}
		unset( $ARConfig->photoTempFiles[$this->id] );
		unset( $ARConfig->photoTempFilesID[$this->id] );
		unset( $ARConfig->photoCommandStack[$this->id] );
		if ($this->error) {
			echo $this->error;
		}
		return $result;
	}

	function cleanup() {
	global $ARConfig;
		if (is_array($this->arClearList)) {
			foreach ( $this->arClearList as $value) {
				if (!eregi("[^a-z0-9\._-]",$value)) {
					@unlink($value);
				}
			}
		}
		unset($ARConfig->photoStack[$this->id]);
	}

	function getimageinfo($extrainfo=false) {
		$tmpsrc = tempnam($this->store->get_config("files")."temp/", "photo");
		$f_store=$this->store->get_filestore("files");
		$f_store->copy_from_store($tmpsrc, $this->id, "file");
		if ($extrainfo!==false) {
			$result=getimagesize($tmpsrc, &$extrainfo);
		} else {
			$result=getimagesize($tmpsrc);
		}
		@unlink($tmpsrc);
		$f_store->close();
		return $result;
	}

	function _convert($format="", $quality=75) {
		return $this->convert($format, $quality);
	}

	function _scale($x, $y, $fillcolor=false) {
		return $this->scale($x, $y, $fillcolor);
	}

	function _rotate($degrees) {
		return $this->rotate($degrees);
	}

	function _scaledown($x, $y, $fillcolor=false) {
		return $this->scaledown($x, $y, $fillcolor);
	}

	function _getThumbSettings() {
		return $this->getThumbSettings();
	}

	function _setFontStyle($name, $font, $pointsize, $color, $gravity="northwest", $rotate=0) {
		return $this->setFontStyle($name, $font, $pointsize, $color, $gravity, $rotate);
	}

	function _annotate($text, $x, $y, $style="default") {
		return $this->annotate($text, $x, $y, $style);
	}

	function _setComposeStyle($name, $method, $width, $height, $xoffset, $yoffset, $percentage, $resize) {
		return $this->setComposeStyle($name, $method, $width, $height, $xoffset, $yoffset, $percentage, $resize);
	}

	function _compose( $target, $style="default", $blend = 0, $params = false ) {
		return $this->compose( $target, $style, $blend, $params );
	}

	function _border($width, $height, $color=false) { 
		return $this->border($width, $height, $color);
	}

	function _cut($x, $y) {
		return $this->cut($x, $y);
	}
	
	function _crop($width, $height, $x=0, $y=0) {
		return $this->crop($width, $height, $x, $y);
	}

	function _build() {
		return $this->build();
	}

	function _cleanup() {
		return $this->cleanup();
	}

	function _getimageinfo($extrainfo=false) {
		if ($extrainfo!==false) {
			return $this->getimageinfo(&$extrainfo);
		} else {
			return $this->getimageinfo();
		}
	}
	
	function _identify( ) {
		return $this->identify();
	}
	
	function _getExif( $sections = false, $arrays = true, $thumbnail = true) {
		return $this->getExif( $sections, $arrays, $thumbnail);
	}
	
} // end of pphoto class definition
?>