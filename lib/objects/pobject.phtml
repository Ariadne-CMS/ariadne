<?php

debug("pobject: Load","object");

class pobject extends object { 

	var $store;	
	var $path;
	var $data;  

	function init(&$store, &$path, &$data) {
		debug("pobject: init([store], $path, [data])","object");
		$this->store=&$store;
		$this->path=&$path;
		$this->data=&$data;
	}

	function call($arCallFunction="view.html", $arCallArgs="") {
	/***********************************************************************
	  {function description}
	  variables available to templates:
	  local: arCallFunction, arCallArgs, arCallTemplte, data
	  global: AR, ARConfig, ARCurrent, ARBeenHere
	***********************************************************************/
	global $AR, $ARConfig, $ARCurrent, $ARBeenHere, $ARnls;

		debug("pobject: call($arCallFunction, $arCallArgs)","object");
		// callstack is needed for getvar()
		$ARCurrent->arCallStack[]=$arCallArgs;
		Parse_str($arCallArgs);
		// now find the initial nls selection (CheckConfig is needed for per
		// tree selected defaults)
		if ($ARCurrent->nls) { 
			$this->reqnls=$ARCurrent->nls; 
		} else { 
			$this->reqnls=$AR->nls->default; 
		}
		if (isset($this->data->{$this->reqnls}) || !isset($this->data->nls)) {  
			// the requested language is available
			$this->nls=$this->reqnls;
			$nls=&$this->nls;
		} else {
			// the requested language is not available, use default of the
			// current object instead.
			$this->nls=$this->data->nls->default;
			$nls=&$this->nls;
			$flag=" <img src=\"".$AR->dir->images."nls/small/$nls.gif\" alt=\"\" border=\"0\"> ";
		}
		if ($this->data->$nls) {
			// now set the data and nlsdata pointers
			$this->nlsdata=$this->data->$nls;
			$nlsdata=&$this->nlsdata;
			$data=&$this->data;
		} else {
			// this object doesn't support nls data
			$this->nlsdata=$this->data;
			$nlsdata=&$this->data;
			$data=&$this->data;
		} 
		debug("pobject: call: nls set to $nls","all"); 
		
		if (strpos($arCallFunction,"::")!==false) {
			list($arType, $arCallFunction)=explode("::",$arCallFunction);
		} else {
			$arType=$this->type;
		}
		while ($arType!="object") {
			$arCallTemplate=$this->store->code."templates/".$arType."/".$arCallFunction;
			if (file_exists($arCallTemplate)) {
				include($arCallTemplate);
				break;
			} else if (file_exists($this->store->code."templates/".$arType."/default.phtml")) {
				include($this->store->code."templates/".$arType."/default.phtml");
				break;
			} else {
				$arTemp=new $arType();
				$arType=get_parent_class($arTemp);
			}
		}
		array_pop($ARCurrent->arCallStack);
		debug("pobject: call: end","all");
		if ($ARCurrent->arResult) {
			$arResult=$ARCurrent->arResult;
			$ARCurrent->arResult=false;
		}
		if (isset($arResult)) {
			// only do a return if we really have something to return
			return $arResult;
		}
	}

	function ls($path="", $function="list.html", $args="") {
		debug("pobject: ls($path, $function, $args)","object");
		$path=$this->store->make_path($this->path, $path);
		return $this->store->call($function, $args, $this->store->ls($path));
	}

	function get($path, $function="view.html", $args="") {
		debug("pobject: get($path, $function, $args)","object");
		$path=$this->store->make_path($this->path, $path);
		return $this->store->call($function, $args, $this->store->get($path));
	}

	function parents($path, $function="list.html", $args="") {
		debug("pobject: parents($path, $function, $args)","object");
		$path=$this->store->make_path($this->path, $path);
		return $this->store->call($function, $args, $this->store->parents($path));
	}

	function find($path, $criteria, $function="list.html", $args="", $limit=100, $offset=0) {
		debug("pobject: find($path, [crit], $function, $args)","object");
		$path=$this->store->make_path($this->path, $path);
		return $this->store->call($function, $args, $this->store->find($path, $criteria, $limit, $offset));
	}


	function save($properties="", $vtype="") {
	/***********************************************************************
	  save the current object.
	  if this is a new object ($this->arIsNewObject) the path is checked and
	  the object is saved under the new path.
	***********************************************************************/
	global $AR;
		debug("pobject: save([properties], $vtype)","object");
		$result=false;
		if ($this->arIsNewObject) { // save a new object
			$arNewParent=$this->make_path("..");
			$arNewFilename=substr($this->path, strlen($arNewParent), -1);
			if (!eregi("\.\.",$arNewFilename)) {
				if (eregi("^[a-z0-9_\{\}\.\:-]+$",$arNewFilename)) { // no "/" allowed, these will void the 'add' grant check.
					if (!$this->exists($arNewFilename)) {
						$this->path=$this->store->save($this->path, $this->type, $this->data, $properties, $vtype);
						$result=$this->path;
					} else {
						$this->error="$arNewFilename already exists.";
					}
				} else {
					$this->error="$arNewFilename is no valid filename, use only a-z, A-Z, 0-9 and _ or -.";					
				}
			} else {
				$this->error="$arNewFilename is no valid filename, do not use '..' in filenames.";
			}
		} else { // update an existing object
			if (!($result=$this->lock(0,"O")) || ($result["locks"][$this->path]["identity"]==$AR->user->data->login)) {
				if ($this->exists($this->path)) { // prevent 'funny stuff'
					$this->path=$this->save($this->path, $this->type, $this->data, $properties, $vtype);
					$result=$this->path;
					$this->ClearCache();
					$this->unlock();
				} else {
					$this->error="Path is corrupt, won't save the object.";
				}
			} else {
				$this->error="Object already locked.";
			}
		}
		debug("pobject: save: end","all");
		return $result;
	}

	function link($from, $to) {
		debug("pobject: link($from, $to)","object");
		return $this->store->link($this->make_path($from), $this->make_path($to));
	}

	function delete($path) {
		debug("pobject: delete($path)","object");
		return $this->store->delete($path);
	}

	function purge($path) {
		debug("pobject: purge($path)","object");
		return $this->store->purge($path);
	}

	function exists($path) {
		debug("pobject: exists($path)","object");
		$path=$this->make_path($path);
		return $this->store->exists($path);
	}

	function make_path($path="") {
		debug("pobject: make_path($path)","object");
		return $this->store->make_path($this->path, $path);
	}

	function make_url($path="") {
		/* FIXME:
		   make_url should first try to make relative links, instead
		   of full absolute urls
		   if the path corresponds with the same root as the current object
		   that should be possible, just find the common root, and add ".."
		   to it for each directory of the current object from that root, 
		   then add the rest of the path of the image.
		*/
		global $ARConfig;
		debug("pobject: make_url($path)","object");
		$object_path=$this->path;
		$path=$this->make_path($path);
		while ($object_path && !$url) {
			$config=$ARConfig->cache[$object_path];
			$rootpath=$config->root["path"];
			if (substr($path, 0, strlen($rootpath))==$rootpath) {
				debug("make_url: root from '$rootpath' = ".$config->root["value"].$this->store->rootoptions,"all");
				$path=substr($path, strlen($rootpath)-1);
				$url=$config->root["value"].$this->store->rootoptions.$path;
			} else {
				// jump to cache information of the parent of $rootpath
				$object_path=substr($rootpath, 0, strrpos("/", substr($rootpath, 0, -1)));
			}
		}
		return $url;			
	}

	function implements($implements) {
		debug("pobject: implements($implements)","object");
		return $this->store->implements($this->type, $implements); 
	}

	function getlocks() {
		debug("pobject: getlocks()","object");
		return $this->store->mod_lock->getlocks($AR->user->data->login);
	}

	function lock($time=0,$mode="O") {
	global $AR;

		debug("pobject: lock($time, $mode)","object");
		return $this->store->mod_lock->lock($AR->user->data->login,$this->path,$time,$mode);
	}

	function unlock() {
	global $AR;

		debug("pobject: unlock()","object");
		return $this->store->mod_lock->unlock($AR->user->data->login,$this->path);
	}


	function load_properties() {
		debug("pobject: load_properties()","object");
		return $this->store->load_properties($this->id);
	}

	function load_property($property) {
		debug("pobject: load_property($property)","object");
		return $this->store->load_property($this->id,$property);
	}

	function GetValidGrants() {
	/********************************************************************

	  This function finds all grants in effect on this object for the
	  logged in user! $AR->user must already be set.
	
	  Grants are checked in the following way:
	  1) First all parents of this object are checked for grants for this
	     specific user. The 'nearest' grants are valid, and the path of
	     parent that set these grants will be the upper limit for the 
	     checking of group grants.
	  2) Now all groups of which the user is a member are checked for
	     grants. Likewise, all parents are checked for group grants, upto 
	     but not including the upperlimit as set in 1. All group grants 
	     found are merged into one grants list. 
	  3) If there are gropup grants, this means that there are group 
	     grants set in a parent nearer to this object than the user grants
	     and therefor only the groupgrants must be returned.
	
	  this results in:
	  1	/		user: read edit		group: none
	  2	/dir/					group: read
	  3	/dir2/		user: none		group: read
	  4	/dir/dir3/				group2: edit
	  case 1: the user takes precedence over the group, grants are 'read edit'
	  case 2: group takes precedence over the user, as its grants are set 
	          in a 'nearer' parent (itself). grants are 'read'.
	  case 3: user takes precedence again. grants are 'none'.
	  case 4: groups take precedence, but all group grants are merged!
	          therefor the grants are 'read edit'.
	********************************************************************/

	global $AR;

		debug("pobject: GetValidGrants()","object");
		if ($AR->user) { 	// login and retrieval of user object 
			// must be handled first.
 			// first create a list of all parent paths, to be used later.
			$subpaths=explode("/", $this->path);
			$path='/';
			$paths[]=''; 	// stop value : prev will not fail, but $path==false
			$paths[]='/';
			while (next($subpaths)) { // last subpath is empty -> next() == false
				$path.=current($subpaths)."/";
				$paths[]=$path;
			}

			// now check the parent paths for grants, starting at the last
			// untill user grants are found.
			$path=end($paths);
			while (!($AR->user->GetGrants($path,$grants)) && $path) {
				$path=prev($paths);
			}
			if ($grants) { // if grants are found, set the upperlimit
				$userpath=$path;
			}
			debug("pobject: GetValidGrants: user grants defined at $userpath","all");

			// if not already done, find all groups of which the user is a member
			$criteria["members"]["login"]["="]="'".AddSlashes($AR->user->data->login)."'";
			if ($AR->user->groups || ($AR->user->groups=$this->find("/system/groups/",$criteria, "system.get.phtml"))) {
				reset($AR->user->groups);
				while (list($key, $group)=each($AR->user->groups)) { 
					// for each group ...
					$path=end($paths);
					while ($path && $path!=$userpath && !$found) { 
						// find and merge first grants set upto, not including, the upperlimit
						if ($group->GetGrants($path, $grants)) {
							debug("pobject: GetValidGrants: group grants for ".$group->data->name." defined at $path","all");
							$found=true;
						}
						$path=prev($paths);
					}
					$found=false;
				}
			}
		}
		debug("pobject: GetValidGrants: end ( ".serialize($grants)." )","all");
		return $grants;
	}

	function CheckLogin($grant) {
	global $AR,$ARnls,$ARCurrent,$ARLogin,$ARPassword,$ARCookie,$session_config;

		debug("pobject: CheckLogin($grant)","object");
		// check for a sessionid
		$silent=($AR->user) ? 1:0;
		$continue=true;
		if (!$AR->user) {
			if (!$ARCurrent->session || !$ARCurrent->session->get("ARLogin")) {
				$ARLogin="public"; $ARPassword="none";
				debug("pobject: CheckLogin: use public","object");
			} else {
				// go check for cookie
				if ($ARCookie!=($md=$ARCurrent->session->get("ARLogin")."{".md5(
					$ARCurrent->session->get("ARPassword").
					$ARCurrent->session->id))."}") {

					debug("pobject: CheckLogin: error in cookie auth ($md -> $ARCookie)","object");
					if (!$silent) {
						$arLoginMessage=$ARnls["accessdenied"].": ".$ARnls["q:cookiesenabled"];
						$this->call("user.login.html","arLoginMessage=".urlencode($ARLoginMessage));
					}
					$continue=false;
				} else {
					$ARLogin=$ARCurrent->session->get("ARLogin");
					$ARPassword=$ARCurrent->session->get("ARPassword");
				}
			}

			if ($continue) {
				// check password
				$criteria["login"]["value"]["="]="'".AddSlashes($ARLogin)."'";
				$result=$this->find("/system/users/",$criteria,"system.get.phtml");
				unset($criteria);	
				if (!($AR->user=$result[0])) {
					debug("pobject: CheckLogin: user in cookie not found","object");
					if (!$silent) {
						$arLoginMessage=$ARnls["accessdenied"].": ".sprintf($ARnls["userunknown"],$ARLogin);
						$this->call("user.login.html","arLoginMessage=".urlencode($arLoginMessage));
					}
					$continue=false;
				} else if (!$AR->user->CheckPassword($ARPassword)) {
					debug("pobject: CheckLogin: wrong password in cookie","object");
					if (!$silent) {
						$arLoginMessage=$ARnls["accessdenied"].": ".$ARnls["passwordincorrect"];
						$this->call("user.login.html","arLoginMessage=".urlencode($arLoginMessage));
					}
					$continue=false;
				} else {
					debug("pobject: CheckLogin: got user ".$result[0]->data->name,"all");
				}
			}
		}
		if ($continue) {
			$grants=$this->GetValidGrants();
			if ($AR->user->data->login!="public" && !Headers_sent()) {
				// Don't remove this or MSIE users won't get uptodate pages...
				Header("Pragma: no-cache");
				Header("Cache-control: no-store, no-cache, must-revalidate, max-age=0");
				Header("Expires: Mon, 26 Jul 1997 05:00:00 GMT");
				Header("Last-Modified: ".gmdate("D, d M Y H:i:s")." GMT");
				Header("Cache-control: private");
			}

			$AR->user->grants=$grants;
			if (!$grants[$grant] && $ARLogin!="admin") {
				// do login
				debug("pobject: CheckLogin: insufficient grants ($ARLogin)","object");
				if (!$silent) {
					$this->call("user.login.html");
				}
				$continue=false;
			}
		}
		$ARPassword=0;
		if ($continue) {
			debug("pobject: CheckLogin: end","all");
			$result=($grants || ($ARLogin=="admin"));
		} else {
			$result=false;
			debug("pobject: CheckLogin: end (failed)","all");
		}
		return $result;
	}

	function CheckSilent($grant) {
	global $AR;

		debug("pobject: CheckSilent($grant)","object");
		if ($AR->user->data->login=="admin") {
			$result=1;
		} else {
			$grants=$this->GetValidGrants();
			$result=$grants[$grant];
		}
		debug("pobject: CheckSilent: end","all");
		return $result;
	}

	function CheckNewFile($newfilename) {
	/**********************************************************************

	  This function performs all the necessary checks on a path to see
	whether it's a valid path for a new object. This consists of:
	1) checking for invalid characters, valid chars are "a-zA-Z0-9./_-"
	2) checking whether the path starts and ends with a "/".
	3) checking whether the path doesn't exist already.
	4) checking whether the parent exists.
	
	if all this checks out, it returns 1. If not, $this->error is set to
	the correct error message.
	
	**********************************************************************/

		debug("pobject: CheckNewFilename($newfilename)","object");
		$this->error="";
		if (eregi("^/[a-z0-9\./_-]*/$",$newfilename)) {
			if (!$this->store->exists($newfilename)) {
				$parent=$this->store->make_path($newfilename, "..");
				if ($this->store->exists($parent)) {
					$result=1;
				} else {
					$this->error="$newfilename is invalid: $parent does not exist.";
				}
			} else {
				$this->error="$newfilename already exists. Please choose another.";
			}
		} else {
			$this->error="Filenames may consist of normal charachters ".
				"(a-z, A-Z, 0-9) and '-','_' or '/'. A path must start and end ".
				"with a '/'.";
		}
		debug("pobject: CheckNewFilename: end","all");
		return $result;
	}

	function CheckConfig($arCallFunction="", $arCallArgs="") {
	// returns true when cache isn't up to date and no other template is
	// defined for $path/$function. Else it takes care of output to the
	// browser.
	// All these templates must exist under a fixed directory, $AR->dir->templates
	global $nocache, $AR, $ARConfig, $ARCurrent, $ARBeenHere, $ARnls;
	
		debug("pobject::CheckConfig($arCallFunction, $arCallArgs)","object");
		$MAX_LOOP_COUNT=10;
		if ($ARBeenHere[$this->path][$arCallFunction]<$MAX_LOOP_COUNT) { // protect against infinite loops
			$ARBeenHere[$this->path][$arCallFunction]+=1;
            if (!$ARConfig->cache[$this->path]) {
				$this->call("system.get.config.phtml");
			}
			$config=$ARConfig->cache[$this->path];
			$ARConfig->nls=$config->nls;
			// if a default language is entered in a parent and no language is
			// explicitly selected in the url, use that default. 
			// The root starts with the system default (ariadne.phtml config file)
			if ($config->nls->default && !$ARCurrent->nls) {
				$this->reqnls=$config->nls->default;
				$this->nls=$this->reqnls;
			}
			$nls=&$this->nls;
			$reqnls=&$this->reqnls;
			// if this object isn't available in the requested language, show
			// a language select dialog with all available languages for this object.
			if (isset($this->data->nls)) {
				if (!isset($this->data->$reqnls) || !$config->nls->list[$reqnls]) {
					if (!$ARCurrent->nolangcheck ) {
						include($this->store->code."widgets/nls/languageselect.phtml");
						return false;
					} else {
						$this->nlsdata=$this->data->$nls;
					}
				} else {
					$this->nlsdata=$this->data->$reqnls;
				}
			} 

			$ARCurrent->nolangcheck=1;
			if (($config->cache && ($config->cache>0)) &&
				(!$nocache) && ($AR->user->data->login=="public") &&
				(!$arCallArgs || $AR->OS=="UNIX")) {
				// caching is on and enabled in loader and user is public.
				$ARCurrent->headers=$this->call("system.get.headers.phtml");	
				if ($ARCurrent->cachepage) {
					$ARCurrent->filename=$ARCurrent->cachepage."=".$arCallArgs;
				} else {
					$ARCurrent->filename=$this->path.$arCallFunction."=".$arCallArgs;
				}
				if ($ARCurrent->nls) {
					$ARCurrent->filename="/".$ARCurrent->nls.$ARCurrent->filename;
				}
				$ARCurrent->cachetime=$config->cache;
				// start output buffering...	
				debug("CheckConfig: ob_start()","all");
				ob_start();
			}
			$nocache=true; // make sure no other parts are cached either;
			if ($this->data->pinp[$this->type][$arCallFunction][$this->nls]) {
				$config->templates[$this->type][$arCallFunction][$this->nls]=$this->data->pinp[$this->type][$arCallFunction][$this->nls];
			} else if ($this->data->pinp[$this->type][$arCallFunction]['any']) {
				$config->templates[$this->type][$arCallFunction]['any']=$this->data->pinp[$this->type][$arCallFunction]['any'];
			}
			$arType=get_class($this);
			while ($arType && !$arCallTemplate) {
				if ($config->templates[$arType][$arCallFunction][$this->nls]) {
					$arCallTemplate=$config->templates[$arType][$arCallFunction][$this->nls];
				} else if ($config->templates[$arType][$arCallFunction]['any']) {
					$arCallTemplate=$config->templates[$arType][$arCallFunction]['any'];
				} else {
					$arTemp=new $arType();
					$arType=get_parent_class($arTemp);
				}
			}
			if ($arCallTemplate) {
				debug("CheckConfig: arCallTemplate=$arCallTemplate","object");
				$arCallTemplate=$this->store->files."templates".$arCallTemplate;
				// check if template exists, if it doesn't exist, then continue the original template that called CheckConfig
				if (file_exists($arCallTemplate)) { 
					debug("CheckConfig: $arCallTemplate exists","object");
					// check if the requested language exists, if not do not display anything, 
					// unless otherwise indicated by $ARCurrent->allnls
					// This triggers only for pinp templates called by other templates,
					// as the first template (in the url) will first trigger the language
					// choice dialogue instead.
					$ARCurrent->arCallStack[]=$arCallArgs;
					if (isset($this->data->$reqnls)) {
						// the requested language is available.
						$this->nlsdata=$this->data->$nls;
						include($arCallTemplate);
					} else if (!isset($this->data->nls)) {
						debug("pobject: CheckConfig: no nls data ","all");
						// the object has no language support
						$this->nlsdata=&$this->data;
						include($arCallTemplate);
					} else if ($ARCurrent->allnls) {
						debug("pobject: CheckConfig: no $reqnls, but allnls set","all");
						// all objects must be displayed
						// $this->reqnls=$this->nls; // set requested nls, for checks
						$this->nls=$this->data->nls->default;
						$this->nlsdata=$this->data->$nls;
						include($arCallTemplate);
					} else {
						// requested language not available, allnls not set
						// -> skip this object (do not run template but do return false)
					}
					array_pop($ARCurrent->arCallStack);
					return false;
				} else {
					debug("pobject: CheckConfig: no such file: $arCallTemplate","all");
				}
			} else {
				debug("CheckConfig: no arCallTemplate","object");
			}
		} else {
			error("Max loop count exceeded in ".$this->path.$arCallFunction."?".$arCallArgs);
			$this->store->close();
			exit();
		}
		debug("pobject: CheckConfig: end","all");
		return true;
	}

	function MkDir($dir) {
		debug("pobject: MkDir($dir)","object");
		return ldMkDir($dir);
	}

	function SetCache($file, $time, $image, $headers) {
		ldSetCache($file, $time, $image, $headers);
	}

	function ClearCache($path="") {
	global $AR;
 
		debug("pobject: ClearCache($path)","object");
		if (!$path) { $path=$this->path; }
		$nlslist=$AR->nls->list;
		$nlslist["."]="default";
		while (list($nls,$language)=each($nlslist)) {
			$fpath=$this->store->files."cache/$nls/".$path;
			$hpath=$this->store->files."cacheheaders/$nls/".$path;
			$ppath=$this->store->files."privatecache/$nls/".$path;
			if ($dir=@dir($ppath)) {
				while ($entry=$dir->read()) {
					if (filetype($ppath.$entry)!="dir") {
						unlink($ppath.$entry);
					} else if ($entry!="." && $entry!="..") {
						$this->ClearCache($path.$entry."/");
					}
				}
			}		
			if ($dir=@dir($fpath)) {
				while ($entry=$dir->read()) {
					if ($entry!="." && $entry!="..") {
						if (filetype($fpath.$entry)!="dir") {
							unlink($fpath.$entry);
							unlink($hpath.$entry);
						} else if ($entry!="." && $entry!="..") {
							$this->ClearCache($path.$entry."/");
						}
					}
				}
			} else if (file_exists(substr($fpath,0,-1)."=")) {
				unlink(substr($fpath,0,-1)."=");
				unlink(substr($hpath,0,-1)."=");
			}
		}
	}

	function cached($name, $nls="") {
		debug("cached($name)","object");
		global $ARCurrent;
		if ($name) {
			$result=false;
			if (!$nls) {
				$nls=$this->nls;
			}
			$file="/".$nls.$this->path.$name."=";
			if ( file_exists($this->store->files."privatecache".$file) &&
			     (filemtime($this->store->files."privatecache".$file)>time()) ) {
				debug("cached: $name exists, reading from cache.","all");
				// FIXME!: should fix links, replace old session id's; use correct root, etc.
				if ($ARCurrent->session) {
					$session="/-".$ARCurrent->session->id."-";
				}
				echo str_replace("{arSession}",$session,
					implode("",file($this->store->files."privatecache".$file)));
				$result=true;
			} else {
				debug("cached: $name not found, start new cache image.","all");
				$ARCurrent->cache[]=$file;
				debug("cached: ob_start()","all");
				ob_start();
				/* output buffering is recursive, so this won't interfere with
				   normal page caching, unless you forget to call savecache()...
				   so normal pagecache needs to check $ARCurrent->cache, if it's
				   not empty, issue a warning and don't cache the outputbuffer...
				   savecache() must then pop the stack. 
				*/
			}
		} else {
			error("cached() : no name given for cache.");
		}
		return $result;
	}

	function savecache($time="") {
		debug("savecache($time)","object");
		global $ARCurrent;
		if (!$time) {
			$time=2; // 'freshness' in hours.
		}
		/* FIXME!: change links to current root with a placeholder.
		   problem: make_url makes it possible that the image also
		   contains other 'roots'. Which should be changed to their 
		   corresponding correct session id's.
		   possible fix: only replace the session id with a placeholder:
		   <img src="http://a.host.com/-abcd-/en/a/dir/img.gif"> to
		   <img src="http://a.host.com{arSession}/en/a/dir/img.gif">
		   language gets cached correctly.
           better fix: change this->store->root to {arRoot}, then change
           any remaining session id's to {arSession} ?
		*/
		if (($file=array_pop($ARCurrent->cache)) && $image=ob_get_contents()) {
			if ($ARCurrent->session) {
				$image=str_replace("/-".$ARCurrent->session->id."-","{arSession}",$image);
				$session="/-".$ARCurrent->session->id."-";
			}
			$path=substr($file, 0, strrpos($file, "/"));
			if (!file_exists($this->store->files."privatecache".$path)) {
				ldMkDir("privatecache".$path);
			}
			$fp=fopen($this->store->files."privatecache".$file, "w");
			fwrite($fp, $image);
			fclose($fp);
			$time=time()+($time*3600);
			if (!touch($this->store->files."privatecache".$file, $time)) {
				debug("savecache: ERROR: couldn't touch $file","object");
			}
			/* it seems that ob_end_flush doesn't really clean the output
			   output buffer, ob_end_clean() does. With flush, the loader
			   keeps thinking there is something to put in the cache while
			   flush also doesn't echo the buffer out... 
			   FIXME: test again in php 4.0.4 
			*/
			ob_end_clean();
			echo str_replace("{arSession}",$session,$image);
			debug("savecache: ob_end_flush()","all");
		} else {
			error("savecache: no file or image ...");
		}
		debug("savecache: end. ($file)","all");
	}

	function getdata($varname, $nls="none") {
	// function to retrieve variables from $this->data, with the correct
	// language version.
	global $ARCurrent, $HTTP_POST_VARS, $HTTP_GET_VARS;

		debug("pobject: getdata($varname, $nls)","object");
		$result=false;
		if ($nls!="none") {
            if ($ARCurrent->arCallStack) {
                Parse_Str(end($ARCurrent->arCallStack));
            }
            if (${$nls}[$varname]) {
                $result=${$nls}[$varname];
			} else if (isset($ARCurrent->$nls->$varname)) {
				$result=$ARCurrent->$nls->$varname;
			} else if (($values=$HTTP_POST_VARS[$nls]) && isset($values[$varname])) {
				$result=$values[$varname];
			} else if (($values=$HTTP_GET_VARS[$nls]) && isset($values[$varname])) {
				$result=$values[$varname];
			} else if (($arStoreVars=$HTTP_POST_VARS["arStoreVars"]) && isset($arStoreVars[$nls][$varname])) {
				$result=$arStoreVars[$nls][$varname];
			} else if (($arStoreVars=$HTTP_GET_VARS["arStoreVars"]) && isset($arStoreVars[$nls][$varname])) {
				$result=$arStoreVars[$nls][$varname];
			}
			if ($result===false) {
				if (isset($this->data->${nls}->${varname})) {
					$result=$this->data->${nls}->${varname};
				}
			}
		} else { // language independant variable.
			if ($ARCurrent->arCallStack) {
				Parse_Str(end($ARCurrent->arCallStack));
			}
			if ($$varname) {
				$result=$$varname;
			} else if (isset($ARCurrent->$varname)) {
				$result=$ARCurrent->$varname;
			} else if (isset($HTTP_POST_VARS[$varname])) {
				$result=$HTTP_POST_VARS[$varname];
			} else if (isset($HTTP_GET_VARS[$varname])) {
				$result=$HTTP_GET_VARS[$varname];
			} else if (($arStoreVars=$HTTP_POST_VARS["arStoreVars"]) && isset($arStoreVars[$varname])) {
				$result=$arStoreVars[$varname];
			} else if (($arStoreVars=$HTTP_GET_VARS["arStoreVars"]) && isset($arStoreVars[$varname])) {
				$result=$arStoreVars[$varname];
			}
			if ($result===false) {
				if (isset($this->data->$varname)) {
					$result=$this->data->$varname;
				}
			}        
		}
		return $result;
	}

	function showdata($varname, $nls="none") {
		debug("pobject: showdata($varname, $nls)","object");
		echo $this->getdata($varname, $nls);
	}

	function setnls($nls) {
		debug("pobject: setnls($nls)","object");
		ldSetNls($nls);
	}

/********************************************************************

  "safe" functions.

  The following functions are safe versions of existing functions
  above. 
  - They don't change anything in the database. 
    This means that to save/delete something, a user will need to call
    "system.save.data.phtml" or "system.delete.phtml" which check grants.
  - All functions except _get and _exists don't take a path as 
    argument, they use the current objects path instead.

  These are meant to be used by 'pinp' versions of templates,
  meaning user defined templates. 'pinp' rewrites call to functions
  to the form '$this->_function'.

  All pinp files automatically first call CheckLogin('read').
  
********************************************************************/

	function _call($function, $args="") {
		return $this->call($function, $args);
	}

	function _get($path, $function="view.html", $args="") {
		debug("pobject: get($path, $function, $args)","object");
		return $this->store->call($function, $args, 
			$this->store->get(
				$this->make_path($path))); 
	}

	function _ls($function="list.html", $args="") {
		debug("pobject: ls($function, $args)","object");
		return $this->store->call($function, $args, 
			$this->store->ls($this->path));
	}

	function _parents($function="list.html", $args="") {
		debug("pobject: parents($function, $args)","object");
		return $this->store->call($function, $args, 
			$this->store->parents($this->path));
	}

	function _find($criteria, $function="list.html", $args="", $limit=100, $offset=0) {
		return $this->store->call($function, $args, 
		$this->store->find($this->path, $criteria, $limit, $offset));
	}

	function _exists($path) {
		debug("pobject: exists($path)","object");
		return $this->store->exists($this->make_path($path));
	}

	function _getvar($var) {
	global $HTTP_POST_VARS, $HTTP_GET_VARS, $ARCurrent, $ARConfig;

		debug("pobject: getvar($var)","object");
		if ($ARCurrent->arCallStack) {
			$arCallArgs=end($ARCurrent->arCallStack);
			Parse_Str($arCallArgs);
		}
		if ($$var) {
			$result=$$var;
		} if ($ARCurrent->$var) {
			$result=$ARCurrent->$var;
		} else if ($HTTP_POST_VARS[$var]) {
			$result=$HTTP_POST_VARS[$var];
		} else if ($HTTP_GET_VARS[$var]) {
			$result=$HTTP_GET_VARS[$var];
		} 
		return $result;
	}

	function _putvar($var, $value) {
	global $ARCurrent;

		debug("pobject: putvar($var, $value)","object");
		$ARCurrent->$var=$value;
	}  

	function _setnls($nls) {
		$this->setnls($nls);
	}

	function _widget($arWidgetName, $arWidgetTemplate, $arWidgetArgs="") {
	global $AR, $ARConfig, $ARCurrent, $ARnls;

		debug("pobject: widget($arWidgetName, $arWidgetTemplate, $arWidgetArgs)","object");
		$arWidgetName=ereg_replace("[^a-zA-Z0-9\.]","",$arWidgetName);
		$arWidgetTemplate=ereg_replace("[^a-zA-Z0-9\.]","",$arWidgetTemplate);
		if (file_exists($this->store->code."widgets/$arWidgetName")) {
			if (file_exists($this->store->code."widgets/$arWidgetName/$arWidgetTemplate")) {
				Parse_str($arWidgetArgs);
				include($this->store->code."widgets/$arWidgetName/$arWidgetTemplate");
			} else {
				error("Template $arWidgetTemplate for widget $arWidgetName not found.");
			}
		} else {
			error("Widget $wgName not found");
		}
		if ($wgResult) {
			return $wgResult;
		}
	}

	function _getdata($varname, $nls="none") { 
		return $this->getdata($varname, $nls);
	}

	function _showdata($varname, $nls="none") {
		$this->showdata($varname, $nls);
	}

	function _gettext($index) {
		global $ARnls;
		return $ARnls[$index];
	}

	function _startsession() {
		return $this->store=ldStartSession(0);
	}

	function _putsessionvar($varname, $varvalue) {
	global $ARCurrent;

		$ARCurrent->session->put($varname, $varvalue);
	}

	function _getsessionvar($varname) {
	global $ARCurrent;

		return $ARCurrent->session->get($varname);
	}

	function _killsession() {
	global $ARCurrent;

		$ARCurrent->session->kill();
	}

	function _sessionid() {
	global $ARCurrent;
		if ($ARCurrent->session) {
			return $ARCurrent->session->id;
		} else {
			return 0;
		}
	}

	function _resetloopcheck() {
		global $ARBeenHere;
		$ARBeenHere=Array();
	}

	function _make_path($path="") {
		return $this->make_path($path);
	}

	function _make_url($path="") {
		return $this->make_url($path);
	}

	function _cached($name) {
		return $this->cached($name);
	}

	function _savecache($time="") {
		return $this->savecache($time);
	}
} // end class pobject
?>