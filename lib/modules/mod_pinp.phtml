<?php
define("PT_VARIABLE",		254);
define("PT_STRING",			253);
define("PT_SUBSTRING",		252);
define("PT_IDENT",			251);
define("PT_UNPARSED",		250);
define("PT_EOF",				249);
define("PT_MULTIPART_STRING_START",	248);
define("PT_MULTIPART_STRING_END",	247);
define("PT_PINP_START",		246);
define("PT_PINP_END",		245);
define("PT_ERROR",			244);
define("PT_PAR_OPEN",		243);
define("PT_NEW",				242);
define("PT_FUNCTION",		241);
define("PT_GLOBAL",			240);
define("PT_RETURN",			239);
define("PT_FILENAME",		238);
define("PT_INCLUDE",			237);
define("PT_INCLUDE_ONCE",	236);
define("PT_REQUIRE",			235);
define("PT_REQUIRE_ONCE",	234);
define("PT_PAR_CLOSE",		233);
define("PT_COMMA",			232);
define("PT_BRACKET_OPEN",	231);
define("PT_BRACKET_CLOSE",	230);
define("PT_VAR_REFERENCE",	229);
define("PT_DQ_STRING",		228);
define("PT_CBRACE_OPEN",		227);
define("PT_CBRACE_CLOSE",	226);
define("PT_NUMBER",			225);
define("PT_END_STMT",		224);

define("YY_STATE_HTML",			1);
define("YY_STATE_PINP",			2);

class scanner {

	function scanner() {
		/*
			create lookup table for language constructs
		*/
		$this->YYLANG_CONSTRUCTS = Array(
				"new" => PT_NEW,
				"function" => PT_FUNCTION,
				"global" => PT_GLOBAL,
				"return" => PT_RETURN,
				"__file__" => PT_FILENAME,
				"include" => PT_INCLUDE,
				"include_once" => PT_INCLUDE_ONCE,
				"require" => PT_REQUIRE,
				"require_once" => PT_REQUIRE_ONCE
				);


		
		
		/*
			create character classes
		*/
		for ($c = ord('a'); $c <= ord('z'); $c++) {
			$cclass[chr($c)] = chr($c);
			$cclass[strtoupper(chr($c))] = strtoupper(chr($c));
		}
		$cclass["_"] = "_";
		$this->YYCLASSES["ID_FIRST"] = $cclass;

		$cclass_second = $cclass;
		for ($c = ord('0'); $c <= ord('9'); $c++) {
			$cclass_second[chr($c)] = 1;
		}
		$this->YYCLASSES["ID_SECOND"] = $cclass_second;

		$cclass_trailing["\n"] = 1;
		$cclass_trailing[" "] = 1;
		$cclass_trailing["\t"] = 1;
		$cclass_trailing[chr(13)] = 1;
		$this->YYCLASSES["NOISE"] = $cclass_trailing;

		$cclass['"'] = '"';
		$cclass["'"] = "'";
		$cclass['$'] = '$';
		$cclass['/'] = '/';
		$cclass['-'] = '-';
		$cclass['`'] = '`';
		$cclass['<'] = '<';
		$cclass['%'] = '%';
		$cclass['?'] = '?';
		$cclass['('] = '(';
		$cclass[')'] = ')';
		$cclass['#'] = '#';
		$cclass[','] = ',';
		$cclass['{'] = '}';
		$cclass['}'] = '{';
		$cclass['='] = '=';
		$cclass['0'] = '0';
		$cclass['1'] = '1';
		$cclass['2'] = '2';
		$cclass['3'] = '3';
		$cclass['4'] = '4';
		$cclass['5'] = '5';
		$cclass['6'] = '6';
		$cclass['7'] = '7';
		$cclass['8'] = '8';
		$cclass['9'] = '9';
		$cclass[';'] = ';';
		$cclass[chr(0)] = 1;
		$this->YYCLASSES["START_TRANSITION"] = $cclass;
	}

	function init($buffer) {
		$this->YYBUFFER = $buffer."\0";
		$this->YYLINE = 1;
		$this->YYSTATE = YY_STATE_HTML;
		$YYCURSOR = 0;
	}

	function scan(&$result) {
		$YYCURSOR = &$this->YYCURSOR;
		$YYBUFFER = &$this->YYBUFFER;
		$YYCLASSES = &$this->YYCLASSES;
		$YYCURSOR_START = $YYCURSOR;
		$YYSTATE = &$this->YYSTATE;

		do {
			$yych = $YYBUFFER[$YYCURSOR];
			switch ($YYSTATE) {
				case YY_STATE_HTML:
					if (ord($yych) == 0) {
						return PT_EOF;
					} else {
						$matches='';
						$scan_buffer = substr($YYBUFFER, $YYCURSOR, -1);
						$re_code="^(.*)(<pinp>|<script[^>]+language[^>]*=[^>]*php[^>]*>|<[%?])";
						if (preg_match("!".$re_code."!Usi", $scan_buffer, $matches)) {
							$this->YYLINE += substr_count($matches[1], "\n");
							if ($matches[2]) {
								if (strtolower($matches[2]) === "<pinp>") {
									/* pinp tag found */
									$result = $matches[1];
									$YYCURSOR+=strlen($matches[0]);
									$YYSTATE = YY_STATE_PINP;
									return PT_PINP_START;
								} else {
									/* php start tag found */
									$result = $matches[1];
									$YYCURSOR+=strlen($matches[0]);
									$result .= "<?php echo \"".str_replace('$', '\\$', AddCSlashes($matches[2], ARESCAPE))."\"; ?>";
									return PT_UNPARSED;
								}
							} else {
								$result = $matches[1];
								$YYCURSOR+=strlen($matches[0]);
								return PT_UNPARSED;
							}
						} else {
							$result = $scan_buffer;
							$YYCURSOR = strlen($YYBUFFER);
							return PT_UNPARSED;
						}
					}
				break;
				case YY_STATE_PINP:
					switch($yych) {
						/*
							Single characters directly beneath here
						*/
						case ';': ($token || $token = PT_END_STMT);
						case '{': ($token || $token = PT_CBRACE_OPEN);
						case '}': ($token || $token = PT_CBRACE_CLOSE);
						case ',': ($token || $token = PT_COMMA);
						case '(': ($token || $token = PT_PAR_OPEN);
						case ')': ($token || $token = PT_PAR_CLOSE);
						case '[': ($token || $token = PT_BRACKET_OPEN);
						case ']': ($token || $token = PT_BRACKET_CLOSE);
							$yych = $YYBUFFER[++$YYCURSOR];
							while ($YYCLASSES["NOISE"][$yych]) {
								if ($yych == "\n") {
									$this->YYLINE++;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
							return $token;
						break;

						case '$': 
							$result = Array();
							array_push($result, Array(PT_VAR_REFERENCE => $yych));
							$YYCINC = 1;

							$yych = $YYBUFFER[++$YYCURSOR];
							if ($yych == '{') {
								array_push($result, Array(PT_CBRACE_OPEN => $yych));
								return ++$YYCURSOR;
							} else {
								if ($yych == '$') {
									$YYCINC++;
									array_push($result, Array(PT_VAR_REFERENCE => $yych));
									$yych = $YYBUFFER[++$YYCURSOR];
								}
								if ($YYCLASSES["ID_FIRST"][$yych]) {
									$yych = $YYBUFFER[++$YYCURSOR];
									while ($YYCLASSES["ID_SECOND"][$yych]) {
										$yych = $YYBUFFER[++$YYCURSOR];
									}
									while ($YYCLASSES["NOISE"][$yych]) {
										if ($yych == "\n") {
											$this->YYLINE++;
										}
										$yych = $YYBUFFER[++$YYCURSOR];
									}
									$ident = substr($YYBUFFER, $YYCURSOR_START+$YYCINC, $YYCURSOR-$YYCURSOR_START-$YYCINC);
									array_push($result, Array(PT_IDENT => $ident));

									return PT_VARIABLE;
								} else {
									$result = "single dollar sign";
									return PT_ERROR;
								}
							}
						break;

						case '%':
						case '?':
							$result = $yych;
							$yych = $YYBUFFER[++$YYCURSOR];
							if ($yych == '>') {
								$result = "php tags found at line: ".$this->YYLINE;
								return PT_ERROR;
							} else {
								return PT_UNPARSED;
							}
						break;

						case '=':
							$yych	= $YYBUFFER[++$YYCURSOR];
							$token	= PT_ASSIGN_OP;
							if ($yych === '>') {
								$token	= PT_ARRAY_OP;
								$yych	= $YYBUFFER[++$YYCURSOR];
							}
							while ($YYCLASSES["NOISE"][$yych]) {
								if ($yych == "\n") {
									$this->YYLINE++;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
							return $token;
						break;


						case '<':
							$yych = $YYBUFFER[++$YYCURSOR];
							switch ($yych) {
								case '/':
									$yych = $YYBUFFER[++$YYCURSOR];
									while ($yych == ' ') {
										$yych = $YYBUFFER[++$YYCURSOR];
									} 
									$tag_element = "";
									while ($yych != ' ' && ord($yych)!==0 && $yych != '>') {
										$tag_element .= $yych;
										$yych = $YYBUFFER[++$YYCURSOR];
									}
									while (ord($yych)!==0 && $yych!='>') {
										$yych = $YYBUFFER[++$YYCURSOR];
									}
									if ($yych=='>') {
										++$YYCURSOR;
									}
									if ($tag_element == "pinp") {
										$result="";
										$YYSTATE = YY_STATE_HTML;
										return PT_PINP_END;
									} else {
										$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
										return PT_UNPARSED;
									}
								break;
								default:
									$result = "<";
								break;
							}
							return PT_UNPARSED;
						break;					
						case '/':
							$yych = $YYBUFFER[++$YYCURSOR];
							switch ($yych) {
								case '/':
									$yych = $YYBUFFER[++$YYCURSOR];
									while ($yych != "\n" && $yych != "\r" && ord($yych)!==0) {
										$yych = $YYBUFFER[++$YYCURSOR];
									}
									$result = "";
									return PT_UNPARSED;
								break;
								case '*':
									$result="";
									$start_line = $this->YYLINE;
									$yych = $YYBUFFER[++$YYCURSOR];
									while (ord($yych)!==0) {
										if ($yych == "\n") {
											$this->YYLINE++;
											$result.="\n";
										}
										if ($yych == '*') {
											if  (($yych = $YYBUFFER[++$YYCURSOR]) == '/') {
												++$YYCURSOR;
												return PT_UNPARSED;
											}
										} else {
											$yych = $YYBUFFER[++$YYCURSOR];
										}
									}
									$result = "unterminated comment, started at $start_line";
									return PT_ERROR;
								break;
								default:
									$result = "/";
									return PT_UNPARSED;
								break;
							}
						break;

						case '0':
						case '1':
						case '2':
						case '3':
						case '4':
						case '5':
						case '6':
						case '7':
						case '8':
						case '9':
							$yych = $YYBUFFER[++$YYCURSOR];
							while ($yych >= "0" && $yych <= "9") {
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							if ($yych === '.') {
								$yych = $YYBUFFER[++$YYCURSOR];
								while ($yych >= "0" && $yych <= "9") {
									$yych = $YYBUFFER[++$YYCURSOR];
								}
							}
							while ($YYCLASSES["NOISE"][$yych]) {
								if ($yych == "\n") {
									$this->YYLINE++;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
							return PT_NUMBER;
						break;

						case $this->YYCLASSES["ID_FIRST"][$yych]:
							/* Identifier */
							$yych = $YYBUFFER[++$YYCURSOR];
							while ($YYCLASSES["ID_SECOND"][$yych]) {
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							while ($YYCLASSES["NOISE"][$yych]) {
								if ($yych == "\n") {
									$this->YYLINE++;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
							$construct = $this->YYLANG_CONSTRUCTS[chop(strtolower($result))];
							if ($construct) {
								return $construct;
							} else {
								return PT_IDENT;
							}
						break;
						case ':':
							$yych = $YYBUFFER[++$YYCURSOR];
							switch ($yych) {
								case ':':
									$yych = $YYBUFFER[++$YYCURSOR];
									$result = "::";
									return PT_CLASS_OPERATOR;
								break;
								default:
									$result = ":";
									return PT_UNPARSED;
								break;
							}
							
						break;
						case '`':
							$result = "backtick encounterd at line ".$this->YYLINE;
							return PT_ERROR;
						break;
						case '"':
							$start_line = $this->YYLINE;
							$multi_string = Array();
							$yych = $YYBUFFER[$YYCURSOR_START=++$YYCURSOR];
							while (ord($yych)!==0 && $yych != '"') {
								if ($yych == '\\') {
									++$YYCURSOR;
								} else
								if ($yych == "\n") {
									$this->YYLINE++;
									++$YYCURSOR;
								} else
								if ($yych == '$') {
									/*	
										push previous parsed string on stack
										if we've got one
									*/
									if ($YYCURSOR_START != $YYCURSOR) {
										$string=substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR - $YYCURSOR_START);
										array_push($multi_string, Array(PT_SUBSTRING => $string));
										$YYCURSOR_START = $YYCURSOR;
									}
									$yych = $YYBUFFER[++$YYCURSOR];
									if ($YYCLASSES["ID_FIRST"][$yych]) {
										$yych = $YYBUFFER[++$YYCURSOR];
										while ($YYCLASSES["ID_SECOND"][$yych]) {
											$yych = $YYBUFFER[++$YYCURSOR];
										}
										while ($YYCLASSES["NOISE"][$yych]) {
											if ($yych == "\n") {
												$this->YYLINE++;
											}
											$yych = $YYBUFFER[++$YYCURSOR];
										}
										$string=substr($YYBUFFER, $YYCURSOR_START+1, $YYCURSOR - $YYCURSOR_START -1);	
										array_push($multi_string, Array(PT_VARIABLE => $string));
										$YYCURSOR_START = $YYCURSOR;
										/* 
											token already read, so continue 'while'
											statement.
										*/
										continue;
									} else {
										$string=substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR - $YYCURSOR_START - 1);
										$YYCURSOR--;
										array_push($multi_string, Array(PT_SUBSTRING => $string));
										$YYCURSOR_START=$YYCURSOR;
									}
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							if (ord($yych) != 0) {
								$YYCURSOR++;
								$string=substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR - $YYCURSOR_START - 1);

								array_push($multi_string, Array(PT_SUBSTRING => $string));
								array_unshift($multi_string, Array(PT_MULTIPART_STRING_START => 1));
								array_push($multi_string, Array(PT_MULTIPART_STRING_END => 1));
								$result = $multi_string;
								return PT_DQ_STRING;
							} else {
								$result = "unterminated quote, started at line $start_line";
								return PT_ERROR;
							}
						break;
						case "'":
							$start_line = $this->YYLINE;
							$yych = $YYBUFFER[++$YYCURSOR];
							while ($yych != "'" && ord($yych)!==0) {
								if ($yych == '\\') {
									++$YYCURSOR;
								} else
								if ($yych == "\n") {
									$this->YYLINE++;
									++$YYCURSOR;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							if (ord($yych)!==0) {
								while ($YYCLASSES["NOISE"][$yych = $YYBUFFER[++$YYCURSOR]]) {
									if ($yych == "\n") {
										$this->YYLINE++;
									}
									//$yych = $YYBUFFER[++$YYCURSOR];
								}
								$result=substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR - $YYCURSOR_START);
								return PT_STRING;
							} else {
								$result = "unterminated quote, started at line: $start_line";
								return PT_ERROR;
							}
						break;
						case "-":
							if (($yych=$YYBUFFER[++$YYCURSOR])=='>') {
								$token = PT_OBJECT_OPERATOR;
								$yych = $YYBUFFER[++$YYCURSOR];
							} else {
								$token = PT_UNPARSED;
							}
							while ($YYCLASSES["NOISE"][$yych]) {
								if ($yych == "\n") {
									$this->YYLINE++;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
							return $token;
						break;
						case "\0":
							return PT_EOF;
						break;
						case $YYCLASSES["START_TRANSITION"][$yych]:
							// unhandled start_transition
							++$YYCURSOR;
							$result = $yych;
							return PT_UNPARSED;
						break;
						default:
							while (!$YYCLASSES["START_TRANSITION"][$yych] && ord($yych) !== 0) {
								if ($yych == "\n") {
									$this->YYLINE++;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
							return PT_UNPARSED;
						break;
					}
				break;
			}
		} while (1);
	}
}

class pinp {

	function pinp($allowed_functions, $var_prefix, $function_prefix="") {
		$var_prefix="\$".$var_prefix;
		if (!$function_prefix) {
			$function_prefix=$var_prefix;
		}
		if (is_array($allowed_functions)) {
			$allowed_functions=implode("|", $allowed_functions);
		}

		$this->var_prefix = $var_prefix;
		$this->function_prefix = $function_prefix;

		$array_funcs="|array|array_change_key_case|array_chunk|array_count_values|".
		  "array_diff|array_flip|array_fill|array_intersect|array_key_exists|array_keys|".
		  "array_merge|array_merge_recursive|array_multisort|array_pad|array_pop|".
		  "array_push|array_rand|array_reverse|array_shift|array_slice|array_splice|".
		  "array_sum|array_unique|array_unshift|array_values|arsort|asort|count|current|".
		  "each|end|in_array|array_search|key|krsort|ksort|list|natsort|natcasesort|".
		  "next|pos|prev|range|reset|rsort|shuffle|sizeof|sort|get_object_vars";
		$control_funcs="if|else|elseif|do|while|for|switch|foreach";
		$datetime_funcs="checkdate|date|getdate|gettimeofday|gmdate|gmmktime|".
	      "gmstrftime|localtime|microtime|mktime|strftime|time|strtotime|".
		  "easter_days|easter_date";
		$math_funcs="abs|acos|acosh|asin|asinh|atan|atanh|atan2|base_convert|bindec|ceil|cos|".
	      "cosh|decbin|dechex|decoct|deg2rad|exp|expm1|floor|getrandmax|hexdec|hypot|lcg_value|log|log10|log1p|max|min|".
	      "mt_rand|mt_srand|mt_getrandmax|number_format|octdec|pi|pow|rad2deg|rand|round|".
	      "sin|sinh|sqrt|srand|tan|tanh|bcadd|bccomp|bcdiv|bcmod|bcmul|bcpow|bcscale|bcsqrt|".
		  "bcsub|gmp_[a-z_]+";
		$misc_funcs="mail|highligh_string|pack|get_browser|get_class|uniqid";
		$net_funcs="checkdnsrr|gethostbyaddr|gethostbyname|gethostbynamel|getmxrr|".
		  "getservbyport|getservbyname|ip2long|long2ip";
		$regex_funcs="ereg|ereg_replace|eregi|eregi_replace|split|spliti|preg_match|".
		  "preg_match_all|preg_split|preg_quote|preg_grep";
		$string_funcs="addslashes|addcslashes|bin2hex|chop|chr|chunk_split|".
		  "convert_cyr_string|count_chars|crc32|crypt|echo|explode|flush|".
		  "get_html_translation_table|htmlentities|htmlspecialchars|implode|join|".
		  "levenshtein|localeconv|ltrim|md5|metaphone|nl2br|ord|parse_str|print|printf|".
		  "quoted_printable_decode|quotemeta|rawurldecode|rawurlencode|rtrim|str_rot13|".
	      "sscanf|setlocale|similar_text|soundex|sprintf|strncasecmp|strcasecmp|strchr|".
		  "strcmp|strcoll|strcspn|strip_tags|stripcslashes|stripslashes|stristr|strlen|".
		  "strnatcmp|strnatcasecmp|strncmp|str_pad|strpos|strrchr|str_repeat|strrev|".
		  "strrpos|strspn|strstr|strtok|strtolower|strtoupper|str_replace|strtr|substr|".
		  "substr_count|substr_replace|trim|ucfirst|ucwords|vprintf|vsprintf|wordwrap|".
		  "base64_decode|base64_encode|urldecode|urlencode|parse_url|basename|dirname";
		$var_funcs="doubleval|empty|floatval|gettype|intval|is_array|is_bool|is_double|".
		  "is_float|is_int|is_integer|is_long|is_null|is_numeric|is_object|is_real|".
		  "is_resource|is_scalar|is_string|isset|settype|serialize|strval|unserialize|".
		  "unset|print_r|var_dump|var_export";
		$xml_funcs="xmldoc|xmltree|domxml_[a-z_]+|xpath_[a-z_]+|xptr_[a-z_]+|".
		  "xml_parser_create|xml_parse_into_struct|xml_parser_free|".
		  "xml_parser_get_option|xml_parser_set_option";
		$debug_funcs="debug|debugon|debugoff|pftime|pfprint|pfreset";
		$loader_funcs="ldheader|ldredirect|ldsetcontent|ldsetclientcache|ldgetusercookie|ldsetusercookie|ldgetclientvar|ldregisterfile|ldgetservervar"; 
		$ob_funcs="flush|ob_clean|ob_end_clean|ob_end_flush|ob_flush|ob_get_contents|ob_get_length|ob_get_level|ob_implicit_flush|ob_start";
		$this->allowed_functions=array_flip(explode("|", "$array_funcs|$control_funcs|$datetime_funcs|$math_funcs|".
		  "$misc_funcs|$net_funcs|$regex_funcs|$string_funcs|$var_funcs|$xml_funcs|".
		  "$allowed_functions|$debug_funcs|$loader_funcs|$ob_funcs|"));

		/*
			create lookup table for cast-types
		*/
		$this->language_types = Array(
				"int"		=> true,
				"integer"	=> true,
				"bool"		=> true,
				"boolean"	=> true,
				"float"		=> true,
				"double"	=> true,
				"string"	=> true,
				"binary"	=> true,
				"array"		=> true,
				"object"	=> true		
		);
	}

	function push_token($token, $token_value) {
		if ($this->token_ahead) {
			array_unshift($this->tokens, Array($this->token_ahead => $this->token_ahead_value));
		}
		$this->token_ahead = $token;
		$this->token_ahead_value = $token_value;
	}

	function next_token() {
		$value="";
		if (count($this->tokens) == 0) {
			$token = $this->scanner->scan($value);
			if (is_array($value)) {
				$this->tokens = $value;
				list($token, $token_value) = each(array_shift($this->tokens));
			} else {
				$token = $token;
				$token_value = $value;
			}
		} else {
			list($token, $token_value) = each(array_shift($this->tokens));
		}
		if ($this->token_ahead) {
			$this->token = $this->token_ahead;
			$this->token_value = $this->token_ahead_value;
		}
		$this->token_ahead = $token;
		$this->token_ahead_value = $token_value;
	}


	function parse_func_call_args() {
		do {
			// T_PAR_OPEN or T_COMMA 
			if ($this->token !== PT_END_STMT) {
				$this->next_token();
				$result .= $this->token_value;
			}
			if ($this->token_ahead == PT_COMMA) {
				// also accept an empty argument
				continue;
			}
			$result .= $this->parse_statement();
		} while (!$this->error && ($this->token_ahead == PT_COMMA || $this->token == PT_END_STMT));
		return $result;
	}

	function parse_var_index($var_prefix, $func_prefix) {
		$result = "";
		if ($this->token_ahead == PT_IDENT) {
			$this->next_token();
			$ident			= $this->token_value;
			$array_index	= $this->parse_array_operator();
			if ($this->error) {
				return false;
			}
			if ($this->token_ahead == PT_PAR_OPEN) {
				if ($array_index) {
					$this->error = "Can't call functions from an array at line: ".$this->scanner->YYLINE;
					return false;
				}
				$call_args = $this->parse_func_call_args();
				if ($this->error) {
					return false;
				}
				if ($this->token_ahead != PT_PAR_CLOSE) {
					$this->error = "Expected ')' at line: ".$this->scanner->YYLINE;
					return false;
				}
				$this->next_token();
				$call_args .= $this->token_value;

				$result = $func_prefix.$ident.$call_args;
			} else {
				$result = $var_prefix.$ident.$array_index;			
			}
		} else if ($this->token_ahead == PT_CBRACE_OPEN || $this->token_ahead == PT_VAR_REFERENCE) {
			$this->next_token();
			if ($this->token == PT_CBRACE_OPEN) {
				$index = "(".$this->parse_statement().")";
				if ($this->error) {
					return false;
				}
				if ($this->token_ahead != PT_CBRACE_CLOSE) {
					$this->error = "Expected '}' at line: ".$this->scanner->YYLINE;
					return false;			
				}
				$this->next_token();
			} else {
				if ($this->token_ahead != PT_IDENT) {
					$this->error = "Expected an identifier insteaf of '".$this->token_ahead_value."' at line: ".$this->scanner->YYLINE;
					return false;
				}
				$this->next_token();
				$index = $this->var_prefix.$this->token_value;
			}
			$array_index = $this->parse_array_operator();
			if ($this->error) {
				return false;
			}
			if ($this->token_ahead == PT_PAR_OPEN) {
				if ($array_index) {
					$this->error = "Can't call functions from an array at line: ".$this->scanner->YYLINE;
					return false;
				}
				$call_args = $this->parse_func_call_args();
				if ($this->error) {
					return false;
				}
				if ($this->token_ahead != PT_PAR_CLOSE) {
					$this->error = "Expected ')' at line: ".$this->scanner->YYLINE;
					return false;
				}
				$this->next_token();
				$call_args .= $this->token_value;

				$result = "{'".$func_prefix."'.".$index."}".$call_args;
			} else {
				$result = "$var_prefix"."{".$index."}".$array_index;
			}
		} else {
			$this->error = "Unexpected '".$this->token_ahead_value."' following '".$this->token_value."' at line: ".$this->scanner->YYLINE;
		}
		return $result;
	}


	function parse_array_operator() {
		$result = "";
		while (!$this->error && ( $this->token_ahead == PT_BRACKET_OPEN ||
					$this->token_ahead == PT_CBRACE_OPEN ) ) {

			$this->next_token();
			if ($this->token == PT_BRACKET_OPEN) {
					$token_close = PT_BRACKET_CLOSE;
					$token_close_value = "]";
			} else {
					$token_close = PT_CBRACE_CLOSE;
					$token_close_value = "]";
			}

			$result .= $this->token_value;

			$stmt	= $this->parse_statement();
			if (trim($stmt)) {
				$result .= "($stmt)";
			} else {
				$result .= $stmt;
			}
			//NOTE(ORIGINAL): $result .= $this->parse_statement();
			if ($this->token_ahead != $token_close) {
				$this->error = "Expected '$token_close_value' at line: ".$this->scanner->YYLINE;
				return false;
			}
			$this->next_token();
			$result .= $this->token_value;
		}
		return $result;		
	}


	function parse_object_operator() {
		while (!$this->error && $this->token_ahead == PT_OBJECT_OPERATOR) {
			$this->next_token();
			$result .= $this->token_value.$this->parse_var_index("", "_");
			if ($this->token == PT_PAR_CLOSE) {
				break;
			}
		}
		return $result;
	}


	function parse_variable_reference() {
		$this->next_token(); // eat $ sign;
		$result = $this->var_prefix.$this->parse_var_index("", "_");
		if ($this->error) {
			return false;
		}
		return $result;
	}

	function parse_expression() {
		$result = "";
		switch ($this->token_ahead) {

			case PT_VAR_REFERENCE:
				$result = $this->parse_variable_reference();
				if ($this->error) {
					return false;
				}
				if ($this->token == PT_PAR_CLOSE) {
					$parseReturnValues = true;
				} else if ($this->token_ahead == PT_OBJECT_OPERATOR) {
					$result .= $this->parse_object_operator();
				}
				if ($this->token == PT_PAR_CLOSE) {
					$parseReturnValues = true;
				}
			break;

			case PT_IDENT:
				$identSet = false;
				$iname = chop(strtolower($this->token_ahead_value));
				$this->next_token();
				if ($this->token_ahead == PT_CLASS_OPERATOR) {
					$result = "pinp_".$this->token_value."::";
					$this->next_token();
					if ($this->token_ahead != PT_IDENT) {
						$this->error = "Expecting an identifier following ($result) at line ".$this->scanner->YYLINE;
						return false;
					} else {
						$this->next_token();
						$result .= "_".$this->token_value;
					}
					$identSet = true;
				}
				if ($this->token_ahead == PT_PAR_OPEN) {
					// we don't have to prefix the function identifier if we already have done that.
					if (!$identSet) {
						if (!$this->allowed_functions[$iname]) {
								$result = $this->function_prefix.$this->token_value;
						} else {
								$result = $this->token_value;
						}
					}
					$result .= $this->parse_func_call_args();
					if ($this->error) {
						return false;
					}
					if ($this->token_ahead != PT_PAR_CLOSE) {
						$this->error = "Expected ')' instead of '".$this->token_ahead_value."' at line ".$this->scanner->YYLINE;
						return false;
					}
					$result .= $this->token_ahead_value;
					$this->next_token();

					$identSet = true;
					$parseReturnValues = true;
				}
				if (!$identSet) {
					$result = $this->token_value;
				}
			break;

			case PT_PAR_OPEN:
				$result = $this->token_ahead_value;
				$this->next_token();
				// parse casting, e.g. (int) (float)
				if ($this->token_ahead == PT_IDENT && $this->language_types[strtolower(trim($this->token_ahead_value))]) {
					$this->next_token();
					$result .= $this->token_value;
					if ($this->token_ahead != PT_PAR_CLOSE) {
						$this->error = "Expected ')' for casting to '".$this->token_value."' at line: ".$this->scanner->YYLINE;
					} else {
						$this->next_token();
						$result .= $this->token_value;
					}
				} else {
					$result .= $this->parse_statement();
					if ($this->token_ahead != PT_PAR_CLOSE) {
						$this->error = "Expected ')' at line ".$this->scanner->YYLINE;
					} else {
						$this->next_token();
						$result .= $this->token_value;
						$parseReturnValues = true;
					}
				}
			break;
		}	

		if ($parseReturnValues) {
				$i = 0;
				while (!$this->error &&	
							($this->token_ahead == PT_OBJECT_OPERATOR 
								|| $this->token_ahead == PT_BRACKET_OPEN
								|| $this->token_ahead == PT_PAR_OPEN)) {
					while (!$this->error && $this->token_ahead == PT_BRACKET_OPEN) {
						$result = "(!is_array(\$res$i = $result)) ? error('Not an array on line: '.__LINE__.' in file: '.__FILE__) : \$res$i".$this->parse_array_operator();
						$i++;
					}
					while (!$this->error && $this->token_ahead == PT_OBJECT_OPERATOR) {
						$result = "(!is_object(\$res$i = $result)) ? error('Not an object on line: '.__LINE__.' in file: '.__FILE__) : \$res$i".$this->parse_object_operator();
						$i++;
					}
					while (!$this->error && $this->token_ahead == PT_PAR_OPEN) {
						$result = "((\$res$i = $result) && false) ? error('Not a function on line: '.__LINE__.' in file: '.__FILE__) : \$this->{'_'.(\$res$i)}".$this->parse_func_call_args().$this->token_ahead_value;
						if ($this->token_ahead != PT_PAR_CLOSE) {
							$this->error = "Expected ')' at line: ".$this->scanner->YYLINE;
							return false;
						}
						$this->next_token();
						$i++;
					}
				}
		}
		return $result;
	}


	function parse_multipart_string() {
		$result = "\"";
		$this->next_token();
		do {
			switch($this->token_ahead) {
				case PT_SUBSTRING:
					$result .= $this->token_ahead_value;
				break;
				case PT_VARIABLE:
					$result .= $this->var_prefix.$this->token_ahead_value;
				break;
				case PT_ERROR:
					$this->error = $this->token_ahead_value;
				break;
				default:
			}
			$this->next_token();
		} while (!$this->error && $this->token_ahead!=PT_MULTIPART_STRING_END);
		$this->next_token();
		$result .= "\"";
		return $result;
	}

	function is_constant() {
		return ($this->token_ahead == PT_MULTIPART_STRING_START 
					|| $this->token_ahead == PT_STRING || $this->token_ahead == PT_NUMBER
						|| $this->token_ahead == PT_IDENT);
	}

	function parse_constant() {
		$result = "";
		switch ($this->token_ahead) {
			case PT_MULTIPART_STRING_START:
				$result = $this->parse_multipart_string();
			break;
			case PT_IDENT:
			case PT_NUMBER:
			case PT_STRING:
				$result = $this->token_ahead_value;
				$this->next_token();
			break;
			default:
				$this->error = "Expected a constant at line ".$this->scanner->YYLINE.", but found '".$this->token_ahead_value."'";
			break;
		}
		return $result;
	}

	function parse_statement() {
		$result = '';
		while (!$this->error && $this->token_ahead != PT_EOF) {
			switch ($this->token_ahead) {
				default:
					$expression = $this->parse_expression();
					if (!$expression) {
						break 2;
					} else {
						$result .= $expression;
					}
				break;
				case PT_STRING:
					$result .= $this->token_ahead_value;
					$this->next_token();
				break;
				case PT_ARRAY_OP:
					$result .= $this->token_ahead_value;
					$this->next_token();
				break;
				case PT_MULTIPART_STRING_START:
					$result .= $this->parse_multipart_string();
				break;
				case PT_OBJECT_OPERATOR:
					$result .= "->";
					$this->next_token();
				break;
				case PT_NUMBER:
				case PT_ASSIGN_OP:
				case PT_UNPARSED:
					$result .= $this->token_ahead_value;
					$this->next_token();
				break;
				case PT_END_STMT:
					$result .= $this->token_ahead_value;
					$this->next_token();
					return $result;
				break;
				case PT_COMMA:
				case PT_PAR_CLOSE:
					return $result;
				break;
			}
		}
		return $result;
	}

	function parse_statement_list() {
		$result = "";
		while (!$this->error && $this->token_ahead != PT_EOF) {
			switch ($this->token_ahead) {
				case PT_CBRACE_CLOSE:
					return $result;
				break;
				case PT_CBRACE_OPEN:
					$result .= $this->token_ahead_value;
					$this->next_token();
					$result .= $this->parse_statement_list();
					$result .= $this->token_ahead_value;
					$this->next_token();
				break;
				case PT_PINP_START:
					$result .= $this->token_ahead_value."<?php ";
					$this->in_pinp = true;
					$this->next_token();
				break;
				case PT_PINP_END:
					$result .= " ?>";
					$this->in_pinp = false;
					$this->next_token();
				break;
				case PT_RETURN:
					$ret_result = $this->token_ahead_value;
					$this->next_token();
					$ret_result .= $this->parse_statement();
					$result .= "{ $ret_result }";
					//NOTE(ORIGINAL): $result .= $ret_result;
				break;
				case PT_ERROR:
					$this->error = $this->token_ahead_value." at line ".$this->scanner->YYLINE;
				break;
				default:
					$statement = $this->parse_statement();
					if (!$statement && !$this->error) {
						$this->error = "Unexpected '".chop($this->token_ahead_value)."' at line ".$this->scanner->YYLINE;
					} else {
						$result .= $statement;
					}
				break;
			}
		}
		return $result;
	}

	function compile($template) {
		$this->scanner = new scanner();
		$this->scanner->init($template);
		$this->tokens = Array();
		$this->new_template = "";
		$this->in_pinp = false;
		$this->next_token();
		$this->new_template = $this->parse_statement_list();
		if (!$this->error && $this->in_pinp) {
			$this->error = "no closing pinp tag found";
		}
		if (!$this->error) {
			$this->syntax_test();
		}
		return $this->new_template;
	}

	function syntax_test() {
		$display_errors = ini_get("display_errors");
		ini_set("display_errors",1);
		$error_reporting = error_reporting(E_ERROR | E_PARSE);
		ob_start();
			$func = create_function('',' ?'.'>'.$this->new_template.'<'.'?php ');
			$result = ob_get_contents();
		ob_end_clean();
		error_reporting($error_reporting);
		ini_set("display_errors",$display_errors);

		if(empty($func)){
			$result	= strip_tags($result);
			$result	= trim($result);
			$first	= strpos($result,':');
			$last	= strrpos($result,':');

			$error	= trim(substr($result,0,$first));
			$reason	= trim(substr($result,$first+2,$last-($first+2)));
			$where	= trim(substr($result,$last+2));

			$linenr = substr($where,strrpos($where,' ')+1);
			// '^(.+) in /'
			ereg('^(.+) in /',$reason,$matches);

			$this->error = $error . ' : ' . $matches[1] . ' on line ' . $linenr;
		}

	}

}
?>