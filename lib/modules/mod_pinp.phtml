<?php
define("T_VARIABLE",		254);
define("T_STRING",			253);
define("T_SUBSTRING",		252);
define("T_IDENT",			251);
define("T_UNPARSED",		250);
define("T_EOF",				249);
define("T_MULTIPART_STRING_START",	248);
define("T_MULTIPART_STRING_END",	247);
define("T_PINP_START",		246);
define("T_PINP_END",		245);
define("T_ERROR",			244);
define("T_PAR_OPEN",		243);
define("T_NEW",				242);
define("T_FUNCTION",		241);
define("T_GLOBAL",			240);
define("T_RETURN",			239);
define("T_FILENAME",		238);
define("T_INCLUDE",			237);
define("T_INCLUDE_ONCE",	236);
define("T_REQUIRE",			235);
define("T_REQUIRE_ONCE",	234);

define("YY_STATE_HTML",			1);
define("YY_STATE_PINP",			2);

class scanner {

	function scanner() {
		/*
			create lookup table for language constructs
		*/
		$this->YYLANG_CONSTRUCTS = Array(
				"new" => T_NEW,
				"function" => T_FUNCTION,
				"global" => T_GLOBAL,
				"return" => T_RETURN,
				"__file__" => T_FILENAME,
				"include" => T_INCLUDE,
				"include_once" => T_INCLUDE_ONCE,
				"require" => T_REQUIRE,
				"require_once" => T_REQUIRE_ONCE
				);

		/*
			create character classes
		*/
		for ($c = ord('a'); $c <= ord('z'); $c++) {
			$cclass[chr($c)] = 1;
			$cclass[strtoupper(chr($c))] = 1;
		}
		$cclass["_"] = 1;
		$this->YYCLASSES["ID_FIRST"] = $cclass;

		$cclass_second = $cclass;
		for ($c = ord('0'); $c <= ord('9'); $c++) {
			$cclass_second[chr($c)] = 1;
		}
		$this->YYCLASSES["ID_SECOND"] = $cclass_second;

		$cclass_trailing["\n"] = 1;
		$cclass_trailing[" "] = 1;
		$this->YYCLASSES["ID_TRAILING"] = $cclass_trailing;

		$cclass['"'] = 1;
		$cclass["'"] = 1;
		$cclass['$'] = 1;
		$cclass['/'] = 1;
		$cclass['-'] = 1;
		$cclass['`'] = 1;
		$cclass['<'] = 1;
		$cclass['%'] = 1;
		$cclass['?'] = 1;
		$cclass['('] = 1;
		$cclass[chr(0)] = 1;
		$this->YYCLASSES["START_TRANSITION"] = $cclass;
	}

	function init($buffer) {
		$this->YYBUFFER = $buffer."\0";
		$this->YYLINE = 1;
		$this->YYSTATE = YY_STATE_HTML;
		$YYCURSOR = 0;
	}

	function scan(&$result) {
		$YYCURSOR = &$this->YYCURSOR;
		$YYBUFFER = &$this->YYBUFFER;
		$YYCLASSES = &$this->YYCLASSES;
		$YYCURSOR_START = $YYCURSOR;
		$YYSTATE = &$this->YYSTATE;

		$yych = $YYBUFFER[$YYCURSOR];
		switch ($YYSTATE) {
			case YY_STATE_HTML:
				//echo "HTML($yych)\n";
				if (ord($yych) == 0) {
					return T_EOF;
				} else {
					$matches='';
					$scan_buffer = substr($YYBUFFER, $YYCURSOR, -1);
					$re_code="^(.*)(<pinp>|<script[^>]+language[^>]*=[^>]*php[^>]*>|<[%?])";
					if (preg_match("!".$re_code."!Usi", $scan_buffer, $matches)) {
						$this->YYLINE += substr_count($matches[1], "\n");
						if ($matches[2]) {
							if (strtolower($matches[2]) === "<pinp>") {
								/* pinp tag found */
								$result = $matches[1];
								$YYCURSOR+=strlen($matches[0]);
								$YYSTATE = YY_STATE_PINP;
								return T_PINP_START;
							} else {
								/* php start tag found */
								$result = $matches[1];
								$YYCURSOR+=strlen($matches[0]);
								$result .= "<?php echo \"".str_replace('$', '\\$', AddCSlashes($matches[2], ARESCAPE))."\"; ?>";
								return T_UNPARSED;
							}
						} else {
							$result = $matches[1];
							$YYCURSOR+=strlen($matches[0]);
							return T_UNPARSED;
						}
					} else {
						$result = $scan_buffer;
						$YYCURSOR = strlen($YYBUFFER);
						return T_UNPARSED;
					}
				}
			break;
			case YY_STATE_PINP:
				//echo "PINP($yych)\n";
				switch($yych) {
					case '$': 
						$yych = $YYBUFFER[++$YYCURSOR];
						if ($YYCLASSES["ID_FIRST"][$yych]) {
							$yych = $YYBUFFER[++$YYCURSOR];
							while ($YYCLASSES["ID_SECOND"][$yych]) {
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							while ($YYCLASSES["ID_TRAILING"][$yych]) {
								$yych = $YYBUFFER[++$YYCURSOR];
							}
							$result = substr($YYBUFFER, $YYCURSOR_START+1, $YYCURSOR-$YYCURSOR_START-1);
							return T_VARIABLE;
						} else {
							$result = "single dollar sign";
							return T_ERROR;
						}
					break;

					case '%':
					case '?':
						$result = $yych;
						$yych = $YYBUFFER[++$YYCURSOR];
						if ($yych == '>') {
							$result = "php tags found at line: ".$this->YYLINE;
							return T_ERROR;
						} else {
							return T_UNPARSED;
						}
					break;

					case '<':
						$yych = $YYBUFFER[++$YYCURSOR];
						switch ($yych) {
							case '/':
								$yych = $YYBUFFER[++$YYCURSOR];
								while ($yych == ' ') {
									$yych = $YYBUFFER[++$YYCURSOR];
								} 
								$tag_element = "";
								while ($yych != ' ' && ord($yych)!==0 && $yych != '>') {
									$tag_element .= $yych;
									$yych = $YYBUFFER[++$YYCURSOR];
								}
								while (ord($yych)!==0 && $yych!='>') {
									$yych = $YYBUFFER[++$YYCURSOR];
								}
								if ($yych=='>') {
									++$YYCURSOR;
								}
								if ($tag_element == "pinp") {
									$result="";
									$YYSTATE = YY_STATE_HTML;
									return T_PINP_END;
								} else {
									$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
									return T_UNPARSED;
								}
							break;
							default:
								$result = "<";
							break;
						}
						return T_UNPARSED;
					break;					
					case '/':
						$yych = $YYBUFFER[++$YYCURSOR];
						switch ($yych) {
							case '/':
								$yych = $YYBUFFER[++$YYCURSOR];
								while ($yych != "\n" && ord($yych)!==0) {
									$yych = $YYBUFFER[++$YYCURSOR];
								}
								--$YYCURSOR;
								$result = "";
								return T_UNPARSED;
							break;
							case '*':
								$result="";
								$start_line = $this->YYLINE;
								$yych = $YYBUFFER[++$YYCURSOR];
								while (ord($yych)!==0) {
									if ($yych == "\n") {
										$this->YYLINE++;
										$result.="\n";
									}
									if ($yych == '*') {
										if  (($yych = $YYBUFFER[++$YYCURSOR]) == '/') {
											++$YYCURSOR;
											return T_UNPARSED;
										}
									} else {
										$yych = $YYBUFFER[++$YYCURSOR];
									}
								}
								$result = "unterminated comment, started at $start_line";
								return T_ERROR;
							break;
							default:
								$result = "/";
								return T_UNPARSED;
							break;
						}
					break;
					case 'a':
					case 'b':
					case 'c':
					case 'd':
					case 'e':
					case 'f':
					case 'g':
					case 'h':
					case 'i':
					case 'j':
					case 'k':
					case 'l':
					case 'm':
					case 'n':
					case 'o':
					case 'p':
					case 'q':
					case 'r':
					case 's':
					case 't':
					case 'u':
					case 'v':
					case 'w':
					case 'x':
					case 'y':
					case 'z':
					case 'A':
					case 'B':
					case 'C':
					case 'D':
					case 'E':
					case 'F':
					case 'G':
					case 'H':
					case 'I':
					case 'J':
					case 'K':
					case 'L':
					case 'M':
					case 'N':
					case 'O':
					case 'P':
					case 'Q':
					case 'R':
					case 'S':
					case 'T':
					case 'U':
					case 'V':
					case 'W':
					case 'X':
					case 'Y':
					case 'Z':
					case '_':
						/* Identifier */
						$yych = $YYBUFFER[++$YYCURSOR];
						while ($YYCLASSES["ID_SECOND"][$yych]) {
							$yych = $YYBUFFER[++$YYCURSOR];
						}
						while ($YYCLASSES["ID_TRAILING"][$yych]) {
							$yych = $YYBUFFER[++$YYCURSOR];
						}
						$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
						$construct = $this->YYLANG_CONSTRUCTS[chop(strtolower($result))];
						if ($construct) {
							return $construct;
						} else {
							return T_IDENT;
						}
					break;
					case ':':
						$yych = $YYBUFFER[++$YYCURSOR];
						switch ($yych) {
							case ':':
								$yych = $YYBUFFER[++$YYCURSOR];
								$result = "::";
								return T_CLASS_OPERATOR;
							break;
							default:
								$result = ":";
								return T_UNPARSED;
							break;
						}
						
					break;
					case '`':
						$result = "backtick encounterd at line ".$this->YYLINE;
						return T_ERROR;
					break;
					case '"':
						$start_line = $this->YYLINE;
						$multi_string = Array();
						$yych = $YYBUFFER[$YYCURSOR_START=++$YYCURSOR];
						while (ord($yych)!==0 && $yych != '"') {
							if ($yych == '\\') {
								++$YYCURSOR;
							} else
							if ($yych == "\n") {
								$this->YYLINE++;
								++$YYCURSOR;
							} else
							if ($yych == '$') {
								/*	
									push previous parsed string on stack
									if we've got one
								*/
								if ($YYCURSOR_START != $YYCURSOR) {
									$string=substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR - $YYCURSOR_START);
									array_push($multi_string, Array(T_SUBSTRING => $string));
									$YYCURSOR_START = $YYCURSOR;
								}
								$yych = $YYBUFFER[++$YYCURSOR];
								if ($YYCLASSES["ID_FIRST"][$yych]) {
									$yych = $YYBUFFER[++$YYCURSOR];
									while ($YYCLASSES["ID_SECOND"][$yych]) {
										$yych = $YYBUFFER[++$YYCURSOR];
									}
									while ($YYCLASSES["ID_TRAILING"][$yych]) {
										$yych = $YYBUFFER[++$YYCURSOR];
									}
									$string=substr($YYBUFFER, $YYCURSOR_START+1, $YYCURSOR - $YYCURSOR_START -1);	
									array_push($multi_string, Array(T_VARIABLE => $string));
									$YYCURSOR_START = $YYCURSOR;
									/* 
										token already read, so continue 'while'
										statement.
									*/
									continue;
								} else {
									$string=substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR - $YYCURSOR_START - 1);
									$YYCURSOR--;
									array_push($multi_string, Array(T_SUBSTRING => $string));
									$YYCURSOR_START=$YYCURSOR;
								}
							}
							$yych = $YYBUFFER[++$YYCURSOR];
						}
						if (ord($yych) != 0) {
							$YYCURSOR++;
							$string=substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR - $YYCURSOR_START - 1);

							array_push($multi_string, Array(T_SUBSTRING => $string));
							$result = $multi_string;
							return T_STRING;
						} else {
							$result = "unterminated quote, started at line $start_line";
							return T_ERROR;
						}
					break;
					case "'":
						$start_line = $this->YYLINE;
						$yych = $YYBUFFER[++$YYCURSOR];
						while ($yych != "'" && ord($yych)!==0) {
							if ($yych == '\\') {
								++$YYCURSOR;
							} else
							if ($yych == "\n") {
								$this->YYLINE++;
								++$YYCURSOR;
							}
							$yych = $YYBUFFER[++$YYCURSOR];
						}
						if (ord($yych)!==0) {
							$YYCURSOR++;
							$result=substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR - $YYCURSOR_START);
							return T_UNPARSED;
						} else {
							$result = "unterminated quote, started at line: $start_line";
							return T_ERROR;
						}
					break;
					case "-":
						if (($yych=$YYBUFFER[++$YYCURSOR])=='>') {
							++$YYCURSOR;
							return T_OBJECT_OPERATOR;
						} else {
							$result="-";
							return T_UNPARSED;
						}
					break;
					case "(":
						$result = "(";
						++$YYCURSOR;
						return T_PAR_OPEN;
					break;
					case "\0":
						return T_EOF;
					break;
					default:
						while (!$YYCLASSES["START_TRANSITION"][$yych]) {
							if ($yych == "\n") {
								$this->YYLINE++;
							}
							$yych = $YYBUFFER[++$YYCURSOR];
						}
						$result = substr($YYBUFFER, $YYCURSOR_START, $YYCURSOR-$YYCURSOR_START);
						return T_UNPARSED;
					break;
				}
			break;
		}
	}
}

class pinp {

	function pinp($allowed_functions, $var_prefix, $function_prefix="") {
		$var_prefix="\$".$var_prefix;
		if (!$function_prefix) {
			$function_prefix=$var_prefix;
		}
		if (is_array($allowed_functions)) {
			$allowed_functions=implode("|", $allowed_functions);
		}

		$this->var_prefix = $var_prefix;
		$this->function_prefix = $function_prefix;

		$array_funcs="|array|array_change_key_case|array_chunk|array_count_values|".
		  "array_diff|array_flip|array_fill|array_intersect|array_key_exists|array_keys|".
		  "array_merge|array_merge_recursive|array_multisort|array_pad|array_pop|".
		  "array_push|array_rand|array_reverse|array_shift|array_slice|array_splice|".
		  "array_sum|array_unique|array_unshift|array_values|arsort|asort|count|current|".
		  "each|end|in_array|array_search|key|krsort|ksort|list|natsort|natcasesort|".
		  "next|pos|prev|range|reset|rsort|shuffle|sizeof|sort|get_object_vars";
		$control_funcs="if|else|elseif|do|while|for|switch|foreach";
		$datetime_funcs="checkdate|date|getdate|gettimeofday|gmdate|gmmktime|".
	      "gmstrftime|localtime|microtime|mktime|strftime|time|strtotime|".
		  "easter_days|easter_date";
		$math_funcs="abs|acos|acosh|asin|asinh|atan|atanh|atan2|base_convert|bindec|ceil|cos|".
	      "cosh|decbin|dechex|decoct|deg2rad|exp|expm1|floor|getrandmax|hexdec|hypot|lcg_value|log|log10|log1p|max|min|".
	      "mt_rand|mt_srand|mt_getrandmax|number_format|octdec|pi|pow|rad2deg|rand|round|".
	      "sin|sinh|sqrt|srand|tan|tanh|bcadd|bccomp|bcdiv|bcmod|bcmul|bcpow|bcscale|bcsqrt|".
		  "bcsub|gmp_[a-z_]+";
		$misc_funcs="mail|highligh_string|pack|get_browser";
		$net_funcs="checkdnsrr|gethostbyaddr|gethostbyname|gethostbynamel|getmxrr|".
		  "getservbyport|getservbyname|ip2long|long2ip";
		$regex_funcs="ereg|ereg_replace|eregi|eregi_replace|split|spliti|preg_match|".
		  "preg_match_all|preg_split|preg_quote|preg_grep";
		$string_funcs="addslashes|addcslashes|bin2hex|chop|chr|chunk_split|".
		  "convert_cyr_string|count_chars|crc32|crypt|echo|explode|flush|".
		  "get_html_translation_table|htmlentities|htmlspecialchars|implode|join|".
		  "levenshtein|localeconv|ltrim|md5|metaphone|nl2br|ord|print|printf|".
		  "quoted_printable_decode|quotemeta|rawurldecode|rawurlencode|rtrim|str_rot13|".
	      "sscanf|setlocale|similar_text|soundex|sprintf|strncasecmp|strcasecmp|strchr|".
		  "strcmp|strcoll|strcspn|strip_tags|stripcslashes|stripslashes|stristr|strlen|".
		  "strnatcmp|strnatcasecmp|strncmp|str_pad|strpos|strrchr|str_repeat|strrev|".
		  "strrpos|strspn|strstr|strtok|strtolower|strtoupper|str_replace|strtr|substr|".
		  "substr_count|substr_replace|trim|ucfirst|ucwords|vprintf|vsprintf|wordwrap|".
		  "base64_decode|base64_encode|urldecode|urlencode|parse_url";
		$var_funcs="doubleval|empty|floatval|gettype|intval|is_array|is_bool|is_double|".
		  "is_float|is_int|is_integer|is_long|is_null|is_numeric|is_object|is_real|".
		  "is_resource|is_scalar|is_string|isset|settype|serialize|strval|unserialize|".
		  "unset|print_r|var_dump|var_export";
		$xml_funcs="xmldoc|xmltree|domxml_[a-z_]+|xpath_[a-z_]+|xptr_[a-z_]+|".
		  "xml_parser_create|xml_parse_into_struct|xml_parser_free|".
		  "xml_parser_get_option|xml_parser_set_option";
		$debug_funcs="debug|debugon|debugoff";
		$loader_funcs="ldheader|ldredirect|ldsetcontent|ldsetclientcache|ldgetusercookie|ldsetusercookie|ldgetclientvar|ldregisterfile"; 
		$ob_funcs="flush|ob_clean|ob_end_clean|ob_end_flush|ob_flush|ob_get_contents|ob_get_length|ob_get_level|ob_implicit_flush|ob_start";
		$this->allowed_functions=array_flip(explode("|", "$array_funcs|$control_funcs|$datetime_funcs|$math_funcs|".
		  "$misc_funcs|$net_funcs|$regex_funcs|$string_funcs|$var_funcs|$xml_funcs|".
		  "$allowed_functions|$debug_funcs|$loader_funcs|$ob_funcs|"));

	}

	function next_token() {
		$value="";
		if (count($this->tokens) == 0) {
			$token = $this->scanner->scan($value);
			if (is_array($value)) {
				$this->tokens = $value;
				$token = T_MULTIPART_STRING_START;
				array_push($this->tokens, Array( T_MULTIPART_STRING_END => 1 ));
			} else {
				$token = $token;
				$token_value = $value;
			}
		} else {
			list($token, $token_value) = each(array_shift($this->tokens));
		}
		if ($this->token_ahead) {
			$this->token = $this->token_ahead;
			$this->token_value = $this->token_ahead_value;
		}
		$this->token_ahead = $token;
		$this->token_ahead_value = $token_value;
	}

	/*
		parse_variable()
		$foo			:	$this->foo
		$foo->bar		:	$this->foo->bar
		$foo->bar()		:	$this->foo->_bar()
	*/
	function parse_variable() {
		$result = $this->var_prefix.$this->token_ahead_value;
		$this->next_token();

		if ($this->token_ahead == T_PAR_OPEN) {
			$this->error = "illegal function call (\$".$this->token_value."()) at line ".$this->scanner->YYLINE;
		}

		while (!$this->error && $this->token_ahead == T_OBJECT_OPERATOR) {
			$this->next_token();
			$result .= "->";
			if ($this->token_ahead != T_IDENT) {
				$this->error = "expected variable name following ($result) at line ".$this->scanner->YYLINE;
			} else {
				$this->next_token();
				if ($this->token_ahead == T_PAR_OPEN) {
					$result .= "_".$this->token_value."(";
					$this->next_token();
				} else {
					$result .= $this->token_value;
				}
			}
		}

		return $result;
	}


	/*
		parse_ident()
		foo			:	foo
		foo::bar	:	pinp_foo::_bar
		foo()		:	foo() else $this->_foo()
	*/
	function parse_ident() {
		$this->next_token();
		switch ($this->token_ahead) {
			case T_PAR_OPEN:
				if (!$this->allowed_functions[chop(strtolower($this->token_value))]) {
					$result = $this->function_prefix.$this->token_value."(";
				} else {
					$result = $this->token_value."(";
				}
				$this->next_token();
			break;
			case T_CLASS_OPERATOR:
				$result = "pinp_".$this->token_value."::";
				$this->next_token();
				if ($this->token_ahead != T_IDENT) {
					$this->error = "execting an identifier following ($result) at line ".$this->scanner->YYLINE;
				} else {
					$this->next_token();
					$result .= "_".$this->token_value;
				}
			break;
			default:
				$result = $this->token_value;
			break;
		}

		return $result;
	}

	function compile($template) {
		$this->scanner = new scanner();
		$this->scanner->init($template);
		$this->tokens = Array();
		$this->new_template = "";
		$this->in_pinp = false;
		$this->next_token();
		while (!$this->error && $this->token_ahead != T_EOF) {
			switch ($this->token_ahead) {
				case T_PINP_START:
					$this->new_template .= $this->token_ahead_value."<?php ";
					$this->in_pinp = true;
					$this->next_token();
				break;
				case T_PINP_END:
					$this->new_template .= " ?>";
					$this->in_pinp = false;
					$this->next_token();
				break;
				case T_VARIABLE:
					$this->new_template .= $this->parse_variable();
				break;
				case T_STRING:
					$this->new_template .= $this->token_ahead_value;
					$this->next_token();
				break;
				case T_MULTIPART_STRING_START:
					$this->new_template.="\"";
					$this->next_token();
					do {
						switch($this->token_ahead) {
							case T_SUBSTRING:
								$this->new_template .= $this->token_ahead_value;
							break;
							case T_VARIABLE:
								$this->new_template .= $this->var_prefix.$this->token_ahead_value;
							break;
							case T_ERROR:
								$this->error = $this->token_ahead_value;
							break;
							default:
						}
						$this->next_token();
					} while (!$this->error && $this->token_ahead!=T_MULTIPART_STRING_END);
					$this->next_token();
					$this->new_template .= "\"";
				break;
				case T_OBJECT_OPERATOR:
					$this->new_template .= "->";
					$this->next_token();
				break;
				case T_UNPARSED:
					$this->new_template .= $this->token_ahead_value;
					$this->next_token();
				break;
				case T_IDENT:
					$this->new_template .= $this->parse_ident();
				break;
				case T_PAR_OPEN:
					$this->new_template.="(";
					$this->next_token();
				break;
				case T_ERROR:
					$this->error = $this->token_ahead_value." at line ".$this->scanner->YYLINE;
				break;
				default:
					$this->error = "illegal or unkown construct (".$this->token_ahead_value.") at line ".$this->scanner->YYLINE;
				break;
			}
		}

		if (!$this->error && $this->in_pinp) {
			$this->error = "no closing pinp tag found";
		}
		return $this->new_template;
	}
}
?>