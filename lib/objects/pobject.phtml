<?php

debug("pobject: Load","object");

class pobject extends object { 

	var $store;	
	var $path;
	var $data;  

	function init(&$store, &$path, &$data) {
		debug("pobject: init([store], $path, [data])","object");
		$this->store=&$store;
		$this->path=&$path;
		$this->data=&$data;
	}

	function call($arCallFunction="view.html", $arCallArgs="") {
	/***********************************************************************
	  call tries to find the template ($arCallFunction) for the current
	  object. If it is not defined there, call will search the superclasses
	  until either it or the template 'default.phtml' is found.

	  $arCallFunction must be the name of a class or object template.
	    it can be prepended with "{classname}::". classname must be either
	    a valid ariadne class (derived from pobject). call() 
	    will then try to find the template starting at the given classname.
		e.g.:
		call("pobject::view.html") will show the view.html template of
	      pobject, with the data of the current object.

	  variables available to templates:
	  local: arCallFunction, arCallArgs, arCallTemplate, data
	  global: AR, ARConfig, ARCurrent, ARBeenHere, ARnls
	***********************************************************************/
	global $AR, $ARConfig, $ARCurrent, $ARBeenHere, $ARnls;

		debug("pobject: ".$this->path.": call($arCallFunction, ".serialize($arCallArgs).")","object","IN");
		// callstack is needed for getvar()
		$ARCurrent->arCallStack[]=$arCallArgs;
		if (is_string($arCallArgs)) {
			Parse_str($arCallArgs);
		} else if (is_array($arCallArgs)) {
			extract($arCallArgs);
		}
		// now find the initial nls selection (CheckConfig is needed for per
		// tree selected defaults)
		if ($ARCurrent->nls) { 
			$this->reqnls=$ARCurrent->nls; 
		} else { 
			$this->reqnls=$AR->nls->default; 
		}
		if (isset($this->data->nls->list[$this->reqnls]) || !isset($this->data->nls)) {  
			// the requested language is available
			$this->nls=$this->reqnls;
			$nls=&$this->nls;
		} else {
			// the requested language is not available, use default of the
			// current object instead.
			$this->nls=$this->data->nls->default;
			$nls=&$this->nls;
			$flag=" <img class=\"flag\" src=\"".$AR->dir->images."nls/small/$nls.gif\" alt=\"\" border=\"0\"> ";
		}
		if ($this->data->$nls) {
			// now set the data and nlsdata pointers
			$this->nlsdata=$this->data->$nls;
			$nlsdata=&$this->nlsdata;
			$data=&$this->data;
		} else {
			// this object doesn't support nls data
			$this->nlsdata=$this->data;
			$nlsdata=&$this->data;
			$data=&$this->data;
		} 
		if ($this->data->customdata['none']) {
			$customdata=&$this->data->customdata['none'];
		}
		if ($this->data->customdata[$nls]) {
			$customnlsdata=&$this->data->customdata[$nls];
		}
		debug("pobject: call: nls set to $nls","all"); 
		
		if (strpos($arCallFunction,"::")!==false) {
			// template of a specific class defined via call("class::template");
			list($arType, $arCallFunction)=explode("::",$arCallFunction);
		} else {
			$arType=$this->type;
		}
		while ($arType!="object") {
			debug("class: $arType","object");
			// search for the template, stop at the root class ('object')
			// (this should not happen, as pobject must have a 'default.phtml')
			$arCallTemplate=$this->store->code."templates/".$arType."/".$arCallFunction;
			if (file_exists($arCallTemplate)) {
				// template found
				debug("pobject::call template($arCallTemplate)", "all");
				include($arCallTemplate);
				debug("pobject::call end template", "all");
				break;
			} else if (file_exists($this->store->code."templates/".$arType."/default.phtml")) {
				// template not found, but we did find a 'default.phtml'
				debug("pobject::call $arType/default.phtml", "all");
				include($this->store->code."templates/".$arType."/default.phtml");
				break;
			} else {
				// no template found, no default.phtml found, try superclass.
				if (!class_exists($arType)) {
					// the given class was not yet loaded, so do that now
					include_once($this->store->code."objects/".$arType.".phtml");
				}
				$arTemp=new $arType();
				$arType=get_parent_class($arTemp);
				debug("try superclass: $arType","object");
			}
		}
		array_pop($ARCurrent->arCallStack);
		debug("pobject: call: end","all","OUT");
		if (isset($ARCurrent->arResult)) {
			// pinp templates can return results via putvar("arResult",$result);
			$arResult=$ARCurrent->arResult;
			$ARCurrent->arResult=false;
		}
		if (isset($arResult)) {
			// only do a return if we really have something to return
			return $arResult;
		}
	}

	function ls($path="", $function="list.html", $args="") {
		debug("pobject: ls($path, $function, $args)","object");
		$path=$this->store->make_path($this->path, $path);
		return $this->store->call($function, $args, $this->store->ls($path));
	}

	function get($path, $function="view.html", $args="") {
		debug("pobject: get($path, $function, $args)","object");
		$path=$this->store->make_path($this->path, $path);
		return $this->store->call($function, $args, $this->store->get($path));
	}

	function parents($path, $function="list.html", $args="", $top="/") {
		debug("pobject: parents($path, $function, $args)","object");
		$path=$this->store->make_path($this->path, $path);
		return $this->store->call($function, $args, $this->store->parents($path, $top));
	}

	function find($path, $criteria, $function="list.html", $args="", $limit=100, $offset=0) {
		debug("pobject: find($path, [crit], $function, $args)","object");
		$path=$this->store->make_path($this->path, $path);
		return $this->store->call($function, $args, $this->store->find($path, $criteria, $limit, $offset));
	}


	function save($properties="", $vtype="") {
	/***********************************************************************
	  save the current object.
	  if this is a new object ($this->arIsNewObject) the path is checked and
	  the object is saved under the new path.
	***********************************************************************/
	global $AR, $ARConfig;
		debug("pobject: save([properties], $vtype)","object");
		debug("pobject: save: path=".$this->path,"object");
		$result=false;
		if ($this->arIsNewObject) { // save a new object
			debug("pobject: save: new object","all");
			$arNewParent=$this->make_path("..");
			$arNewFilename=substr($this->path, strlen($arNewParent), -1);
			if (!eregi("\.\.",$arNewFilename)) {
				if (eregi("^[a-z0-9_\{\}\.\:-]+$",$arNewFilename)) { // no "/" allowed, these will void the 'add' grant check.
					if (!$this->exists($this->path)) { //arNewFilename)) {
						if ($this->exists($arNewParent)) {
							$this->data->ctime=time();
							$this->data->mtime=$this->data->ctime;
							$this->data->owner_name=$AR->user->data->name;
							$this->data->owner=$AR->user->data->login;
							$customdata=$this->getdata("customdata","none");
							@parse_str($customdata);
							$this->data->customdata=$customdata;
							/* 	FIXME! add properties in install.
								$properties["time"][0]["ctime"]=$this->data->ctime;
								$properties["time"][0]["mtime"]=$this->data->mtime;
								$properties["owner"][0]["value"]=$this->data->owner;
								$i=0;
								while (list($nls, $cdata)=each($this->data->custom)) {
									while (list($name, $value)=each($cdata)) {
										// one index, this order (name, value, nls) ?
										$properties["custom"][$i]["name"]="'".AddSlashes($name)."'";
										$properties["custom"][$i]["value"]="'".AddSlashes($value)."'";
										$properties["custom"][$i]["nls"]="'".AddSlashes($nls)."'";
									}
								}
							*/
							$this->path=$this->store->save($this->path, $this->type, $this->data, $properties, $vtype, $this->priority);
							$this->id=$this->exists($this->path);
							$result=$this->path;
						} else {
							$this->error="parent $arNewParent doesn't exist.";
						}
					} else {
						$this->error="$arNewFilename already exists.";
					}
				} else {
					$this->error="$arNewFilename is no valid filename, use only a-z, A-Z, 0-9 and _ or -.";					
				}
			} else {
				$this->error="$arNewFilename is no valid filename, do not use '..' in filenames.";
			}
		} else { // update an existing object
			debug("pobject: save: existing object","all");
			if ($this->lock()) {
				if ($this->exists($this->path)) { // prevent 'funny stuff'
					$this->data->mtime=time();
					// $properties["time"]["mtime"]=$this->data->mtime;
					$customdata=$this->getdata("customdata","none");
					@parse_str($customdata);
					$this->data->customdata=$customdata;
					$this->path=$this->store->save($this->path, $this->type, $this->data, $properties, $vtype, $this->priority);
					$result=$this->path;
					$this->ClearCache();
					$this->unlock();
				} else {
					$this->error="Path is corrupt, won't save the object.";
				}
			} else {
				$this->error="Object already locked.";
			}
		}
		if ($this->data->nls->list[$this->nls]) {
			$this->nlsdata=$this->data->{$this->nls};
		} else {
			$this->nlsdata=$this->data->{$this->data->nls->default};
		}
		debug("pobject: save: end","all");
		return $result;
	}

	function link($to) {
		debug("pobject: link({$this->path} => $to)","object");
		return $this->store->link($this->path, $this->make_path($to));
	}

	function delete() {
		debug("pobject: delete({$this->path})","object");
		return $this->store->delete($this->path);
	}

	function purge() {
		debug("pobject: purge({$this->path})","object");
		return $this->store->purge($this->path);
	}

	function exists($path) {
		debug("pobject: exists($path)","object");
		$path=$this->make_path($path);
		return $this->store->exists($path);
	}

	function make_path($path="") {
		debug("pobject: make_path($path)","object");
		return $this->store->make_path($this->path, $path);
	}

	function make_url($path="") {
		/* FIXME:
		   make_url should first try to make relative links, instead
		   of full absolute urls
		   if the path corresponds with the same root as the current object
		   that should be possible, just find the common root, and add ".."
		   to it for each directory of the current object from that root, 
		   then add the rest of the path of the image.
		*/
		global $ARConfig;
		debug("pobject: make_url($path) (from: ".$this->path.")","object");
		$object_path=$this->path;
		$path=$this->make_path($path);
		while ($object_path && !$url) {
			$config=$ARConfig->cache[$object_path];
			if (!$config) {
				$config=$ARConfig->cache[".."];
			}
			$rootpath=$config->root["path"];
			if (substr($path, 0, strlen($rootpath))==$rootpath) {
				debug("make_url: root from '$rootpath' = ".$config->root["value"].$this->store->rootoptions,"all");
				$path=substr($path, strlen($rootpath)-1);
				$url=$config->root["value"].$this->store->rootoptions.$path;
			} else {
				// jump to cache information of the parent of $rootpath
				$object_path=substr($rootpath, 0, strrpos(substr($rootpath, 0, -1),'/')+1);
				debug("make_url: no root from '$rootpath', jump to '$object_path'","all");
			}
		}
		debug("url: $url",'all');
		return $url;			
	}

	function implements($implements) {
		debug("pobject: implements($implements)","object");
		return $this->store->implements($this->type, $implements); 
	}

	function getlocks() {
		global $AR;
		debug("pobject: getlocks()","object");
		if ($this->store->mod_lock) {
			$result=$this->store->mod_lock->getlocks($AR->user->data->login);
		} else {
			$result="";
		}
		return $result;
	}

	function lock($mode="O", $time=0) {
	global $AR;
		debug("pobject: lock($mode, $time)","object");
		if ($this->store->mod_lock) {
			$result=$this->store->mod_lock->lock($AR->user->data->login,$this->path,$mode,$time);
		} else {
			$result=true; // no lock module, so lock is 'set'
		}
		return $result;
	}

	function unlock() {
	global $AR;
		debug("pobject: unlock()","object");
		if ($this->store->mod_lock) {
			$result=$this->store->mod_lock->unlock($AR->user->data->login,$this->path);
		} else {
			$result=true;
		}
		return $result;
	}


	function load_properties() {
		debug("pobject: load_properties()","object");
		return $this->store->load_properties($this->id);
	}

	function load_property($property) {
		debug("pobject: load_property($property)","object");
		return $this->store->load_property($this->id,$property);
	}

	function GetValidGrants() {
	/********************************************************************

	  This function finds all grants in effect on this object for the
	  logged in user! $AR->user must already be set.
	
	  Grants are checked in the following way:
	  1) First all parents of this object are checked for grants for this
	     specific user. The 'nearest' grants are valid, and the path of
	     parent that set these grants will be the upper limit for the 
	     checking of group grants.
	  2) Now all groups of which the user is a member are checked for
	     grants. Likewise, all parents are checked for group grants, upto 
	     but not including the upperlimit as set in 1. All group grants 
	     found are merged into one grants list. 
	  3) If there are gropup grants, this means that there are group 
	     grants set in a parent nearer to this object than the user grants
	     and therefore the groupgrants must be merged with the
	     usergrants.
	
	  this results in:
	  1	/		user: read edit		group: none
	  2	/dir/					group: read
	  3	/dir2/		user: none		group: read
	  4	/dir/dir3/				group2: edit
	  case 1: the user takes precedence over the group, grants are 'read edit'
	  case 2: groupgrants are merged with usergrants, as its grants are set 
	          in a 'nearer' parent (itself). grants are 'read edit'.
	  case 3: user takes precedence again. grants are 'none'.
	  case 4: All group grants are merged with the usergrants.
	          Therefore the grants are 'none read edit'.
	********************************************************************/

	global $AR;

		debug("pobject: GetValidGrants()","object");
		if ($AR->user) { 	// login and retrieval of user object 
			if (!$AR->user->grants[$this->path]) {
				$grants=Array();
				$userpath=$AR->user->FindGrants($this->path, $grants);
				// if not already done, find all groups of which the user is a member
				$criteria["members"]["login"]["="]="'".AddSlashes($AR->user->data->login)."'";
				if ($AR->user->groups || ($AR->user->groups=$this->find("/system/groups/",$criteria, "system.get.phtml"))) {
					// $path=end($paths);
					reset($AR->user->groups);
					while (list($key, $group)=each($AR->user->groups)) { 
						$group->FindGrants($this->path, $grants, $userpath);
					}
				}
				$AR->user->grants[$this->path]=$grants;
			}
			$grants=$AR->user->grants[$this->path];	
		}
		debug("pobject: GetValidGrants: end ( ".serialize($grants)." )","all");
		return $grants;
	}

	function CheckLogin($grant, $modifier=ARTHISTYPE) {
	global $AR,$ARnls,$ARCurrent,$ARLogin,$ARPassword,$ARCookie,$session_config;
		debug("pobject: CheckLogin($grant)","object");
		if ($modifier==ARTHISTYPE) {
			$modifier=$this->type;
		}
		// check for a sessionid
		$silent=($AR->user) ? 1:0;
		$continue=true;
		if (!$AR->user) {
			if (!$ARCurrent->session || !$ARCurrent->session->get("ARLogin")) {
				$ARLogin="public"; $ARPassword="none";
				debug("pobject: CheckLogin: use public","object");
			} else {
				if (!ldCheckCredentials($ARCurrent->session->get("ARLogin"), $ARCurrent->session->get("ARPassword"))) {
					$ARLogin="public"; $ARPassword="none";
					// default fallback is 'public'.
					$fallback=true;
				} else {
					$ARLogin=$ARCurrent->session->get("ARLogin");
					$ARPassword=$ARCurrent->session->get("ARPassword");
				}
			}

			if ($continue) {
				// check password
				$criteria["login"]["value"]["="]="'".AddSlashes($ARLogin)."'";
				$result=@current($this->find("/system/users/",$criteria,"system.get.phtml"));
				unset($criteria);	
				if (!($AR->user=$result)) {
					debug("pobject: CheckLogin: user in cookie not found","object");
					if (!$silent) {
						$arLoginMessage=$ARnls["accessdenied"].": ".sprintf($ARnls["userunknown"],$ARLogin);
						$this->call("user.login.html",compact("arLoginMessage"));
					}
					$continue=false;
				} else if (!$AR->user->CheckPassword($ARPassword)) {
					debug("pobject: CheckLogin: wrong password in cookie","object");
					if (!$silent) {
						$arLoginMessage=$ARnls["accessdenied"].": ".$ARnls["passwordincorrect"];
						$this->call("user.login.html",compact("arLoginMessage"));
					}
					$continue=false;
				} else {
					debug("pobject: CheckLogin: got user ".$result->data->name,"all");
				}
			}
		}
		if ($continue) {
			if ($AR->user->data->login!="admin" && !$AR->user->grants[$this->path]) {
				$AR->user->grants[$this->path]=$this->GetValidGrants();
			}
			if ($AR->user->data->login!="public") {
				// Don't remove this or MSIE users won't get uptodate pages...
				ldSetClientCache(false);
			}
			$grants=$AR->user->grants[$this->path];
			if ( 	( !$grants[$grant] 
						|| ( $modifier && is_array($grants[$grant]) && !$grants[$grant][$modifier] )
					) && $ARLogin!="admin" ) {
				// do login
				debug("pobject: CheckLogin: insufficient grants ($ARLogin)","object");
				if (!$silent) {
					if ($ARLogin!="public") {
						$args=Array( "arLoginMessage" => $ARnls["accessdenied"]);
					} else if ($fallback) {
						$args=Array( "arLoginMessage" => $ARnls["accessdenied"].": ".$ARnls["q:cookiesenabled"]);
					}
					$this->call("user.login.html", $args);
				}
				$continue=false;
			}
		}
		$ARPassword=0;
		if ($continue) {
			debug("pobject: CheckLogin: end","all");
			$result=($grants || ($ARLogin=="admin"));
		} else {
			$result=false;
			debug("pobject: CheckLogin: end (failed)","all");
		}
		return $result;
	}

	function CheckSilent($grant, $modifier=ARTHISTYPE) {
	global $AR;

		debug("pobject: CheckSilent($grant)","object");
		if ($modifier==ARTHISTYPE) {
			$modifier=$this->type;
		}
		$result=false;
		if ($AR->user->data->login=="admin") {
			$result=1;
		} else if ($grants=$AR->user->grants[$this->path]) {
			$result=$grants[$grant];
		} else {
			$grants=$this->GetValidGrants();
			$result=$grants[$grant];
		}
		if ($modifier && is_array($result)) {
			$result=$result[$modifier];
		}
		debug("pobject: CheckSilent: end","all");
		return $result;
	}

	function CheckNewFile($newfilename) {
	/**********************************************************************

	  This function performs all the necessary checks on a path to see
	whether it's a valid path for a new object. This consists of:
	1) checking for invalid characters, valid chars are "a-zA-Z0-9./_-"
	2) checking whether the path starts and ends with a "/".
	3) checking whether the path doesn't exist already.
	4) checking whether the parent exists.
	
	if all this checks out, it returns 1. If not, $this->error is set to
	the correct error message.
	
	**********************************************************************/

		debug("pobject: CheckNewFilename($newfilename)","object");
		$this->error="";
		if (eregi("^/[a-z0-9\./_-]*/$",$newfilename)) {
			if (!$this->store->exists($newfilename)) {
				$parent=$this->store->make_path($newfilename, "..");
				if ($this->store->exists($parent)) {
					$result=1;
				} else {
					$this->error="$newfilename is invalid: $parent does not exist.";
				}
			} else {
				$this->error="$newfilename already exists. Please choose another.";
			}
		} else {
			$this->error="Filenames may consist of normal charachters ".
				"(a-z, A-Z, 0-9) and '-','_' or '/'. A path must start and end ".
				"with a '/'.";
		}
		debug("pobject: CheckNewFilename: end","all");
		return $result;
	}

	function CheckConfig($arCallFunction="", $arCallArgs="") {
	// returns true when cache isn't up to date and no other template is
	// defined for $path/$function. Else it takes care of output to the
	// browser.
	// All these templates must exist under a fixed directory, $AR->dir->templates
	global $nocache, $AR, $ARConfig, $ARCurrent, $ARBeenHere, $ARnls, $HTTP_POST_VARS, $HTTP_GET_VARS;
	static $arContentTypeSent = false;
	
		debug("pobject::CheckConfig($arCallFunction, $arCallArgs)","object");
		$MAX_LOOP_COUNT=10;
		if ($ARBeenHere[$this->path][$arCallFunction]<$MAX_LOOP_COUNT) { // protect against infinite loops
			$ARBeenHere[$this->path][$arCallFunction]+=1;
			if (!$ARConfig->cache[$this->path]) {
				$this->call("system.get.config.phtml");
			}
			$config=$ARConfig->cache[$this->path];
			$ARConfig->nls=$config->nls;
			// if a default language is entered in a parent and no language is
			// explicitly selected in the url, use that default. 
			// The root starts with the system default (ariadne.phtml config file)
			if ($config->nls->default && !$ARCurrent->nls) {
				$this->reqnls=$config->nls->default;
				$this->nls=$this->reqnls;
			}
			$nls=&$this->nls;
			$reqnls=&$this->reqnls;
			// if this object isn't available in the requested language, show
			// a language select dialog with all available languages for this object.
			if (isset($this->data->nls)) {
				if (!isset($this->data->nls->list[$reqnls]) || !$config->nls->list[$reqnls]) {
					if (!$ARCurrent->nolangcheck ) {
						include($this->store->code."widgets/nls/languageselect.phtml");
						return false;
					} else {
						$this->nlsdata=$this->data->$nls;
					}
				} else {
					$this->nlsdata=$this->data->$reqnls;
				}
			} 
			if ($this->data->customdata['none']) {
				$this->customdata=&$this->data->customdata['none'];
			}
			if ($this->data->customdata[$nls]) {
				$this->customnlsdata=&$this->data->customdata[$nls];
			}
			$ARCurrent->nolangcheck=1;
			if (	(	$config->cache && ( $config->cache>0 )		) &&
					( 	!$nocache 									) && 
					( 	$AR->user->data->login=="public" 			) &&
					(	$AR->OS=="UNIX" || 
						( 	(count($HTTP_POST_VARS)==0) && 
							(count($HTTP_GET_VARS)==0) 			) 	) 	) {
				// caching is on and enabled in loader and user is public.
				$ARCurrent->cachetime=$config->cache;
				// start output buffering...	
				debug("CheckConfig: ob_start()","all");
				ob_start();
			} else {
				debug("CheckConfig: caching disabled","all");
				debug("             config->cache: ".$config->cache."; nocache: ".$nocache."; user: ".$AR->user->data->login."; os: ".$AR->OS,"all");
			}
			$nocache=true; // make sure no other parts are cached either;
			if (!$arContentTypeSent) {
				if ($AR->nls->charsets[$nls]) {
					ldHeader("Content-Type: text/html; charset=".$AR->nls->charsets[$nls]);
				} else {
					ldHeader("Content-Type: text/html; charset=".$AR->nls->charsets["default"]);
				}
				$arContentTypeSent = true;
			}

			if ($this->data->pinp[$this->type][$arCallFunction][$this->nls]) {
				$config->templates[$this->type][$arCallFunction][$this->nls]=$this->data->pinp[$this->type][$arCallFunction][$this->nls];
			} else if ($this->data->pinp[$this->type][$arCallFunction]['any']) {
				$config->templates[$this->type][$arCallFunction]['any']=$this->data->pinp[$this->type][$arCallFunction]['any'];
			}
			$arType=get_class($this);
			while ($arType && !$arCallTemplate) {
				if ($arTemplateId=$config->templates[$arType][$arCallFunction][$this->nls]) {
					$arCallTemplate=$arType.".".$arCallFunction.".".$this->nls;
				} else if ($arTemplateId=$config->templates[$arType][$arCallFunction]['any']) {
					$arCallTemplate=$arType.".".$arCallFunction.".any";
				} else {
					$arTemp=new $arType();
					$arType=get_parent_class($arTemp);
				}
			}
			if ($arCallTemplate && $arTemplateId) {
				debug("CheckConfig: arCallTemplate=$arCallTemplate, arTemplateId=$arTemplateId","object");
				// $arCallTemplate=$this->store->files."templates".$arCallTemplate;
				// check if template exists, if it doesn't exist, then continue the original template that called CheckConfig
				$arTemplates=$this->store->get_filestore("templates");
				if ($arTemplates->exists($arTemplateId, $arCallTemplate)) { 
					debug("CheckConfig: $arCallTemplate exists","object");
					// check if the requested language exists, if not do not display anything, 
					// unless otherwise indicated by $ARCurrent->allnls
					// This triggers only for pinp templates called by other templates,
					// as the first template (in the url) will first trigger the language
					// choice dialogue instead.
					$ARCurrent->arCallStack[]=$arCallArgs;
					if (isset($this->data->nls->list[$reqnls])) {
						// the requested language is available.
						$this->nlsdata=$this->data->$nls;
						$continue=true;
					} else if (!isset($this->data->nls)) {
						debug("pobject: CheckConfig: no nls data ","all");
						// the object has no language support
						$this->nlsdata=&$this->data;
						$continue=true;
					} else if ($ARCurrent->allnls) {
						debug("pobject: CheckConfig: no $reqnls, but allnls set","all");
						// all objects must be displayed
						// $this->reqnls=$this->nls; // set requested nls, for checks
						$this->nls=$this->data->nls->default;
						$this->nlsdata=$this->data->$nls;
						$continue=true;
					} else {
						// requested language not available, allnls not set
						// -> skip this object (do not run template but do return false)
						$continue=false;
					}
					if ($continue) {
						$arTemplates->import($arTemplateId, $arCallTemplate, "",$this);
					}
					array_pop($ARCurrent->arCallStack);
					return false;
				} else {
					debug("pobject: CheckConfig: no such file: $arCallTemplate","all");
				}
			} else {
				debug("CheckConfig: no arCallTemplate","object");
			}
		} else {
			error("Max loop count exceeded in ".$this->path.$arCallFunction."?".$arCallArgs);
			$this->store->close();
			exit();
		}
		debug("pobject: CheckConfig: end","all");
		return true;
	}

	function MkDir($dir) {
		debug("pobject: MkDir($dir)","object");
		return ldMkDir($dir);
	}

	function SetCache($file, $time, $image, $headers) {
		ldSetCache($file, $time, $image, $headers);
	}

	function ClearCache($path="",$private=true) {
	global $AR;
 
		debug("pobject: ClearCache($path)","object");
		if (!$path) { $path=$this->path; }
		$nlslist=$AR->nls->list;
		$nlslist["."]="default";
		while (list($nls,$language)=each($nlslist)) {
			$fpath=$this->store->files."cache/$nls/".$path;
			$hpath=$this->store->files."cacheheaders/$nls/".$path;
			if ($dir=@dir($fpath)) {
				while ($entry=$dir->read()) {
					if ($entry!="." && $entry!="..") {
						if (filetype($fpath.$entry)!="dir") {
							@unlink($fpath.$entry);
							@unlink($hpath.$entry);
						} else if ($entry!="." && $entry!="..") {
							$this->ClearCache($path.$entry."/", false);
						}
					}
				}
			} else if (file_exists(substr($fpath,0,-1)."=")) {
				@unlink(substr($fpath,0,-1)."=");
				@unlink(substr($hpath,0,-1)."=");
			}
		}
		if ($private) {
			// now remove any private cache entries.
			// FIXME: this doesn't scale very well.
			//        only scalable solution is storage in a database
			//        but it will need the original path info to
			//        remove recursively fast enough.
	        //        this means a change in the filestore api. -> 2.5
			$pcache=$this->store->get_filestore("privatecache");
			$ids=$this->store->info($this->store->find($path, "" ,0));
			while (list($key, $value)=@each($ids)) {
				$pcache->purge($value["id"]);
			}
		}
		debug("pobject: ClearCache: end","all");
	}

	function cached($name, $nls="") {
		debug("cached($name)","object");
		global $ARCurrent;
		if ($name) {
			$result=false;
			if (!$nls) {
				$nls=$this->nls;
			}
			$file=$nls.".".$name;
			$pcache=$this->store->get_filestore("privatecache");
			if ( $pcache->exists($this->id, $file) &&
			     ($pcache->mtime($this->id, $file)>time()) ) {
				debug("cached: $name exists, reading from cache.","all");
				// FIXME!: should fix links, replace old session id's; use correct root, etc.
				if ($ARCurrent->session) {
					$session="/-".$ARCurrent->session->id."-";
				}
				echo str_replace("{arSession}", $session, $pcache->read($this->id, $file));
				$result=true;
			} else {
				debug("cached: $name not found, start new cache image.","all");
				$ARCurrent->cache[]=$file;
				debug("cached: ob_start()","all");
				ob_start();
				/* output buffering is recursive, so this won't interfere with
				   normal page caching, unless you forget to call savecache()...
				   so normal pagecache needs to check $ARCurrent->cache, if it's
				   not empty, issue a warning and don't cache the outputbuffer...
				   savecache() must then pop the stack. 
				*/
			}
		} else {
			error("cached() : no name given for cache.");
		}
		return $result;
	}

	function savecache($time="") {
		debug("savecache($time)","object");
		global $ARCurrent;
		if (!$time) {
			$time=2; // 'freshness' in hours.
		}
		/* FIXME!: change links to current root with a placeholder.
		   problem: make_url makes it possible that the image also
		   contains other 'roots'. Which should be changed to their 
		   corresponding correct session id's.
		   possible fix: only replace the session id with a placeholder:
		   <img src="http://a.host.com/-abcd-/en/a/dir/img.gif"> to
		   <img src="http://a.host.com{arSession}/en/a/dir/img.gif">
		   language gets cached correctly.
           better fix: change this->store->root to {arRoot}, then change
           any remaining session id's to {arSession} ?
		*/
		if (($file=array_pop($ARCurrent->cache)) && $image=ob_get_contents()) {
			if ($ARCurrent->session) {
				$image=str_replace("/-".$ARCurrent->session->id."-","{arSession}",$image);
				$session="/-".$ARCurrent->session->id."-";
			}
			//$path=substr($file, 0, strrpos($file, "/"));
			//if (!file_exists($this->store->files."privatecache".$path)) {
			//	ldMkDir("privatecache".$path);
			//}
			//$fp=fopen($this->store->files."privatecache".$file, "w");
			//fwrite($fp, $image);
			//fclose($fp);
			$pcache=$this->store->get_filestore("privatecache");
			$pcache->write($image, $this->id, $file);
			$time=time()+($time*3600);
			if (!$pcache->touch($this->id, $file, $time)) {
				debug("savecache: ERROR: couldn't touch $file","object");
			}
			/* it seems that ob_end_flush doesn't really clean the output
			   output buffer, ob_end_clean() does. With flush, the loader
			   keeps thinking there is something to put in the cache while
			   flush also doesn't echo the buffer out... 
			   FIXME: test again in php 4.0.4 
			*/
			ob_end_clean();
			echo str_replace("{arSession}",$session,$image);
			debug("savecache: ob_end_flush()","all");
		} else {
			error("savecache: no file or image ...");
		}
		debug("savecache: end. ($file)","all");
	}

	function getdata($varname, $nls="none") {
	// function to retrieve variables from $this->data, with the correct
	// language version.
	global $ARCurrent, $HTTP_POST_VARS, $HTTP_GET_VARS;

		debug("pobject: getdata($varname, $nls)","object");
		$result=false;
		if ($nls!="none") {
			if ($ARCurrent->arCallStack) {
				$arCallArgs=end($ARCurrent->arCallStack);
				if (is_array($arCallArgs)) {
					extract($arCallArgs);
				} else if (is_string($arCallArgs)) {
					Parse_Str($arCallArgs);
				}
			}
			if (isset(${$nls}[$varname])) {
				$result=${$nls}[$varname];
			} else if (isset($ARCurrent->$nls->$varname)) {
				$result=$ARCurrent->$nls->$varname;
			} else if (($values=$HTTP_POST_VARS[$nls]) && isset($values[$varname])) {
				$result=$values[$varname];
			} else if (($values=$HTTP_GET_VARS[$nls]) && isset($values[$varname])) {
				$result=$values[$varname];
			} else if (($arStoreVars=$HTTP_POST_VARS["arStoreVars"]) && isset($arStoreVars[$nls][$varname])) {
				$result=$arStoreVars[$nls][$varname];
			} else if (($arStoreVars=$HTTP_GET_VARS["arStoreVars"]) && isset($arStoreVars[$nls][$varname])) {
				$result=$arStoreVars[$nls][$varname];
			}
			if ($result===false) {
				if (isset($this->data->${nls}->${varname})) {
					$result=$this->data->${nls}->${varname};
				}
			}
		} else { // language independant variable.
			if ($ARCurrent->arCallStack) {
				$arCallArgs=end($ARCurrent->arCallStack);
				if (is_array($arCallArgs)) {
					extract($arCallArgs);
				} else if (is_string($arCallArgs)) {
					Parse_Str($arCallArgs);
				}
			}
			if (isset($$varname)) {
				$result=$$varname;
			} else if (isset($ARCurrent->$varname)) {
				$result=$ARCurrent->$varname;
			} else if (isset($HTTP_POST_VARS[$varname])) {
				$result=$HTTP_POST_VARS[$varname];
			} else if (isset($HTTP_GET_VARS[$varname])) {
				$result=$HTTP_GET_VARS[$varname];
			} else if (($arStoreVars=$HTTP_POST_VARS["arStoreVars"]) && isset($arStoreVars[$varname])) {
				debug('POST[arStoreVars]','all');
				$result=$arStoreVars[$varname];
			} else if (($arStoreVars=$HTTP_GET_VARS["arStoreVars"]) && isset($arStoreVars[$varname])) {
				$result=$arStoreVars[$varname];
			}
			if ($result===false) {
				if (isset($this->data->$varname)) {
					$result=$this->data->$varname;
				}
			}        
		}
		debug("getdata: end: result=$result","all");
		return $result;
	}

	function showdata($varname, $nls="none") {
		debug("pobject: showdata($varname, $nls)","object");
		echo $this->getdata($varname, $nls);
	}

	function setnls($nls) {
		debug("pobject: setnls($nls)","object");
		ldSetNls($nls);
	}

	function getcharset() {
		global $AR;
		if (!($charset=$AR->nls->charsets[$this->nls])) {
			$charset=$AR->nls->charsets["default"];
		}
		return $charset;
	}

/********************************************************************

  "safe" functions.

  The following functions are safe versions of existing functions
  above. 
  - They don't change anything in the database. 
    This means that to save/delete something, a user will need to call
    "system.save.data.phtml" or "system.delete.phtml" which check grants.
  - All functions except _get and _exists don't take a path as 
    argument, they use the current objects path instead.

  These are meant to be used by 'pinp' versions of templates,
  meaning user defined templates. 'pinp' rewrites call to functions
  to the form '$this->_function'.

  All pinp files automatically first call CheckLogin('read').
  
********************************************************************/

	function _call($function, $args="") {
		// remove possible path information (greedy match)
		eregi('(.*[/\\])?(.*)', $function, $regs);
		$function=$regs[2];
		return $this->call($function, $args);
	}

	function _get($path, $function="view.html", $args="") {
		debug("pobject: get($path, $function, $args)","object");
		// remove possible path information (greedy match)
		eregi('(.*[/\\])?(.*)', $function, $regs);
		$function=$regs[2];
		return $this->store->call($function, $args, 
			$this->store->get(
				$this->make_path($path))); 
	}

	function _call_object($object, $function, $args="") {
		return $object->call($function, $args);
	}

	function _ls($function="list.html", $args="") {
		debug("pobject: ls($function, $args)","object");
		// remove possible path information (greedy match)
		eregi('(.*[/\\])?(.*)', $function, $regs);
		$function=$regs[2];
		return $this->store->call($function, $args, 
			$this->store->ls($this->path));
	}

	function _parents($function="list.html", $args="", $top="/") {
		debug("pobject: parents($function, $args)","object");
		// remove possible path information (greedy match)
		eregi('(.*[/\\])?(.*)', $function, $regs);
		$function=$regs[2];
		return $this->store->call($function, $args, 
			$this->store->parents($this->path, $top));
	}

	function _find($criteria, $function="list.html", $args="", $limit=100, $offset=0) {
		// remove possible path information (greedy match)
		eregi('(.*[/\\])?(.*)', $function, $regs);
		$function=$regs[2];
		return $this->store->call($function, $args, 
		$this->store->find($this->path, $criteria, $limit, $offset));
	}

	function _exists($path) {
		debug("pobject: exists($path)","object");
		return $this->store->exists($this->make_path($path));
	}

	function _getvar($var) {
	global $HTTP_POST_VARS, $HTTP_GET_VARS, $ARCurrent, $ARConfig;

		debug("pobject: getvar($var)","object");
		if ($ARCurrent->arCallStack) {
			$arCallArgs=end($ARCurrent->arCallStack);
			if (is_array($arCallArgs)) {
				extract($arCallArgs);
			} else if (is_string($arCallArgs)) {
				Parse_Str($arCallArgs);
			}
		}
		if ($$var) {
			$result=$$var;
		} if ($ARCurrent->$var) {
			$result=$ARCurrent->$var;
		} else if ($HTTP_POST_VARS[$var]) {
			$result=$HTTP_POST_VARS[$var];
		} else if ($HTTP_GET_VARS[$var]) {
			$result=$HTTP_GET_VARS[$var];
		} 
		return $result;
	}

	function _putvar($var, $value) {
	global $ARCurrent;

		debug("pobject: putvar($var, $value)","object");
		$ARCurrent->$var=$value;
	}  

	function _setnls($nls) {
		$this->setnls($nls);
	}

	function _widget($arWidgetName, $arWidgetTemplate, $arWidgetArgs="") {
	global $AR, $ARConfig, $ARCurrent, $ARnls;

		debug("pobject: widget($arWidgetName, $arWidgetTemplate, $arWidgetArgs)","object");
		$arWidgetName=ereg_replace("[^a-zA-Z0-9\.]","",$arWidgetName);
		$arWidgetTemplate=ereg_replace("[^a-zA-Z0-9\.]","",$arWidgetTemplate);
		if (file_exists($this->store->code."widgets/$arWidgetName")) {
			if (file_exists($this->store->code."widgets/$arWidgetName/$arWidgetTemplate")) {
				if (is_array($arWidgetArgs)) {
					extract($arWidgetArgs);
				} else if (is_string($arWidgetArgs)) {
					Parse_str($arWidgetArgs);
				}
				include($this->store->code."widgets/$arWidgetName/$arWidgetTemplate");
			} else {
				error("Template $arWidgetTemplate for widget $arWidgetName not found.");
			}
		} else {
			error("Widget $wgName not found");
		}
		if ($wgResult) {
			return $wgResult;
		}
	}

	function _getdata($varname, $nls="none") { 
		return $this->getdata($varname, $nls);
	}

	function _showdata($varname, $nls="none") {
		$this->showdata($varname, $nls);
	}

	function _gettext($index) {
	global $ARnls;
		return $ARnls[$index];
	}

	function _startsession() {
	global $ARCurrent;
		ldStartSession(0);
		return $ARCurrent->session->id;
	}

	function _putsessionvar($varname, $varvalue) {
	global $ARCurrent;

		$ARCurrent->session->put($varname, $varvalue);
	}

	function _getsessionvar($varname) {
	global $ARCurrent;

		return $ARCurrent->session->get($varname);
	}

	function _killsession() {
	global $ARCurrent;

		$ARCurrent->session->kill();
	}

	function _sessionid() {
	global $ARCurrent;
		if ($ARCurrent->session) {
			return $ARCurrent->session->id;
		} else {
			return 0;
		}
	}

	function _resetloopcheck() {
		global $ARBeenHere;
		$ARBeenHere=Array();
	}

	function _make_path($path="") {
		return $this->make_path($path);
	}

	function _make_url($path="") {
		return $this->make_url($path);
	}

	function _cached($name) {
		return $this->cached($name);
	}

	function _savecache($time="") {
		return $this->savecache($time);
	}

	function _currentsite() {
		global $ARConfig;
		$config=$ARConfig->cache[$this->path];
		return $config->site;
	}

	function _parentsite($site) {
		global $ARConfig;
		$path=$this->store->make_path($site, "..");
		$config=$ARConfig->cache[$path];
		return $config->site;
	}

	function _checkgrant($grant) {
		// as this is called within a pinp template, 
		// all the grants are already loaded, so
		// checksilent will fullfill our needs

		return $this->CheckSilent($grant);
	}

	function _getcharset() {
		return $this->getcharset();
	}
} // end class pobject
?>